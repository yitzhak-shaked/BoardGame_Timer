<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.BoardGameTimer&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.BoardGameTimer&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.OptionsActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:label=&quot;Game Options&quot;&#10;            android:theme=&quot;@style/Theme.BoardGameTimer&quot; /&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.BoardGameTimer&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:screenOrientation=&quot;portrait&quot;&#10;            android:theme=&quot;@style/Theme.BoardGameTimer&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.OptionsActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:label=&quot;Game Options&quot;&#10;            android:screenOrientation=&quot;portrait&quot;&#10;            android:theme=&quot;@style/Theme.BoardGameTimer&quot; /&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/ui/components/DiceComponents.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/ui/components/DiceComponents.kt" />
              <option name="originalContent" value="package com.example.boardgametimer.ui.components&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.*&#10;import androidx.compose.ui.graphics.drawscope.DrawScope&#10;import androidx.compose.ui.graphics.drawscope.Stroke&#10;import androidx.compose.ui.graphics.drawscope.rotate&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.example.boardgametimer.model.DiceType&#10;import com.example.boardgametimer.model.DiceResult&#10;import kotlin.math.*&#10;&#10;@Composable&#10;fun DiceDisplay(&#10;    diceType: DiceType,&#10;    diceCount: Int,&#10;    diceResult: DiceResult?,&#10;    isAnimating: Boolean,&#10;    circleSize: Dp,&#10;    onDiceClick: () -&gt; Unit,&#10;    onNextPhase: () -&gt; Unit = {},&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Box(&#10;        modifier = modifier&#10;            .size(circleSize * 0.6f)&#10;            .clip(CircleShape)&#10;            .clickable {&#10;                if (diceResult != null &amp;&amp; !isAnimating) {&#10;                    // After dice are thrown, clicking should move to next phase&#10;                    onNextPhase()&#10;                } else {&#10;                    // Before throwing, clicking should throw dice&#10;                    onDiceClick()&#10;                }&#10;            },&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        if (diceResult != null) {&#10;            if (diceCount == 1) {&#10;                // Single die - show large die with polygon and number&#10;                SingleDiceDisplay(&#10;                    diceType = diceType,&#10;                    value = diceResult.values.first(),&#10;                    isAnimating = isAnimating,&#10;                    size = circleSize * 0.5f&#10;                )&#10;            } else {&#10;                // Multiple dice - show individual results with sum below&#10;                MultipleDiceDisplay(&#10;                    diceType = diceType,&#10;                    diceResult = diceResult,&#10;                    isAnimating = isAnimating,&#10;                    circleSize = circleSize&#10;                )&#10;            }&#10;        } else {&#10;            // Waiting to throw - show instruction&#10;            WaitingToThrowDisplay(diceType, diceCount, circleSize)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SingleDiceDisplay(&#10;    diceType: DiceType,&#10;    value: Int,&#10;    isAnimating: Boolean,&#10;    size: Dp&#10;) {&#10;    // Draw the polygon shape for the die with the number inside&#10;    DicePolygon(&#10;        diceType = diceType,&#10;        size = size,&#10;        isAnimating = isAnimating,&#10;        value = value&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun MultipleDiceDisplay(&#10;    diceType: DiceType,&#10;    diceResult: DiceResult,&#10;    isAnimating: Boolean,&#10;    circleSize: Dp&#10;) {&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        // Show individual dice results in a grid-like layout&#10;        val diceSize = (circleSize.value / (diceResult.values.size + 1)).dp.coerceAtMost(40.dp)&#10;&#10;        if (diceResult.values.size &lt;= 5) {&#10;            // Single row for 5 or fewer dice&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(4.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                diceResult.values.forEach { value -&gt;&#10;                    IndividualDie(&#10;                        diceType = diceType,&#10;                        value = value,&#10;                        size = diceSize,&#10;                        isAnimating = isAnimating&#10;                    )&#10;                }&#10;            }&#10;        } else {&#10;            // Two rows for more than 5 dice&#10;            val firstRowCount = ceil(diceResult.values.size / 2.0).toInt()&#10;&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(4.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                diceResult.values.take(firstRowCount).forEach { value -&gt;&#10;                    IndividualDie(&#10;                        diceType = diceType,&#10;                        value = value,&#10;                        size = diceSize,&#10;                        isAnimating = isAnimating&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(4.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                diceResult.values.drop(firstRowCount).forEach { value -&gt;&#10;                    IndividualDie(&#10;                        diceType = diceType,&#10;                        value = value,&#10;                        size = diceSize,&#10;                        isAnimating = isAnimating&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        // Show total sum&#10;        Text(&#10;            text = &quot;Total: ${diceResult.total}&quot;,&#10;            fontSize = (circleSize.value / 12).sp,&#10;            fontWeight = FontWeight.Bold,&#10;            textAlign = TextAlign.Center,&#10;            color = MaterialTheme.colorScheme.primary&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun IndividualDie(&#10;    diceType: DiceType,&#10;    value: Int,&#10;    size: Dp,&#10;    isAnimating: Boolean&#10;) {&#10;    // Draw the polygon shape for the die with the number inside&#10;    DicePolygon(&#10;        diceType = diceType,&#10;        size = size,&#10;        isAnimating = isAnimating,&#10;        value = value&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun WaitingToThrowDisplay(&#10;    diceType: DiceType,&#10;    diceCount: Int,&#10;    circleSize: Dp&#10;) {&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        Text(&#10;            text = &quot;${diceCount}${diceType.displayName}&quot;,&#10;            fontSize = (circleSize.value / 10).sp,&#10;            fontWeight = FontWeight.Bold,&#10;            textAlign = TextAlign.Center,&#10;            color = MaterialTheme.colorScheme.primary&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(4.dp))&#10;&#10;        Text(&#10;            text = &quot;Tap to throw&quot;,&#10;            fontSize = (circleSize.value / 14).sp,&#10;            fontWeight = FontWeight.Medium,&#10;            textAlign = TextAlign.Center,&#10;            color = MaterialTheme.colorScheme.onSurface&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        // Show a preview of the die shape&#10;        DicePolygon(&#10;            diceType = diceType,&#10;            size = circleSize * 0.25f,&#10;            isAnimating = false&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun DicePolygon(&#10;    diceType: DiceType,&#10;    size: Dp,&#10;    isAnimating: Boolean,&#10;    value: Int? = null // Optional value for dice display&#10;) {&#10;    // Synchronize rotation changes with value changes&#10;    val animationRotation = if (isAnimating &amp;&amp; value != null) {&#10;        // Create a rotation that changes when the value changes&#10;        var currentRotation by remember { mutableStateOf(0f) }&#10;        LaunchedEffect(value) {&#10;            // When value changes, pick a new random rotation&#10;            currentRotation = (0..7).random() * 45f&#10;        }&#10;        currentRotation&#10;    } else {&#10;        0f&#10;    }&#10;&#10;    Box(&#10;        modifier = Modifier.size(size),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        // Draw the polygon shape&#10;        Canvas(&#10;            modifier = Modifier.size(size)&#10;        ) {&#10;            val center = Offset(size.toPx() / 2, size.toPx() / 2)&#10;            val radius = size.toPx() / 2 * 0.8f&#10;&#10;            rotate(animationRotation, center) {&#10;                when (diceType) {&#10;                    DiceType.D2 -&gt; drawCircle(center, radius)&#10;                    DiceType.D4 -&gt; drawTriangle(center, radius)&#10;                    DiceType.D6 -&gt; drawSquare(center, radius)&#10;                    DiceType.D8 -&gt; drawOctagon(center, radius)&#10;                    DiceType.D10 -&gt; drawDecagon(center, radius)&#10;                    DiceType.D20 -&gt; drawIcosagon(center, radius)&#10;                    DiceType.D100 -&gt; drawDecagon(center, radius) // Use decagon for d100&#10;                }&#10;            }&#10;        }&#10;&#10;        // Draw the value as a Text component overlayed on top&#10;        if (value != null) {&#10;            Text(&#10;                text = value.toString(),&#10;                fontSize = (size.value / 3.5f).sp,&#10;                fontWeight = FontWeight.Bold,&#10;                color = Color.White,&#10;                textAlign = TextAlign.Center,&#10;                modifier = Modifier&#10;                    .align(Alignment.Center)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;private fun DrawScope.drawCircle(center: Offset, radius: Float) {&#10;    drawCircle(&#10;        color = Color.Blue,&#10;        radius = radius,&#10;        center = center,&#10;        style = Stroke(width = 3.dp.toPx())&#10;    )&#10;}&#10;&#10;private fun DrawScope.drawTriangle(center: Offset, radius: Float) {&#10;    val path = Path().apply {&#10;        val angle = 2 * PI / 3&#10;        for (i in 0..2) {&#10;            val x = center.x + radius * cos(angle * i - PI / 2).toFloat()&#10;            val y = center.y + radius * sin(angle * i - PI / 2).toFloat()&#10;            if (i == 0) moveTo(x, y) else lineTo(x, y)&#10;        }&#10;        close()&#10;    }&#10;    drawPath(&#10;        path = path,&#10;        color = Color.Green,&#10;        style = Stroke(width = 3.dp.toPx())&#10;    )&#10;}&#10;&#10;private fun DrawScope.drawSquare(center: Offset, radius: Float) {&#10;    val side = radius * sqrt(2f)&#10;    drawRect(&#10;        color = Color.Red,&#10;        topLeft = Offset(center.x - side / 2, center.y - side / 2),&#10;        size = Size(side, side),&#10;        style = Stroke(width = 3.dp.toPx())&#10;    )&#10;}&#10;&#10;private fun DrawScope.drawPolygon(center: Offset, radius: Float, sides: Int, color: Color) {&#10;    val path = Path().apply {&#10;        val angle = 2 * PI / sides&#10;        for (i in 0 until sides) {&#10;            val x = center.x + radius * cos(angle * i - PI / 2).toFloat()&#10;            val y = center.y + radius * sin(angle * i - PI / 2).toFloat()&#10;            if (i == 0) moveTo(x, y) else lineTo(x, y)&#10;        }&#10;        close()&#10;    }&#10;    drawPath(&#10;        path = path,&#10;        color = color,&#10;        style = Stroke(width = 3.dp.toPx())&#10;    )&#10;}&#10;&#10;private fun DrawScope.drawOctagon(center: Offset, radius: Float) {&#10;    drawPolygon(center, radius, 8, Color.Magenta)&#10;}&#10;&#10;private fun DrawScope.drawDecagon(center: Offset, radius: Float) {&#10;    drawPolygon(center, radius, 10, Color.Cyan)&#10;}&#10;&#10;private fun DrawScope.drawIcosagon(center: Offset, radius: Float) {&#10;    drawPolygon(center, radius, 20, Color.Yellow)&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.boardgametimer.ui.components&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.*&#10;import androidx.compose.ui.graphics.drawscope.DrawScope&#10;import androidx.compose.ui.graphics.drawscope.Stroke&#10;import androidx.compose.ui.graphics.drawscope.rotate&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.example.boardgametimer.model.DiceType&#10;import com.example.boardgametimer.model.DiceResult&#10;import kotlin.math.*&#10;&#10;@Composable&#10;fun DiceDisplay(&#10;    diceType: DiceType,&#10;    diceCount: Int,&#10;    diceResult: DiceResult?,&#10;    isAnimating: Boolean,&#10;    circleSize: Dp,&#10;    onDiceClick: () -&gt; Unit,&#10;    onNextPhase: () -&gt; Unit = {},&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Box(&#10;        modifier = modifier&#10;            .size(circleSize * 0.6f)&#10;            .clip(CircleShape)&#10;            .clickable {&#10;                if (diceResult != null &amp;&amp; !isAnimating) {&#10;                    // After dice are thrown, clicking should move to next phase&#10;                    onNextPhase()&#10;                } else {&#10;                    // Before throwing, clicking should throw dice&#10;                    onDiceClick()&#10;                }&#10;            },&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        if (diceResult != null) {&#10;            if (diceCount == 1) {&#10;                // Single die - show large die with polygon and number&#10;                SingleDiceDisplay(&#10;                    diceType = diceType,&#10;                    value = diceResult.values.first(),&#10;                    isAnimating = isAnimating,&#10;                    size = circleSize * 0.5f&#10;                )&#10;            } else {&#10;                // Multiple dice - show individual results with sum below&#10;                MultipleDiceDisplay(&#10;                    diceType = diceType,&#10;                    diceResult = diceResult,&#10;                    isAnimating = isAnimating,&#10;                    circleSize = circleSize&#10;                )&#10;            }&#10;        } else {&#10;            // Waiting to throw - show instruction&#10;            WaitingToThrowDisplay(diceType, diceCount, circleSize)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SingleDiceDisplay(&#10;    diceType: DiceType,&#10;    value: Int,&#10;    isAnimating: Boolean,&#10;    size: Dp&#10;) {&#10;    // Draw the polygon shape for the die with the number inside&#10;    DicePolygon(&#10;        diceType = diceType,&#10;        size = size,&#10;        isAnimating = isAnimating,&#10;        value = value&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun MultipleDiceDisplay(&#10;    diceType: DiceType,&#10;    diceResult: DiceResult,&#10;    isAnimating: Boolean,&#10;    circleSize: Dp&#10;) {&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        // Calculate dice size based on actual available space&#10;        // The DiceDisplay container uses circleSize * 0.6f, so we need to work within that&#10;        val containerSize = circleSize * 0.6f&#10;        val availableWidth = containerSize * 0.95f // Use 95% of container width for better space utilization&#10;        val spacing = 3.dp // Reduced spacing to allow for larger dice&#10;        val diceCount = diceResult.values.size&#10;&#10;        val diceSize = if (diceCount &lt;= 5) {&#10;            // Single row - calculate size based on available width&#10;            val totalSpacing = spacing * (diceCount - 1)&#10;            val availableForDice = availableWidth - totalSpacing&#10;            val calculatedSize = (availableForDice.value / diceCount).dp&#10;            &#10;            // Use more generous size limits for better space utilization&#10;            when (diceCount) {&#10;                1 -&gt; calculatedSize.coerceAtMost(120.dp).coerceAtLeast(60.dp)&#10;                2 -&gt; calculatedSize.coerceAtMost(100.dp).coerceAtLeast(50.dp)&#10;                3 -&gt; calculatedSize.coerceAtMost(80.dp).coerceAtLeast(40.dp)&#10;                4 -&gt; calculatedSize.coerceAtMost(70.dp).coerceAtLeast(35.dp)&#10;                5 -&gt; calculatedSize.coerceAtMost(60.dp).coerceAtLeast(30.dp)&#10;                else -&gt; calculatedSize.coerceAtMost(50.dp).coerceAtLeast(25.dp)&#10;            }&#10;        } else {&#10;            // Two rows - calculate based on the larger row&#10;            val firstRowCount = ceil(diceCount / 2.0).toInt()&#10;            val totalSpacing = spacing * (firstRowCount - 1)&#10;            val availableForDice = availableWidth - totalSpacing&#10;            (availableForDice.value / firstRowCount).dp.coerceAtMost(50.dp).coerceAtLeast(20.dp)&#10;        }&#10;&#10;        if (diceResult.values.size &lt;= 5) {&#10;            // Single row for 5 or fewer dice&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(4.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                diceResult.values.forEach { value -&gt;&#10;                    IndividualDie(&#10;                        diceType = diceType,&#10;                        value = value,&#10;                        size = diceSize,&#10;                        isAnimating = isAnimating&#10;                    )&#10;                }&#10;            }&#10;        } else {&#10;            // Two rows for more than 5 dice&#10;            val firstRowCount = ceil(diceResult.values.size / 2.0).toInt()&#10;&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(4.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                diceResult.values.take(firstRowCount).forEach { value -&gt;&#10;                    IndividualDie(&#10;                        diceType = diceType,&#10;                        value = value,&#10;                        size = diceSize,&#10;                        isAnimating = isAnimating&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(4.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                diceResult.values.drop(firstRowCount).forEach { value -&gt;&#10;                    IndividualDie(&#10;                        diceType = diceType,&#10;                        value = value,&#10;                        size = diceSize,&#10;                        isAnimating = isAnimating&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        // Show total sum&#10;        Text(&#10;            text = &quot;Total: ${diceResult.total}&quot;,&#10;            fontSize = (circleSize.value / 12).sp,&#10;            fontWeight = FontWeight.Bold,&#10;            textAlign = TextAlign.Center,&#10;            color = MaterialTheme.colorScheme.primary&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun IndividualDie(&#10;    diceType: DiceType,&#10;    value: Int,&#10;    size: Dp,&#10;    isAnimating: Boolean&#10;) {&#10;    // Draw the polygon shape for the die with the number inside&#10;    DicePolygon(&#10;        diceType = diceType,&#10;        size = size,&#10;        isAnimating = isAnimating,&#10;        value = value&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun WaitingToThrowDisplay(&#10;    diceType: DiceType,&#10;    diceCount: Int,&#10;    circleSize: Dp&#10;) {&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        Text(&#10;            text = &quot;${diceCount}${diceType.displayName}&quot;,&#10;            fontSize = (circleSize.value / 10).sp,&#10;            fontWeight = FontWeight.Bold,&#10;            textAlign = TextAlign.Center,&#10;            color = MaterialTheme.colorScheme.primary&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(4.dp))&#10;&#10;        Text(&#10;            text = &quot;Tap to throw&quot;,&#10;            fontSize = (circleSize.value / 14).sp,&#10;            fontWeight = FontWeight.Medium,&#10;            textAlign = TextAlign.Center,&#10;            color = MaterialTheme.colorScheme.onSurface&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        // Show a preview of the die shape&#10;        DicePolygon(&#10;            diceType = diceType,&#10;            size = circleSize * 0.25f,&#10;            isAnimating = false&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun DicePolygon(&#10;    diceType: DiceType,&#10;    size: Dp,&#10;    isAnimating: Boolean,&#10;    value: Int? = null // Optional value for dice display&#10;) {&#10;    // Synchronize rotation changes with value changes&#10;    val animationRotation = if (isAnimating &amp;&amp; value != null) {&#10;        // Create a rotation that changes when the value changes&#10;        var currentRotation by remember { mutableStateOf(0f) }&#10;        LaunchedEffect(value) {&#10;            // When value changes, pick a new random rotation with more possibilities&#10;            // Use 72 different orientations (every 5 degrees) to ensure visible changes&#10;            currentRotation = (0..71).random() * 5f&#10;        }&#10;        currentRotation&#10;    } else {&#10;        0f&#10;    }&#10;&#10;    Box(&#10;        modifier = Modifier.size(size),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        // Draw the polygon shape&#10;        Canvas(&#10;            modifier = Modifier.size(size)&#10;        ) {&#10;            val center = Offset(size.toPx() / 2, size.toPx() / 2)&#10;            val radius = size.toPx() / 2 * 0.8f&#10;&#10;            rotate(animationRotation, center) {&#10;                when (diceType) {&#10;                    DiceType.D2 -&gt; drawCircle(center, radius)&#10;                    DiceType.D4 -&gt; drawTriangle(center, radius)&#10;                    DiceType.D6 -&gt; drawSquare(center, radius)&#10;                    DiceType.D8 -&gt; drawOctagon(center, radius)&#10;                    DiceType.D10 -&gt; drawDecagon(center, radius)&#10;                    DiceType.D20 -&gt; drawIcosagon(center, radius)&#10;                    DiceType.D100 -&gt; drawDecagon(center, radius) // Use decagon for d100&#10;                }&#10;            }&#10;        }&#10;&#10;        // Draw the value as a Text component overlayed on top&#10;        if (value != null) {&#10;            Text(&#10;                text = value.toString(),&#10;                fontSize = (size.value / 3.5f).sp,&#10;                fontWeight = FontWeight.Bold,&#10;                color = Color.White,&#10;                textAlign = TextAlign.Center,&#10;                modifier = Modifier&#10;                    .align(Alignment.Center)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;private fun DrawScope.drawCircle(center: Offset, radius: Float) {&#10;    drawCircle(&#10;        color = Color.Blue,&#10;        radius = radius,&#10;        center = center,&#10;        style = Stroke(width = 3.dp.toPx())&#10;    )&#10;}&#10;&#10;private fun DrawScope.drawTriangle(center: Offset, radius: Float) {&#10;    val path = Path().apply {&#10;        val angle = 2 * PI / 3&#10;        for (i in 0..2) {&#10;            val x = center.x + radius * cos(angle * i - PI / 2).toFloat()&#10;            val y = center.y + radius * sin(angle * i - PI / 2).toFloat()&#10;            if (i == 0) moveTo(x, y) else lineTo(x, y)&#10;        }&#10;        close()&#10;    }&#10;    drawPath(&#10;        path = path,&#10;        color = Color.Green,&#10;        style = Stroke(width = 3.dp.toPx())&#10;    )&#10;}&#10;&#10;private fun DrawScope.drawSquare(center: Offset, radius: Float) {&#10;    val side = radius * sqrt(2f)&#10;    drawRect(&#10;        color = Color.Red,&#10;        topLeft = Offset(center.x - side / 2, center.y - side / 2),&#10;        size = Size(side, side),&#10;        style = Stroke(width = 3.dp.toPx())&#10;    )&#10;}&#10;&#10;private fun DrawScope.drawPolygon(center: Offset, radius: Float, sides: Int, color: Color) {&#10;    val path = Path().apply {&#10;        val angle = 2 * PI / sides&#10;        for (i in 0 until sides) {&#10;            val x = center.x + radius * cos(angle * i - PI / 2).toFloat()&#10;            val y = center.y + radius * sin(angle * i - PI / 2).toFloat()&#10;            if (i == 0) moveTo(x, y) else lineTo(x, y)&#10;        }&#10;        close()&#10;    }&#10;    drawPath(&#10;        path = path,&#10;        color = color,&#10;        style = Stroke(width = 3.dp.toPx())&#10;    )&#10;}&#10;&#10;private fun DrawScope.drawOctagon(center: Offset, radius: Float) {&#10;    drawPolygon(center, radius, 8, Color.Magenta)&#10;}&#10;&#10;private fun DrawScope.drawDecagon(center: Offset, radius: Float) {&#10;    drawPolygon(center, radius, 10, Color.Cyan)&#10;}&#10;&#10;private fun DrawScope.drawIcosagon(center: Offset, radius: Float) {&#10;    drawPolygon(center, radius, 20, Color.Yellow)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/ui/components/StatsDialog.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/ui/components/StatsDialog.kt" />
              <option name="originalContent" value="package com.example.boardgametimer.ui.components&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.window.Dialog&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.GameState&#10;import java.util.Locale&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun StatsDialog(&#10;    gameState: GameState,&#10;    gameConfiguration: GameConfiguration,&#10;    onDismiss: () -&gt; Unit,&#10;    onNewGame: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Dialog(onDismissRequest = onDismiss) {&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .fillMaxHeight(0.8f)&#10;                .padding(16.dp),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 8.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(16.dp)&#10;            ) {&#10;                // Header&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Game Statistics&quot;,&#10;                        fontSize = 20.sp,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                    IconButton(onClick = onDismiss) {&#10;                        Icon(Icons.Default.Close, contentDescription = &quot;Close&quot;)&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                LazyColumn(&#10;                    modifier = Modifier.weight(1f),&#10;                    verticalArrangement = Arrangement.spacedBy(16.dp)&#10;                ) {&#10;                    item {&#10;                        // Overall Stats&#10;                        Card(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;                        ) {&#10;                            Column(modifier = Modifier.padding(16.dp)) {&#10;                                Text(&#10;                                    text = &quot;Overall Statistics&quot;,&#10;                                    fontWeight = FontWeight.Medium,&#10;                                    fontSize = 16.sp&#10;                                )&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                                StatRow(&quot;Total Rounds&quot;, gameState.getTotalRounds().toString())&#10;                                StatRow(&quot;Average Turn Time&quot;, formatTime(gameState.getOverallAverageTime().toInt()))&#10;                                StatRow(&quot;Total Players&quot;, gameConfiguration.numberOfPlayers.toString())&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    item {&#10;                        // Player Statistics&#10;                        Card(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;                        ) {&#10;                            Column(modifier = Modifier.padding(16.dp)) {&#10;                                Text(&#10;                                    text = &quot;Player Statistics&quot;,&#10;                                    fontWeight = FontWeight.Medium,&#10;                                    fontSize = 16.sp&#10;                                )&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                                repeat(gameConfiguration.numberOfPlayers) { playerIndex -&gt;&#10;                                    PlayerStatCard(&#10;                                        playerName = gameConfiguration.getPlayerName(playerIndex),&#10;                                        averageTime = gameState.getAverageTimeForPlayer(playerIndex),&#10;                                        totalTurns = if (playerIndex &lt; gameState.playerTurnTimes.size)&#10;                                            gameState.playerTurnTimes[playerIndex].size else 0&#10;                                    )&#10;                                    if (playerIndex &lt; gameConfiguration.numberOfPlayers - 1) {&#10;                                        Spacer(modifier = Modifier.height(8.dp))&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                // Action Buttons&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    OutlinedButton(&#10;                        onClick = onDismiss,&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;Close&quot;)&#10;                    }&#10;&#10;                    Button(&#10;                        onClick = {&#10;                            onNewGame()&#10;                            onDismiss()&#10;                        },&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;New Game&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun StatRow(&#10;    label: String,&#10;    value: String&#10;) {&#10;    Row(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        horizontalArrangement = Arrangement.SpaceBetween&#10;    ) {&#10;        Text(&#10;            text = label,&#10;            fontSize = 14.sp&#10;        )&#10;        Text(&#10;            text = value,&#10;            fontSize = 14.sp,&#10;            fontWeight = FontWeight.Medium&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun PlayerStatCard(&#10;    playerName: String,&#10;    averageTime: Double,&#10;    totalTurns: Int&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(12.dp)&#10;        ) {&#10;            Text(&#10;                text = playerName,&#10;                fontWeight = FontWeight.Medium,&#10;                fontSize = 14.sp&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                Text(&#10;                    text = &quot;Avg: ${formatTime(averageTime.toInt())}&quot;,&#10;                    fontSize = 12.sp,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;                Text(&#10;                    text = &quot;Turns: $totalTurns&quot;,&#10;                    fontSize = 12.sp,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private fun formatTime(seconds: Int): String {&#10;    val minutes = seconds / 60&#10;    val remainingSeconds = seconds % 60&#10;    return String.format(Locale.getDefault(), &quot;%d:%02d&quot;, minutes, remainingSeconds)&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.boardgametimer.ui.components&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.window.Dialog&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.GameState&#10;import java.util.Locale&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun StatsDialog(&#10;    gameState: GameState,&#10;    gameConfiguration: GameConfiguration,&#10;    onDismiss: () -&gt; Unit,&#10;    onNewGame: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Dialog(onDismissRequest = onDismiss) {&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth(0.95f) // Increased from default to make wider&#10;                .fillMaxHeight(0.85f) // Increased from 0.8f&#10;                .padding(8.dp), // Reduced padding to use more screen space&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 8.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(20.dp) // Increased from 16.dp&#10;            ) {&#10;                // Header&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Game Statistics&quot;,&#10;                        fontSize = 24.sp, // Increased from 20.sp&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                    IconButton(onClick = onDismiss) {&#10;                        Icon(Icons.Default.Close, contentDescription = &quot;Close&quot;)&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(20.dp)) // Increased from 16.dp&#10;&#10;                LazyColumn(&#10;                    modifier = Modifier.weight(1f),&#10;                    verticalArrangement = Arrangement.spacedBy(20.dp) // Increased from 16.dp&#10;                ) {&#10;                    item {&#10;                        // Overall Stats&#10;                        Card(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;                        ) {&#10;                            Column(modifier = Modifier.padding(20.dp)) { // Increased from 16.dp&#10;                                Text(&#10;                                    text = &quot;Overall Statistics&quot;,&#10;                                    fontWeight = FontWeight.Medium,&#10;                                    fontSize = 18.sp // Increased from 16.sp&#10;                                )&#10;                                Spacer(modifier = Modifier.height(12.dp)) // Increased from 8.dp&#10;&#10;                                StatRow(&quot;Total Rounds&quot;, gameState.getTotalRounds().toString())&#10;                                StatRow(&quot;Average Turn Time&quot;, formatTime(gameState.getOverallAverageTime().toInt()))&#10;                                StatRow(&quot;Total Players&quot;, gameConfiguration.numberOfPlayers.toString())&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    item {&#10;                        // Player Statistics&#10;                        Card(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;                        ) {&#10;                            Column(modifier = Modifier.padding(20.dp)) { // Increased from 16.dp&#10;                                Text(&#10;                                    text = &quot;Player Statistics&quot;,&#10;                                    fontWeight = FontWeight.Medium,&#10;                                    fontSize = 18.sp // Increased from 16.sp&#10;                                )&#10;                                Spacer(modifier = Modifier.height(12.dp)) // Increased from 8.dp&#10;&#10;                                repeat(gameConfiguration.numberOfPlayers) { playerIndex -&gt;&#10;                                    PlayerStatCard(&#10;                                        playerName = gameConfiguration.getPlayerName(playerIndex),&#10;                                        averageTime = gameState.getAverageTimeForPlayer(playerIndex),&#10;                                        totalTurns = if (playerIndex &lt; gameState.playerTurnTimes.size)&#10;                                            gameState.playerTurnTimes[playerIndex].size else 0&#10;                                    )&#10;                                    if (playerIndex &lt; gameConfiguration.numberOfPlayers - 1) {&#10;                                        Spacer(modifier = Modifier.height(12.dp)) // Increased from 8.dp&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(20.dp)) // Increased from 16.dp&#10;&#10;                // Action Buttons&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp) // Increased from 8.dp&#10;                ) {&#10;                    OutlinedButton(&#10;                        onClick = onDismiss,&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;Close&quot;, fontSize = 16.sp) // Added larger font size&#10;                    }&#10;&#10;                    Button(&#10;                        onClick = {&#10;                            onNewGame()&#10;                            onDismiss()&#10;                        },&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;New Game&quot;, fontSize = 16.sp) // Added larger font size&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun StatRow(&#10;    label: String,&#10;    value: String&#10;) {&#10;    Row(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        horizontalArrangement = Arrangement.SpaceBetween&#10;    ) {&#10;        Text(&#10;            text = label,&#10;            fontSize = 16.sp // Increased from 14.sp&#10;        )&#10;        Text(&#10;            text = value,&#10;            fontSize = 16.sp, // Increased from 14.sp&#10;            fontWeight = FontWeight.Medium&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun PlayerStatCard(&#10;    playerName: String,&#10;    averageTime: Double,&#10;    totalTurns: Int&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp) // Increased from 12.dp&#10;        ) {&#10;            Text(&#10;                text = playerName,&#10;                fontWeight = FontWeight.Medium,&#10;                fontSize = 16.sp // Increased from 14.sp&#10;            )&#10;            Spacer(modifier = Modifier.height(6.dp)) // Increased from 4.dp&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                Text(&#10;                    text = &quot;Avg: ${formatTime(averageTime.toInt())}&quot;,&#10;                    fontSize = 14.sp, // Increased from 12.sp&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;                Text(&#10;                    text = &quot;Turns: $totalTurns&quot;,&#10;                    fontSize = 14.sp, // Increased from 12.sp&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private fun formatTime(seconds: Int): String {&#10;    val minutes = seconds / 60&#10;    val remainingSeconds = seconds % 60&#10;    return String.format(Locale.getDefault(), &quot;%d:%02d&quot;, minutes, remainingSeconds)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModel.kt" />
              <option name="originalContent" value="package com.example.boardgametimer.viewmodel&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.media.AudioManager&#10;import android.media.ToneGenerator&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.speech.tts.TextToSpeech&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.GameState&#10;import com.example.boardgametimer.model.SavedConfiguration&#10;import com.example.boardgametimer.model.DicePhaseState&#10;import com.example.boardgametimer.model.PhaseType&#10;import com.example.boardgametimer.model.TurnPhase&#10;import com.example.boardgametimer.model.DiceResult&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.util.Locale&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;&#10;class GameTimerViewModel : ViewModel() {&#10;&#10;    var gameState by mutableStateOf(GameState())&#10;        private set&#10;&#10;    var gameConfiguration by mutableStateOf(GameConfiguration())&#10;        private set&#10;&#10;    var showOptions by mutableStateOf(false)&#10;        private set&#10;&#10;    var showStats by mutableStateOf(false)&#10;        private set&#10;&#10;    var undoHistory by mutableStateOf&lt;GameState?&gt;(null)&#10;        private set&#10;&#10;    var savedConfigurations by mutableStateOf&lt;List&lt;SavedConfiguration&gt;&gt;(emptyList())&#10;        private set&#10;&#10;    private var timerJob: Job? = null&#10;    private var toneGenerator: ToneGenerator? = null&#10;    private var vibrator: Vibrator? = null&#10;    private var textToSpeech: TextToSpeech? = null&#10;    private var ttsReady = false&#10;    private var sharedPreferences: SharedPreferences? = null&#10;    private val gson = Gson()&#10;&#10;    fun initializeAudio(context: Context) {&#10;        toneGenerator = ToneGenerator(AudioManager.STREAM_NOTIFICATION, 100)&#10;&#10;        // Use modern vibrator API&#10;        vibrator = if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.S) {&#10;            val vibratorManager = context.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            vibratorManager.defaultVibrator&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;&#10;        textToSpeech = TextToSpeech(context) { status -&gt;&#10;            if (status == TextToSpeech.SUCCESS) {&#10;                textToSpeech?.language = Locale.getDefault()&#10;                ttsReady = true&#10;            }&#10;        }&#10;&#10;        // Initialize SharedPreferences for saving configurations&#10;        sharedPreferences = context.getSharedPreferences(&quot;BoardGameTimer&quot;, Context.MODE_PRIVATE)&#10;        loadSavedConfigurations()&#10;    }&#10;&#10;    fun startNewGame() {&#10;        val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;        val firstPhaseDuration = gameConfiguration.getCurrentPhaseDuration(0)&#10;        gameState = GameState(&#10;            currentPlayerIndex = 0,&#10;            currentPhaseIndex = 0, // Start with first phase&#10;            timeRemainingSeconds = firstPhaseDuration,&#10;            timeRemainingMillis = firstPhaseDuration * 1000L,&#10;            isGameRunning = true,&#10;            isPaused = false, // Start ready to play, not paused&#10;            roundCount = 0,&#10;            playerTurnTimes = playerTurnTimes,&#10;            gameStartTime = System.currentTimeMillis(),&#10;            turnStartTime = System.currentTimeMillis()&#10;        )&#10;        startTimer() // Auto-start the timer for the first player&#10;    }&#10;&#10;    fun nextPlayer() {&#10;        if (!gameState.isGameRunning) return&#10;&#10;        // Check if we need to advance to next phase or next player&#10;        val nextPhaseIndex = gameState.currentPhaseIndex + 1&#10;        val totalPhases = gameConfiguration.getTotalPhases()&#10;&#10;        if (nextPhaseIndex &lt; totalPhases) {&#10;            // Move to next phase for same player&#10;            nextPhase()&#10;        } else {&#10;            // Move to next player (reset to first phase)&#10;            moveToNextPlayer()&#10;        }&#10;    }&#10;&#10;    private fun nextPhase() {&#10;        // Play a beep sound when passing to next phase&#10;        playTurnPassBeep()&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        val nextPhaseIndex = gameState.currentPhaseIndex + 1&#10;        val phaseDuration = gameConfiguration.getCurrentPhaseDuration(nextPhaseIndex)&#10;        val nextPhase = gameConfiguration.turnPhases[nextPhaseIndex]&#10;&#10;        gameState = gameState.copy(&#10;            currentPhaseIndex = nextPhaseIndex,&#10;            timeRemainingSeconds = phaseDuration,&#10;            timeRemainingMillis = phaseDuration * 1000L,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = false,&#10;            // Reset dice state for new phase&#10;            dicePhaseState = DicePhaseState.WAITING_TO_THROW,&#10;            diceResult = null,&#10;            isDiceAnimating = false&#10;        )&#10;&#10;        // Auto-start timer for next phase (unless it's a dice phase waiting for throw)&#10;        if (nextPhase.phaseType != PhaseType.DICE_THROW || !shouldWaitForDiceThrow()) {&#10;            startTimer()&#10;        }&#10;    }&#10;&#10;    private fun moveToNextPlayer() {&#10;        // Play a beep sound when passing turn&#10;        playTurnPassBeep()&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        // Record the time taken for current player's turn (only record when completing all phases)&#10;        val timeTaken = gameConfiguration.getCurrentPhaseDuration(gameState.currentPhaseIndex) - gameState.timeRemainingSeconds&#10;        val currentPlayerTimes = gameState.playerTurnTimes[gameState.currentPlayerIndex].toMutableList()&#10;        currentPlayerTimes.add(timeTaken)&#10;&#10;        val updatedPlayerTurnTimes = gameState.playerTurnTimes.toMutableList()&#10;        updatedPlayerTurnTimes[gameState.currentPlayerIndex] = currentPlayerTimes&#10;&#10;        val nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameConfiguration.numberOfPlayers&#10;        val newRoundCount = if (nextPlayerIndex == 0) gameState.roundCount + 1 else gameState.roundCount&#10;        val firstPhaseDuration = gameConfiguration.getCurrentPhaseDuration(0)&#10;        val firstPhase = gameConfiguration.turnPhases[0]&#10;&#10;        gameState = gameState.copy(&#10;            currentPlayerIndex = nextPlayerIndex,&#10;            currentPhaseIndex = 0, // Reset to first phase for new player&#10;            timeRemainingSeconds = firstPhaseDuration,&#10;            timeRemainingMillis = firstPhaseDuration * 1000L,&#10;            playerTurnTimes = updatedPlayerTurnTimes,&#10;            roundCount = newRoundCount,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = false,&#10;            // Reset dice state for new player&#10;            dicePhaseState = DicePhaseState.WAITING_TO_THROW,&#10;            diceResult = null,&#10;            isDiceAnimating = false&#10;        )&#10;&#10;        // Auto-start timer for next player (unless first phase is a dice phase waiting for throw)&#10;        if (firstPhase.phaseType != PhaseType.DICE_THROW || !shouldWaitForDiceThrow()) {&#10;            startTimer()&#10;        }&#10;    }&#10;&#10;    fun undoLastAction() {&#10;        undoHistory?.let { previousState -&gt;&#10;            gameState = previousState&#10;            undoHistory = null&#10;            if (gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun pauseResumeGame() {&#10;        if (gameState.isGameRunning) {&#10;            gameState = gameState.copy(isPaused = !gameState.isPaused)&#10;            if (gameState.isPaused) {&#10;                timerJob?.cancel()&#10;            } else {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun endGame() {&#10;        timerJob?.cancel()&#10;        gameState = gameState.copy(isGameRunning = false, isPaused = false)&#10;        showStats = true&#10;    }&#10;&#10;    private fun startTimer() {&#10;        timerJob?.cancel()&#10;        timerJob = viewModelScope.launch {&#10;            var lastUpdateTime = System.currentTimeMillis()&#10;            var lastSecond = gameState.timeRemainingSeconds&#10;&#10;            while (gameState.timeRemainingMillis &gt; 0 &amp;&amp; gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                delay(16) // Update every 16ms for smooth animation (~60fps)&#10;&#10;                val currentTime = System.currentTimeMillis()&#10;                val deltaTime = currentTime - lastUpdateTime&#10;                lastUpdateTime = currentTime&#10;&#10;                val newTimeMillis = (gameState.timeRemainingMillis - deltaTime).coerceAtLeast(0L)&#10;                val newTimeSeconds = (newTimeMillis / 1000).toInt()&#10;&#10;                gameState = gameState.copy(&#10;                    timeRemainingMillis = newTimeMillis,&#10;                    timeRemainingSeconds = newTimeSeconds&#10;                )&#10;&#10;                // Handle audio alerts (only on second changes)&#10;                if (newTimeSeconds != lastSecond) {&#10;                    lastSecond = newTimeSeconds&#10;                    when (newTimeSeconds) {&#10;                        60 -&gt; if (gameConfiguration.audioAlert60s) playAlert()&#10;                        30 -&gt; if (gameConfiguration.audioAlert30s) playAlert()&#10;                        10, 9, 8, 7, 6, 5, 4, 3, 2, 1 -&gt; {&#10;                            if (gameConfiguration.audioAlert10sCountdown) {&#10;                                speakCountdown(newTimeSeconds)&#10;                            }&#10;                        }&#10;                        0 -&gt; {&#10;                            // Handle timeout with enhanced functionality&#10;                            handlePlayerTimeout()&#10;                            break&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handlePlayerTimeout() {&#10;        // Play timeout alert if enabled&#10;        if (gameConfiguration.audioAlertTimeOut) {&#10;            playAlert()&#10;        }&#10;&#10;        // Announce timeout with text-to-speech if enabled&#10;        if (gameConfiguration.audioAlertTimeOut &amp;&amp; ttsReady) {&#10;            val playerName = gameConfiguration.getPlayerName(gameState.currentPlayerIndex)&#10;            textToSpeech?.speak(&quot;$playerName ran out of time!&quot;, TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;&#10;        // Pause the game and show timeout dialog&#10;        gameState = gameState.copy(&#10;            isPaused = true,&#10;            showTimeExpiredDialog = true&#10;        )&#10;    }&#10;&#10;    fun dismissTimeExpiredDialog() {&#10;        gameState = gameState.copy(showTimeExpiredDialog = false)&#10;    }&#10;&#10;    fun continueAfterTimeout() {&#10;        // Reset timer to full duration and resume game&#10;        gameState = gameState.copy(&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            isPaused = false,&#10;            showTimeExpiredDialog = false&#10;        )&#10;        startTimer()&#10;    }&#10;&#10;    private fun playAlert() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_CDMA_ALERT_CALL_GUARD, 200)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun playTurnPassBeep() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_PROP_BEEP, 150)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun speakCountdown(seconds: Int) {&#10;        if (ttsReady) {&#10;            textToSpeech?.speak(seconds.toString(), TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    fun updateConfiguration(newConfig: GameConfiguration) {&#10;        gameConfiguration = newConfig&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(newConfig.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = newConfig.turnDurationSeconds,&#10;                timeRemainingMillis = newConfig.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun saveConfiguration(name: String) {&#10;        if (name.isBlank()) return&#10;&#10;        val newConfig = SavedConfiguration(name, gameConfiguration)&#10;        val updatedConfigs = savedConfigurations.toMutableList()&#10;&#10;        // Remove existing config with same name&#10;        updatedConfigs.removeAll { it.name == name }&#10;        updatedConfigs.add(newConfig)&#10;&#10;        savedConfigurations = updatedConfigs&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    fun loadConfiguration(savedConfig: SavedConfiguration) {&#10;        gameConfiguration = savedConfig.configuration&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;                timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun deleteConfiguration(configName: String) {&#10;        savedConfigurations = savedConfigurations.filter { it.name != configName }&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    private fun loadSavedConfigurations() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = prefs.getString(&quot;saved_configurations&quot;, &quot;[]&quot;)&#10;            val type = object : TypeToken&lt;List&lt;SavedConfiguration&gt;&gt;() {}.type&#10;            try {&#10;                savedConfigurations = gson.fromJson(json, type) ?: emptyList()&#10;            } catch (e: Exception) {&#10;                savedConfigurations = emptyList()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveToPersistentStorage() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = gson.toJson(savedConfigurations)&#10;            prefs.edit().putString(&quot;saved_configurations&quot;, json).apply()&#10;        }&#10;    }&#10;&#10;    fun showOptions() {&#10;        showOptions = true&#10;    }&#10;&#10;    fun hideOptions() {&#10;        showOptions = false&#10;    }&#10;&#10;    fun hideStats() {&#10;        showStats = false&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        toneGenerator?.release()&#10;        textToSpeech?.shutdown()&#10;    }&#10;&#10;    fun throwDice() {&#10;        val currentPhase = gameConfiguration.turnPhases[gameState.currentPhaseIndex]&#10;        if (currentPhase.phaseType != PhaseType.DICE_THROW) return&#10;&#10;        // Prevent throwing dice if game is not running&#10;        if (!gameState.isGameRunning) return&#10;&#10;        // Prevent throwing dice if already thrown in this phase&#10;        if (gameState.dicePhaseState != DicePhaseState.WAITING_TO_THROW) return&#10;&#10;        // Stop the countdown timer immediately when dice are thrown&#10;        timerJob?.cancel()&#10;&#10;        // Start dice animation and pause the game&#10;        gameState = gameState.copy(&#10;            isDiceAnimating = true,&#10;            dicePhaseState = DicePhaseState.THROWING,&#10;            isPaused = true // Pause the game to stop the countdown&#10;        )&#10;&#10;        // Simulate dice animation with out-of-sync changes for multiple dice&#10;        viewModelScope.launch {&#10;            val animationDuration = 3000L // Fixed at 3 seconds&#10;            val startTime = System.currentTimeMillis()&#10;&#10;            // Initialize with random values immediately to replace &quot;Tap to throw&quot;&#10;            var previousValues = (1..currentPhase.diceCount).map { (1..currentPhase.diceType.sides).random() }&#10;            val lastChangeTime = mutableListOf&lt;Long&gt;()&#10;            repeat(currentPhase.diceCount) { lastChangeTime.add(0L) }&#10;&#10;            // Set initial values immediately&#10;            gameState = gameState.copy(&#10;                diceResult = DiceResult(previousValues, previousValues.sum())&#10;            )&#10;&#10;            while (System.currentTimeMillis() - startTime &lt; animationDuration) {&#10;                val currentTime = System.currentTimeMillis() - startTime&#10;                val progress = currentTime.toFloat() / animationDuration.toFloat()&#10;&#10;                // Create deceleration curve - starts fast, gets slower&#10;                val decelerationFactor = 1.0f - (progress * progress) // Quadratic deceleration&#10;                val adjustedBaseInterval = (120L + (300L * progress)).toLong() // 120ms to 420ms (more controlled)&#10;&#10;                // Check each die individually and update immediately when it's time to change&#10;                for (index in 0 until currentPhase.diceCount) {&#10;                    val dieInterval = (adjustedBaseInterval + (index * 80L * decelerationFactor)).toLong()&#10;&#10;                    // Check if enough time has passed since this die's last change&#10;                    if (currentTime - lastChangeTime[index] &gt;= dieInterval) {&#10;                        // Time to change this die's value - update immediately&#10;                        lastChangeTime[index] = currentTime&#10;                        val newValue = (1..currentPhase.diceType.sides).random()&#10;&#10;                        // Update only this die's value immediately for perfect sync&#10;                        val updatedValues = previousValues.toMutableList()&#10;                        updatedValues[index] = newValue&#10;                        previousValues = updatedValues&#10;&#10;                        // Update state immediately when value changes&#10;                        gameState = gameState.copy(&#10;                            diceResult = DiceResult(previousValues, previousValues.sum())&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Fixed frame rate&#10;                delay(50L)&#10;            }&#10;&#10;            // Generate final result&#10;            val finalValues = (1..currentPhase.diceCount).map {&#10;                (1..currentPhase.diceType.sides).random()&#10;            }&#10;            gameState = gameState.copy(&#10;                isDiceAnimating = false,&#10;                diceResult = DiceResult(finalValues, finalValues.sum()),&#10;                dicePhaseState = DicePhaseState.SHOWING_RESULT&#10;            )&#10;&#10;            // Play dice sound effect&#10;            playDiceSound()&#10;&#10;            // Handle timer based on phase configuration&#10;            if (currentPhase.waitForPress) {&#10;                // If wait for press is enabled, just pause and wait for manual progression&#10;                gameState = gameState.copy(isPaused = true)&#10;            } else if (currentPhase.durationSeconds &gt; 0) {&#10;                // Start the timer with the configured duration&#10;                gameState = gameState.copy(&#10;                    timeRemainingSeconds = currentPhase.durationSeconds,&#10;                    timeRemainingMillis = currentPhase.durationSeconds * 1000L,&#10;                    isPaused = false&#10;                )&#10;                startTimer()&#10;            } else {&#10;                // Duration is 0, automatically proceed to next phase/player&#10;                delay(1000) // Show result for 1 second&#10;                nextPlayer()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun playDiceSound() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_PROP_BEEP, 200)&#10;    }&#10;&#10;    fun getCurrentPhase(): TurnPhase {&#10;        return gameConfiguration.turnPhases[gameState.currentPhaseIndex]&#10;    }&#10;&#10;    fun isDicePhase(): Boolean {&#10;        return getCurrentPhase().phaseType == PhaseType.DICE_THROW&#10;    }&#10;&#10;    fun shouldWaitForDiceThrow(): Boolean {&#10;        val currentPhase = getCurrentPhase()&#10;        return currentPhase.phaseType == PhaseType.DICE_THROW &amp;&amp;&#10;               gameState.dicePhaseState == DicePhaseState.WAITING_TO_THROW&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.boardgametimer.viewmodel&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.media.AudioManager&#10;import android.media.ToneGenerator&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.speech.tts.TextToSpeech&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.GameState&#10;import com.example.boardgametimer.model.SavedConfiguration&#10;import com.example.boardgametimer.model.DicePhaseState&#10;import com.example.boardgametimer.model.PhaseType&#10;import com.example.boardgametimer.model.TurnPhase&#10;import com.example.boardgametimer.model.DiceResult&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.util.Locale&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;&#10;class GameTimerViewModel : ViewModel() {&#10;&#10;    var gameState by mutableStateOf(GameState())&#10;        private set&#10;&#10;    var gameConfiguration by mutableStateOf(GameConfiguration())&#10;        private set&#10;&#10;    var showOptions by mutableStateOf(false)&#10;        private set&#10;&#10;    var showStats by mutableStateOf(false)&#10;        private set&#10;&#10;    var undoHistory by mutableStateOf&lt;GameState?&gt;(null)&#10;        private set&#10;&#10;    var savedConfigurations by mutableStateOf&lt;List&lt;SavedConfiguration&gt;&gt;(emptyList())&#10;        private set&#10;&#10;    private var timerJob: Job? = null&#10;    private var toneGenerator: ToneGenerator? = null&#10;    private var vibrator: Vibrator? = null&#10;    private var textToSpeech: TextToSpeech? = null&#10;    private var ttsReady = false&#10;    private var sharedPreferences: SharedPreferences? = null&#10;    private val gson = Gson()&#10;&#10;    fun initializeAudio(context: Context) {&#10;        toneGenerator = ToneGenerator(AudioManager.STREAM_NOTIFICATION, 100)&#10;&#10;        // Use modern vibrator API&#10;        vibrator = if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.S) {&#10;            val vibratorManager = context.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            vibratorManager.defaultVibrator&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;&#10;        textToSpeech = TextToSpeech(context) { status -&gt;&#10;            if (status == TextToSpeech.SUCCESS) {&#10;                textToSpeech?.language = Locale.getDefault()&#10;                ttsReady = true&#10;            }&#10;        }&#10;&#10;        // Initialize SharedPreferences for saving configurations&#10;        sharedPreferences = context.getSharedPreferences(&quot;BoardGameTimer&quot;, Context.MODE_PRIVATE)&#10;        loadSavedConfigurations()&#10;        loadLastUsedConfiguration()&#10;    }&#10;&#10;    private fun loadLastUsedConfiguration() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = prefs.getString(&quot;last_used_configuration&quot;, null)&#10;            if (json != null) {&#10;                try {&#10;                    val lastConfig = gson.fromJson(json, GameConfiguration::class.java)&#10;                    gameConfiguration = lastConfig&#10;                    // Update game state with the loaded configuration&#10;                    if (!gameState.isGameRunning) {&#10;                        val playerTurnTimes = List(lastConfig.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;                        gameState = GameState(&#10;                            timeRemainingSeconds = lastConfig.turnDurationSeconds,&#10;                            timeRemainingMillis = lastConfig.turnDurationSeconds * 1000L,&#10;                            playerTurnTimes = playerTurnTimes,&#10;                            isPaused = false,&#10;                            isGameRunning = false&#10;                        )&#10;                    }&#10;                } catch (e: Exception) {&#10;                    // If loading fails, keep the default configuration&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveCurrentConfigurationAsDefault() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = gson.toJson(gameConfiguration)&#10;            prefs.edit().putString(&quot;last_used_configuration&quot;, json).apply()&#10;        }&#10;    }&#10;&#10;    fun startNewGame() {&#10;        val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;        val firstPhaseDuration = gameConfiguration.getCurrentPhaseDuration(0)&#10;        gameState = GameState(&#10;            currentPlayerIndex = 0,&#10;            currentPhaseIndex = 0, // Start with first phase&#10;            timeRemainingSeconds = firstPhaseDuration,&#10;            timeRemainingMillis = firstPhaseDuration * 1000L,&#10;            isGameRunning = true,&#10;            isPaused = false, // Start ready to play, not paused&#10;            roundCount = 0,&#10;            playerTurnTimes = playerTurnTimes,&#10;            gameStartTime = System.currentTimeMillis(),&#10;            turnStartTime = System.currentTimeMillis()&#10;        )&#10;        startTimer() // Auto-start the timer for the first player&#10;    }&#10;&#10;    fun nextPlayer() {&#10;        if (!gameState.isGameRunning) return&#10;&#10;        // Check if we need to advance to next phase or next player&#10;        val nextPhaseIndex = gameState.currentPhaseIndex + 1&#10;        val totalPhases = gameConfiguration.getTotalPhases()&#10;&#10;        if (nextPhaseIndex &lt; totalPhases) {&#10;            // Move to next phase for same player&#10;            nextPhase()&#10;        } else {&#10;            // Move to next player (reset to first phase)&#10;            moveToNextPlayer()&#10;        }&#10;    }&#10;&#10;    private fun nextPhase() {&#10;        // Play a beep sound when passing to next phase&#10;        playTurnPassBeep()&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        val nextPhaseIndex = gameState.currentPhaseIndex + 1&#10;        val phaseDuration = gameConfiguration.getCurrentPhaseDuration(nextPhaseIndex)&#10;        val nextPhase = gameConfiguration.turnPhases[nextPhaseIndex]&#10;&#10;        gameState = gameState.copy(&#10;            currentPhaseIndex = nextPhaseIndex,&#10;            timeRemainingSeconds = phaseDuration,&#10;            timeRemainingMillis = phaseDuration * 1000L,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = false,&#10;            // Reset dice state for new phase&#10;            dicePhaseState = DicePhaseState.WAITING_TO_THROW,&#10;            diceResult = null,&#10;            isDiceAnimating = false&#10;        )&#10;&#10;        // Auto-start timer for next phase (unless it's a dice phase waiting for throw)&#10;        if (nextPhase.phaseType != PhaseType.DICE_THROW || !shouldWaitForDiceThrow()) {&#10;            startTimer()&#10;        }&#10;    }&#10;&#10;    private fun moveToNextPlayer() {&#10;        // Play a beep sound when passing turn&#10;        playTurnPassBeep()&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        // Record the time taken for current player's turn (only record when completing all phases)&#10;        val timeTaken = gameConfiguration.getCurrentPhaseDuration(gameState.currentPhaseIndex) - gameState.timeRemainingSeconds&#10;        val currentPlayerTimes = gameState.playerTurnTimes[gameState.currentPlayerIndex].toMutableList()&#10;        currentPlayerTimes.add(timeTaken)&#10;&#10;        val updatedPlayerTurnTimes = gameState.playerTurnTimes.toMutableList()&#10;        updatedPlayerTurnTimes[gameState.currentPlayerIndex] = currentPlayerTimes&#10;&#10;        val nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameConfiguration.numberOfPlayers&#10;        val newRoundCount = if (nextPlayerIndex == 0) gameState.roundCount + 1 else gameState.roundCount&#10;        val firstPhaseDuration = gameConfiguration.getCurrentPhaseDuration(0)&#10;        val firstPhase = gameConfiguration.turnPhases[0]&#10;&#10;        gameState = gameState.copy(&#10;            currentPlayerIndex = nextPlayerIndex,&#10;            currentPhaseIndex = 0, // Reset to first phase for new player&#10;            timeRemainingSeconds = firstPhaseDuration,&#10;            timeRemainingMillis = firstPhaseDuration * 1000L,&#10;            playerTurnTimes = updatedPlayerTurnTimes,&#10;            roundCount = newRoundCount,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = false,&#10;            // Reset dice state for new player&#10;            dicePhaseState = DicePhaseState.WAITING_TO_THROW,&#10;            diceResult = null,&#10;            isDiceAnimating = false&#10;        )&#10;&#10;        // Auto-start timer for next player (unless first phase is a dice phase waiting for throw)&#10;        if (firstPhase.phaseType != PhaseType.DICE_THROW || !shouldWaitForDiceThrow()) {&#10;            startTimer()&#10;        }&#10;    }&#10;&#10;    fun undoLastAction() {&#10;        undoHistory?.let { previousState -&gt;&#10;            gameState = previousState&#10;            undoHistory = null&#10;            if (gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun pauseResumeGame() {&#10;        if (gameState.isGameRunning) {&#10;            gameState = gameState.copy(isPaused = !gameState.isPaused)&#10;            if (gameState.isPaused) {&#10;                timerJob?.cancel()&#10;            } else {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun endGame() {&#10;        timerJob?.cancel()&#10;        gameState = gameState.copy(isGameRunning = false, isPaused = false)&#10;        showStats = true&#10;    }&#10;&#10;    private fun startTimer() {&#10;        timerJob?.cancel()&#10;        timerJob = viewModelScope.launch {&#10;            var lastUpdateTime = System.currentTimeMillis()&#10;            var lastSecond = gameState.timeRemainingSeconds&#10;&#10;            while (gameState.timeRemainingMillis &gt; 0 &amp;&amp; gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                delay(16) // Update every 16ms for smooth animation (~60fps)&#10;&#10;                val currentTime = System.currentTimeMillis()&#10;                val deltaTime = currentTime - lastUpdateTime&#10;                lastUpdateTime = currentTime&#10;&#10;                val newTimeMillis = (gameState.timeRemainingMillis - deltaTime).coerceAtLeast(0L)&#10;                val newTimeSeconds = (newTimeMillis / 1000).toInt()&#10;&#10;                gameState = gameState.copy(&#10;                    timeRemainingMillis = newTimeMillis,&#10;                    timeRemainingSeconds = newTimeSeconds&#10;                )&#10;&#10;                // Handle audio alerts (only on second changes)&#10;                if (newTimeSeconds != lastSecond) {&#10;                    lastSecond = newTimeSeconds&#10;                    when (newTimeSeconds) {&#10;                        60 -&gt; if (gameConfiguration.audioAlert60s) playAlert()&#10;                        30 -&gt; if (gameConfiguration.audioAlert30s) playAlert()&#10;                        10, 9, 8, 7, 6, 5, 4, 3, 2, 1 -&gt; {&#10;                            if (gameConfiguration.audioAlert10sCountdown) {&#10;                                speakCountdown(newTimeSeconds)&#10;                            }&#10;                        }&#10;                        0 -&gt; {&#10;                            // Handle timeout with enhanced functionality&#10;                            handlePlayerTimeout()&#10;                            break&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handlePlayerTimeout() {&#10;        // Play timeout alert if enabled&#10;        if (gameConfiguration.audioAlertTimeOut) {&#10;            playAlert()&#10;        }&#10;&#10;        // Announce timeout with text-to-speech if enabled&#10;        if (gameConfiguration.audioAlertTimeOut &amp;&amp; ttsReady) {&#10;            val playerName = gameConfiguration.getPlayerName(gameState.currentPlayerIndex)&#10;            textToSpeech?.speak(&quot;$playerName ran out of time!&quot;, TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;&#10;        // Pause the game and show timeout dialog&#10;        gameState = gameState.copy(&#10;            isPaused = true,&#10;            showTimeExpiredDialog = true&#10;        )&#10;    }&#10;&#10;    fun dismissTimeExpiredDialog() {&#10;        gameState = gameState.copy(showTimeExpiredDialog = false)&#10;    }&#10;&#10;    fun continueAfterTimeout() {&#10;        // Reset timer to full duration and resume game&#10;        gameState = gameState.copy(&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            isPaused = false,&#10;            showTimeExpiredDialog = false&#10;        )&#10;        startTimer()&#10;    }&#10;&#10;    private fun playAlert() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_CDMA_ALERT_CALL_GUARD, 200)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun playTurnPassBeep() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_PROP_BEEP, 150)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun speakCountdown(seconds: Int) {&#10;        if (ttsReady) {&#10;            textToSpeech?.speak(seconds.toString(), TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    fun updateConfiguration(newConfig: GameConfiguration) {&#10;        gameConfiguration = newConfig&#10;        // Automatically save this configuration as the default for future app startups&#10;        saveCurrentConfigurationAsDefault()&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(newConfig.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = newConfig.turnDurationSeconds,&#10;                timeRemainingMillis = newConfig.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun saveConfiguration(name: String) {&#10;        if (name.isBlank()) return&#10;&#10;        val newConfig = SavedConfiguration(name, gameConfiguration)&#10;        val updatedConfigs = savedConfigurations.toMutableList()&#10;&#10;        // Remove existing config with same name&#10;        updatedConfigs.removeAll { it.name == name }&#10;        updatedConfigs.add(newConfig)&#10;&#10;        savedConfigurations = updatedConfigs&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    fun loadConfiguration(savedConfig: SavedConfiguration) {&#10;        gameConfiguration = savedConfig.configuration&#10;        // Automatically save this loaded configuration as the default for future app startups&#10;        saveCurrentConfigurationAsDefault()&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;                timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun deleteConfiguration(configName: String) {&#10;        savedConfigurations = savedConfigurations.filter { it.name != configName }&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    private fun loadSavedConfigurations() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = prefs.getString(&quot;saved_configurations&quot;, &quot;[]&quot;)&#10;            val type = object : TypeToken&lt;List&lt;SavedConfiguration&gt;&gt;() {}.type&#10;            try {&#10;                savedConfigurations = gson.fromJson(json, type) ?: emptyList()&#10;            } catch (e: Exception) {&#10;                savedConfigurations = emptyList()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveToPersistentStorage() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = gson.toJson(savedConfigurations)&#10;            prefs.edit().putString(&quot;saved_configurations&quot;, json).apply()&#10;        }&#10;    }&#10;&#10;    fun showOptions() {&#10;        showOptions = true&#10;    }&#10;&#10;    fun hideOptions() {&#10;        showOptions = false&#10;    }&#10;&#10;    fun hideStats() {&#10;        showStats = false&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        toneGenerator?.release()&#10;        textToSpeech?.shutdown()&#10;    }&#10;&#10;    fun throwDice() {&#10;        val currentPhase = gameConfiguration.turnPhases[gameState.currentPhaseIndex]&#10;        if (currentPhase.phaseType != PhaseType.DICE_THROW) return&#10;&#10;        // Prevent throwing dice if game is not running&#10;        if (!gameState.isGameRunning) return&#10;&#10;        // Prevent throwing dice if already thrown in this phase&#10;        if (gameState.dicePhaseState != DicePhaseState.WAITING_TO_THROW) return&#10;&#10;        // Stop the countdown timer immediately when dice are thrown&#10;        timerJob?.cancel()&#10;&#10;        // Start dice animation and pause the game&#10;        gameState = gameState.copy(&#10;            isDiceAnimating = true,&#10;            dicePhaseState = DicePhaseState.THROWING,&#10;            isPaused = true // Pause the game to stop the countdown&#10;        )&#10;&#10;        // Simulate dice animation with out-of-sync changes for multiple dice&#10;        viewModelScope.launch {&#10;            val animationDuration = 3000L // Fixed at 3 seconds&#10;            val startTime = System.currentTimeMillis()&#10;&#10;            // Initialize with random values immediately to replace &quot;Tap to throw&quot;&#10;            var previousValues = (1..currentPhase.diceCount).map { (1..currentPhase.diceType.sides).random() }&#10;            val lastChangeTime = mutableListOf&lt;Long&gt;()&#10;            repeat(currentPhase.diceCount) { lastChangeTime.add(0L) }&#10;&#10;            // Set initial values immediately&#10;            gameState = gameState.copy(&#10;                diceResult = DiceResult(previousValues, previousValues.sum())&#10;            )&#10;&#10;            while (System.currentTimeMillis() - startTime &lt; animationDuration) {&#10;                val currentTime = System.currentTimeMillis() - startTime&#10;                val progress = currentTime.toFloat() / animationDuration.toFloat()&#10;&#10;                // Create deceleration curve - starts fast, gets slower&#10;                val decelerationFactor = 1.0f - (progress * progress) // Quadratic deceleration&#10;                val adjustedBaseInterval = (120L + (300L * progress)).toLong() // 120ms to 420ms (more controlled)&#10;&#10;                // Check each die individually and update immediately when it's time to change&#10;                for (index in 0 until currentPhase.diceCount) {&#10;                    val dieInterval = (adjustedBaseInterval + (index * 80L * decelerationFactor)).toLong()&#10;&#10;                    // Check if enough time has passed since this die's last change&#10;                    if (currentTime - lastChangeTime[index] &gt;= dieInterval) {&#10;                        // Time to change this die's value - update immediately&#10;                        lastChangeTime[index] = currentTime&#10;                        val newValue = (1..currentPhase.diceType.sides).random()&#10;&#10;                        // Update only this die's value immediately for perfect sync&#10;                        val updatedValues = previousValues.toMutableList()&#10;                        updatedValues[index] = newValue&#10;                        previousValues = updatedValues&#10;&#10;                        // Update state immediately when value changes&#10;                        gameState = gameState.copy(&#10;                            diceResult = DiceResult(previousValues, previousValues.sum())&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Fixed frame rate&#10;                delay(50L)&#10;            }&#10;&#10;            // Generate final result&#10;            val finalValues = (1..currentPhase.diceCount).map {&#10;                (1..currentPhase.diceType.sides).random()&#10;            }&#10;            gameState = gameState.copy(&#10;                isDiceAnimating = false,&#10;                diceResult = DiceResult(finalValues, finalValues.sum()),&#10;                dicePhaseState = DicePhaseState.SHOWING_RESULT&#10;            )&#10;&#10;            // Play dice sound effect&#10;            playDiceSound()&#10;&#10;            // Handle timer based on phase configuration&#10;            if (currentPhase.waitForPress) {&#10;                // If wait for press is enabled, just pause and wait for manual progression&#10;                gameState = gameState.copy(isPaused = true)&#10;            } else if (currentPhase.durationSeconds &gt; 0) {&#10;                // Start the timer with the configured duration&#10;                gameState = gameState.copy(&#10;                    timeRemainingSeconds = currentPhase.durationSeconds,&#10;                    timeRemainingMillis = currentPhase.durationSeconds * 1000L,&#10;                    isPaused = false&#10;                )&#10;                startTimer()&#10;            } else {&#10;                // Duration is 0, automatically proceed to next phase/player&#10;                delay(1000) // Show result for 1 second&#10;                nextPlayer()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun playDiceSound() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_PROP_BEEP, 200)&#10;    }&#10;&#10;    fun getCurrentPhase(): TurnPhase {&#10;        return gameConfiguration.turnPhases[gameState.currentPhaseIndex]&#10;    }&#10;&#10;    fun isDicePhase(): Boolean {&#10;        return getCurrentPhase().phaseType == PhaseType.DICE_THROW&#10;    }&#10;&#10;    fun shouldWaitForDiceThrow(): Boolean {&#10;        val currentPhase = getCurrentPhase()&#10;        return currentPhase.phaseType == PhaseType.DICE_THROW &amp;&amp;&#10;               gameState.dicePhaseState == DicePhaseState.WAITING_TO_THROW&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModelNew.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModelNew.kt" />
              <option name="updatedContent" value="package com.example.boardgametimer.viewmodel&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.media.AudioManager&#10;import android.media.ToneGenerator&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.speech.tts.TextToSpeech&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.GameState&#10;import com.example.boardgametimer.model.SavedConfiguration&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.util.Locale&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;&#10;class GameTimerViewModel : ViewModel() {&#10;&#10;    var gameState by mutableStateOf(GameState())&#10;        private set&#10;&#10;    var gameConfiguration by mutableStateOf(GameConfiguration())&#10;        private set&#10;&#10;    var showOptions by mutableStateOf(false)&#10;        private set&#10;&#10;    var showStats by mutableStateOf(false)&#10;        private set&#10;&#10;    var undoHistory by mutableStateOf&lt;GameState?&gt;(null)&#10;        private set&#10;&#10;    var savedConfigurations by mutableStateOf&lt;List&lt;SavedConfiguration&gt;&gt;(emptyList())&#10;        private set&#10;&#10;    private var timerJob: Job? = null&#10;    private var toneGenerator: ToneGenerator? = null&#10;    private var vibrator: Vibrator? = null&#10;    private var textToSpeech: TextToSpeech? = null&#10;    private var ttsReady = false&#10;    private var sharedPreferences: SharedPreferences? = null&#10;    private val gson = Gson()&#10;&#10;    fun initializeAudio(context: Context) {&#10;        toneGenerator = ToneGenerator(AudioManager.STREAM_NOTIFICATION, 100)&#10;&#10;        // Use modern vibrator API&#10;        vibrator = if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.S) {&#10;            val vibratorManager = context.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            vibratorManager.defaultVibrator&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;&#10;        textToSpeech = TextToSpeech(context) { status -&gt;&#10;            if (status == TextToSpeech.SUCCESS) {&#10;                textToSpeech?.language = Locale.getDefault()&#10;                ttsReady = true&#10;            }&#10;        }&#10;&#10;        // Initialize SharedPreferences for saving configurations&#10;        sharedPreferences = context.getSharedPreferences(&quot;BoardGameTimer&quot;, Context.MODE_PRIVATE)&#10;        loadSavedConfigurations()&#10;    }&#10;&#10;    fun startNewGame() {&#10;        val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;        gameState = GameState(&#10;            currentPlayerIndex = 0,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            isGameRunning = true,&#10;            isPaused = true, // Start paused&#10;            roundCount = 0,&#10;            playerTurnTimes = playerTurnTimes,&#10;            gameStartTime = System.currentTimeMillis(),&#10;            turnStartTime = System.currentTimeMillis()&#10;        )&#10;        // Don't start timer automatically - wait for user to resume&#10;    }&#10;&#10;    fun nextPlayer() {&#10;        if (!gameState.isGameRunning) return&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        // Record the time taken for current player's turn&#10;        val timeTaken = gameConfiguration.turnDurationSeconds - gameState.timeRemainingSeconds&#10;        val currentPlayerTimes = gameState.playerTurnTimes[gameState.currentPlayerIndex].toMutableList()&#10;        currentPlayerTimes.add(timeTaken)&#10;&#10;        val updatedPlayerTurnTimes = gameState.playerTurnTimes.toMutableList()&#10;        updatedPlayerTurnTimes[gameState.currentPlayerIndex] = currentPlayerTimes&#10;&#10;        val nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameConfiguration.numberOfPlayers&#10;        val newRoundCount = if (nextPlayerIndex == 0) gameState.roundCount + 1 else gameState.roundCount&#10;&#10;        gameState = gameState.copy(&#10;            currentPlayerIndex = nextPlayerIndex,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            playerTurnTimes = updatedPlayerTurnTimes,&#10;            roundCount = newRoundCount,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = true // Pause after each player switch&#10;        )&#10;&#10;        // Don't auto-start timer - let user resume manually&#10;    }&#10;&#10;    fun undoLastAction() {&#10;        undoHistory?.let { previousState -&gt;&#10;            gameState = previousState&#10;            undoHistory = null&#10;            if (gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun pauseResumeGame() {&#10;        if (gameState.isGameRunning) {&#10;            gameState = gameState.copy(isPaused = !gameState.isPaused)&#10;            if (gameState.isPaused) {&#10;                timerJob?.cancel()&#10;            } else {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun endGame() {&#10;        timerJob?.cancel()&#10;        gameState = gameState.copy(isGameRunning = false, isPaused = false)&#10;        showStats = true&#10;    }&#10;&#10;    private fun startTimer() {&#10;        timerJob?.cancel()&#10;        timerJob = viewModelScope.launch {&#10;            var lastUpdateTime = System.currentTimeMillis()&#10;            var lastSecond = gameState.timeRemainingSeconds&#10;            &#10;            while (gameState.timeRemainingMillis &gt; 0 &amp;&amp; gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                delay(16) // Update every 16ms for smooth animation (~60fps)&#10;                &#10;                val currentTime = System.currentTimeMillis()&#10;                val deltaTime = currentTime - lastUpdateTime&#10;                lastUpdateTime = currentTime&#10;                &#10;                val newTimeMillis = (gameState.timeRemainingMillis - deltaTime).coerceAtLeast(0L)&#10;                val newTimeSeconds = (newTimeMillis / 1000).toInt()&#10;                &#10;                gameState = gameState.copy(&#10;                    timeRemainingMillis = newTimeMillis,&#10;                    timeRemainingSeconds = newTimeSeconds&#10;                )&#10;&#10;                // Handle audio alerts (only on second changes)&#10;                if (newTimeSeconds != lastSecond) {&#10;                    lastSecond = newTimeSeconds&#10;                    when (newTimeSeconds) {&#10;                        60 -&gt; if (gameConfiguration.audioAlert60s) playAlert()&#10;                        30 -&gt; if (gameConfiguration.audioAlert30s) playAlert()&#10;                        10, 9, 8, 7, 6, 5, 4, 3, 2, 1 -&gt; {&#10;                            if (gameConfiguration.audioAlert10sCountdown) {&#10;                                speakCountdown(newTimeSeconds)&#10;                            }&#10;                        }&#10;                        0 -&gt; {&#10;                            if (gameConfiguration.audioAlertTimeOut) playAlert()&#10;                            break&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun playAlert() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_CDMA_ALERT_CALL_GUARD, 200)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun speakCountdown(seconds: Int) {&#10;        if (ttsReady) {&#10;            textToSpeech?.speak(seconds.toString(), TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    fun updateConfiguration(newConfig: GameConfiguration) {&#10;        gameConfiguration = newConfig&#10;        // Reset game state with new configuration&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(newConfig.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = newConfig.turnDurationSeconds,&#10;                timeRemainingMillis = newConfig.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = true&#10;            )&#10;        }&#10;    }&#10;&#10;    fun saveConfiguration(name: String) {&#10;        if (name.isBlank()) return&#10;        &#10;        val newConfig = SavedConfiguration(name, gameConfiguration)&#10;        val updatedConfigs = savedConfigurations.toMutableList()&#10;        &#10;        // Remove existing config with same name&#10;        updatedConfigs.removeAll { it.name == name }&#10;        updatedConfigs.add(newConfig)&#10;        &#10;        savedConfigurations = updatedConfigs&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    fun loadConfiguration(savedConfig: SavedConfiguration) {&#10;        gameConfiguration = savedConfig.configuration&#10;        // Reset game state with new configuration&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;                timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = true&#10;            )&#10;        }&#10;    }&#10;&#10;    fun deleteConfiguration(configName: String) {&#10;        savedConfigurations = savedConfigurations.filter { it.name != configName }&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    private fun loadSavedConfigurations() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = prefs.getString(&quot;saved_configurations&quot;, &quot;[]&quot;)&#10;            val type = object : TypeToken&lt;List&lt;SavedConfiguration&gt;&gt;() {}.type&#10;            try {&#10;                savedConfigurations = gson.fromJson(json, type) ?: emptyList()&#10;            } catch (e: Exception) {&#10;                savedConfigurations = emptyList()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveToPersistentStorage() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = gson.toJson(savedConfigurations)&#10;            prefs.edit().putString(&quot;saved_configurations&quot;, json).apply()&#10;        }&#10;    }&#10;&#10;    fun showOptions() {&#10;        showOptions = true&#10;    }&#10;&#10;    fun hideOptions() {&#10;        showOptions = false&#10;    }&#10;&#10;    fun hideStats() {&#10;        showStats = false&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        toneGenerator?.release()&#10;        textToSpeech?.shutdown()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModel_Fixed.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModel_Fixed.kt" />
              <option name="updatedContent" value="package com.example.boardgametimer.viewmodel&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.media.AudioManager&#10;import android.media.ToneGenerator&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.speech.tts.TextToSpeech&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.GameState&#10;import com.example.boardgametimer.model.SavedConfiguration&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.util.Locale&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;&#10;class GameTimerViewModel : ViewModel() {&#10;&#10;    var gameState by mutableStateOf(GameState())&#10;        private set&#10;&#10;    var gameConfiguration by mutableStateOf(GameConfiguration())&#10;        private set&#10;&#10;    var showOptions by mutableStateOf(false)&#10;        private set&#10;&#10;    var showStats by mutableStateOf(false)&#10;        private set&#10;&#10;    var undoHistory by mutableStateOf&lt;GameState?&gt;(null)&#10;        private set&#10;&#10;    var savedConfigurations by mutableStateOf&lt;List&lt;SavedConfiguration&gt;&gt;(emptyList())&#10;        private set&#10;&#10;    private var timerJob: Job? = null&#10;    private var toneGenerator: ToneGenerator? = null&#10;    private var vibrator: Vibrator? = null&#10;    private var textToSpeech: TextToSpeech? = null&#10;    private var ttsReady = false&#10;    private var sharedPreferences: SharedPreferences? = null&#10;    private val gson = Gson()&#10;&#10;    fun initializeAudio(context: Context) {&#10;        toneGenerator = ToneGenerator(AudioManager.STREAM_NOTIFICATION, 100)&#10;&#10;        // Use modern vibrator API&#10;        vibrator = if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.S) {&#10;            val vibratorManager = context.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            vibratorManager.defaultVibrator&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;&#10;        textToSpeech = TextToSpeech(context) { status -&gt;&#10;            if (status == TextToSpeech.SUCCESS) {&#10;                textToSpeech?.language = Locale.getDefault()&#10;                ttsReady = true&#10;            }&#10;        }&#10;&#10;        // Initialize SharedPreferences for saving configurations&#10;        sharedPreferences = context.getSharedPreferences(&quot;BoardGameTimer&quot;, Context.MODE_PRIVATE)&#10;        loadSavedConfigurations()&#10;    }&#10;&#10;    fun startNewGame() {&#10;        val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;        gameState = GameState(&#10;            currentPlayerIndex = 0,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            isGameRunning = true,&#10;            isPaused = false, // Start ready to play, not paused&#10;            roundCount = 0,&#10;            playerTurnTimes = playerTurnTimes,&#10;            gameStartTime = System.currentTimeMillis(),&#10;            turnStartTime = System.currentTimeMillis()&#10;        )&#10;        startTimer() // Auto-start the timer for the first player&#10;    }&#10;&#10;    fun nextPlayer() {&#10;        if (!gameState.isGameRunning) return&#10;&#10;        // Play a beep sound when passing turn&#10;        playTurnPassBeep()&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        // Record the time taken for current player's turn&#10;        val timeTaken = gameConfiguration.turnDurationSeconds - gameState.timeRemainingSeconds&#10;        val currentPlayerTimes = gameState.playerTurnTimes[gameState.currentPlayerIndex].toMutableList()&#10;        currentPlayerTimes.add(timeTaken)&#10;&#10;        val updatedPlayerTurnTimes = gameState.playerTurnTimes.toMutableList()&#10;        updatedPlayerTurnTimes[gameState.currentPlayerIndex] = currentPlayerTimes&#10;&#10;        val nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameConfiguration.numberOfPlayers&#10;        val newRoundCount = if (nextPlayerIndex == 0) gameState.roundCount + 1 else gameState.roundCount&#10;&#10;        gameState = gameState.copy(&#10;            currentPlayerIndex = nextPlayerIndex,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            playerTurnTimes = updatedPlayerTurnTimes,&#10;            roundCount = newRoundCount,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = false // Don't pause after each player switch&#10;        )&#10;&#10;        // Auto-start timer for next player&#10;        startTimer()&#10;    }&#10;&#10;    fun undoLastAction() {&#10;        undoHistory?.let { previousState -&gt;&#10;            gameState = previousState&#10;            undoHistory = null&#10;            if (gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun pauseResumeGame() {&#10;        if (gameState.isGameRunning) {&#10;            gameState = gameState.copy(isPaused = !gameState.isPaused)&#10;            if (gameState.isPaused) {&#10;                timerJob?.cancel()&#10;            } else {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun endGame() {&#10;        timerJob?.cancel()&#10;        gameState = gameState.copy(isGameRunning = false, isPaused = false)&#10;        showStats = true&#10;    }&#10;&#10;    private fun startTimer() {&#10;        timerJob?.cancel()&#10;        timerJob = viewModelScope.launch {&#10;            var lastUpdateTime = System.currentTimeMillis()&#10;            var lastSecond = gameState.timeRemainingSeconds&#10;&#10;            while (gameState.timeRemainingMillis &gt; 0 &amp;&amp; gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                delay(16) // Update every 16ms for smooth animation (~60fps)&#10;&#10;                val currentTime = System.currentTimeMillis()&#10;                val deltaTime = currentTime - lastUpdateTime&#10;                lastUpdateTime = currentTime&#10;&#10;                val newTimeMillis = (gameState.timeRemainingMillis - deltaTime).coerceAtLeast(0L)&#10;                val newTimeSeconds = (newTimeMillis / 1000).toInt()&#10;&#10;                gameState = gameState.copy(&#10;                    timeRemainingMillis = newTimeMillis,&#10;                    timeRemainingSeconds = newTimeSeconds&#10;                )&#10;&#10;                // Handle audio alerts (only on second changes)&#10;                if (newTimeSeconds != lastSecond) {&#10;                    lastSecond = newTimeSeconds&#10;                    when (newTimeSeconds) {&#10;                        60 -&gt; if (gameConfiguration.audioAlert60s) playAlert()&#10;                        30 -&gt; if (gameConfiguration.audioAlert30s) playAlert()&#10;                        10, 9, 8, 7, 6, 5, 4, 3, 2, 1 -&gt; {&#10;                            if (gameConfiguration.audioAlert10sCountdown) {&#10;                                speakCountdown(newTimeSeconds)&#10;                            }&#10;                        }&#10;                        0 -&gt; {&#10;                            if (gameConfiguration.audioAlertTimeOut) playAlert()&#10;                            break&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun playAlert() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_CDMA_ALERT_CALL_GUARD, 200)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun playTurnPassBeep() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_PROP_BEEP, 150)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun speakCountdown(seconds: Int) {&#10;        if (ttsReady) {&#10;            textToSpeech?.speak(seconds.toString(), TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    fun updateConfiguration(newConfig: GameConfiguration) {&#10;        gameConfiguration = newConfig&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(newConfig.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = newConfig.turnDurationSeconds,&#10;                timeRemainingMillis = newConfig.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun saveConfiguration(name: String) {&#10;        if (name.isBlank()) return&#10;&#10;        val newConfig = SavedConfiguration(name, gameConfiguration)&#10;        val updatedConfigs = savedConfigurations.toMutableList()&#10;&#10;        // Remove existing config with same name&#10;        updatedConfigs.removeAll { it.name == name }&#10;        updatedConfigs.add(newConfig)&#10;&#10;        savedConfigurations = updatedConfigs&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    fun loadConfiguration(savedConfig: SavedConfiguration) {&#10;        gameConfiguration = savedConfig.configuration&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;                timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun deleteConfiguration(configName: String) {&#10;        savedConfigurations = savedConfigurations.filter { it.name != configName }&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    private fun loadSavedConfigurations() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = prefs.getString(&quot;saved_configurations&quot;, &quot;[]&quot;)&#10;            val type = object : TypeToken&lt;List&lt;SavedConfiguration&gt;&gt;() {}.type&#10;            try {&#10;                savedConfigurations = gson.fromJson(json, type) ?: emptyList()&#10;            } catch (e: Exception) {&#10;                savedConfigurations = emptyList()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveToPersistentStorage() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = gson.toJson(savedConfigurations)&#10;            prefs.edit().putString(&quot;saved_configurations&quot;, json).apply()&#10;        }&#10;    }&#10;&#10;    fun showOptions() {&#10;        showOptions = true&#10;    }&#10;&#10;    fun hideOptions() {&#10;        showOptions = false&#10;    }&#10;&#10;    fun hideStats() {&#10;        showStats = false&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        toneGenerator?.release()&#10;        textToSpeech?.shutdown()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModel_updated.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModel_updated.kt" />
              <option name="updatedContent" value="package com.example.boardgametimer.viewmodel&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.media.AudioManager&#10;import android.media.ToneGenerator&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.speech.tts.TextToSpeech&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.GameState&#10;import com.example.boardgametimer.model.SavedConfiguration&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.util.Locale&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;&#10;class GameTimerViewModel : ViewModel() {&#10;&#10;    var gameState by mutableStateOf(GameState())&#10;        private set&#10;&#10;    var gameConfiguration by mutableStateOf(GameConfiguration())&#10;        private set&#10;&#10;    var showOptions by mutableStateOf(false)&#10;        private set&#10;&#10;    var showStats by mutableStateOf(false)&#10;        private set&#10;&#10;    var undoHistory by mutableStateOf&lt;GameState?&gt;(null)&#10;        private set&#10;&#10;    var savedConfigurations by mutableStateOf&lt;List&lt;SavedConfiguration&gt;&gt;(emptyList())&#10;        private set&#10;&#10;    private var timerJob: Job? = null&#10;    private var toneGenerator: ToneGenerator? = null&#10;    private var vibrator: Vibrator? = null&#10;    private var textToSpeech: TextToSpeech? = null&#10;    private var ttsReady = false&#10;    private var sharedPreferences: SharedPreferences? = null&#10;    private val gson = Gson()&#10;&#10;    fun initializeAudio(context: Context) {&#10;        toneGenerator = ToneGenerator(AudioManager.STREAM_NOTIFICATION, 100)&#10;&#10;        // Use modern vibrator API&#10;        vibrator = if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.S) {&#10;            val vibratorManager = context.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            vibratorManager.defaultVibrator&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;&#10;        textToSpeech = TextToSpeech(context) { status -&gt;&#10;            if (status == TextToSpeech.SUCCESS) {&#10;                textToSpeech?.language = Locale.getDefault()&#10;                ttsReady = true&#10;            }&#10;        }&#10;&#10;        // Initialize SharedPreferences for saving configurations&#10;        sharedPreferences = context.getSharedPreferences(&quot;BoardGameTimer&quot;, Context.MODE_PRIVATE)&#10;        loadSavedConfigurations()&#10;    }&#10;&#10;    fun startNewGame() {&#10;        val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;        gameState = GameState(&#10;            currentPlayerIndex = 0,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            isGameRunning = true,&#10;            isPaused = false, // Start ready to play, not paused&#10;            roundCount = 0,&#10;            playerTurnTimes = playerTurnTimes,&#10;            gameStartTime = System.currentTimeMillis(),&#10;            turnStartTime = System.currentTimeMillis()&#10;        )&#10;        startTimer() // Auto-start the timer for the first player&#10;    }&#10;&#10;    fun nextPlayer() {&#10;        if (!gameState.isGameRunning) return&#10;&#10;        // Play a beep sound when passing turn&#10;        playTurnPassBeep()&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        // Record the time taken for current player's turn&#10;        val timeTaken = gameConfiguration.turnDurationSeconds - gameState.timeRemainingSeconds&#10;        val currentPlayerTimes = gameState.playerTurnTimes[gameState.currentPlayerIndex].toMutableList()&#10;        currentPlayerTimes.add(timeTaken)&#10;&#10;        val updatedPlayerTurnTimes = gameState.playerTurnTimes.toMutableList()&#10;        updatedPlayerTurnTimes[gameState.currentPlayerIndex] = currentPlayerTimes&#10;&#10;        val nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameConfiguration.numberOfPlayers&#10;        val newRoundCount = if (nextPlayerIndex == 0) gameState.roundCount + 1 else gameState.roundCount&#10;&#10;        gameState = gameState.copy(&#10;            currentPlayerIndex = nextPlayerIndex,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            playerTurnTimes = updatedPlayerTurnTimes,&#10;            roundCount = newRoundCount,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = false // Don't pause after each player switch&#10;        )&#10;&#10;        // Auto-start timer for next player&#10;        startTimer()&#10;    }&#10;&#10;    fun undoLastAction() {&#10;        undoHistory?.let { previousState -&gt;&#10;            gameState = previousState&#10;            undoHistory = null&#10;            if (gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun pauseResumeGame() {&#10;        if (gameState.isGameRunning) {&#10;            gameState = gameState.copy(isPaused = !gameState.isPaused)&#10;            if (gameState.isPaused) {&#10;                timerJob?.cancel()&#10;            } else {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun endGame() {&#10;        timerJob?.cancel()&#10;        gameState = gameState.copy(isGameRunning = false, isPaused = false)&#10;        showStats = true&#10;    }&#10;&#10;    private fun startTimer() {&#10;        timerJob?.cancel()&#10;        timerJob = viewModelScope.launch {&#10;            var lastUpdateTime = System.currentTimeMillis()&#10;            var lastSecond = gameState.timeRemainingSeconds&#10;&#10;            while (gameState.timeRemainingMillis &gt; 0 &amp;&amp; gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                delay(16) // Update every 16ms for smooth animation (~60fps)&#10;&#10;                val currentTime = System.currentTimeMillis()&#10;                val deltaTime = currentTime - lastUpdateTime&#10;                lastUpdateTime = currentTime&#10;&#10;                val newTimeMillis = (gameState.timeRemainingMillis - deltaTime).coerceAtLeast(0L)&#10;                val newTimeSeconds = (newTimeMillis / 1000).toInt()&#10;&#10;                gameState = gameState.copy(&#10;                    timeRemainingMillis = newTimeMillis,&#10;                    timeRemainingSeconds = newTimeSeconds&#10;                )&#10;&#10;                // Handle audio alerts (only on second changes)&#10;                if (newTimeSeconds != lastSecond) {&#10;                    lastSecond = newTimeSeconds&#10;                    when (newTimeSeconds) {&#10;                        60 -&gt; if (gameConfiguration.audioAlert60s) playAlert()&#10;                        30 -&gt; if (gameConfiguration.audioAlert30s) playAlert()&#10;                        10, 9, 8, 7, 6, 5, 4, 3, 2, 1 -&gt; {&#10;                            if (gameConfiguration.audioAlert10sCountdown) {&#10;                                speakCountdown(newTimeSeconds)&#10;                            }&#10;                        }&#10;                        0 -&gt; {&#10;                            // Handle timeout with enhanced functionality&#10;                            handlePlayerTimeout()&#10;                            break&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handlePlayerTimeout() {&#10;        // Play timeout alert if enabled&#10;        if (gameConfiguration.audioAlertTimeOut) {&#10;            playAlert()&#10;        }&#10;        &#10;        // Announce timeout with text-to-speech if enabled&#10;        if (gameConfiguration.audioAlertTimeOut &amp;&amp; ttsReady) {&#10;            val playerName = gameConfiguration.getPlayerName(gameState.currentPlayerIndex)&#10;            textToSpeech?.speak(&quot;$playerName ran out of time!&quot;, TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;        &#10;        // Pause the game and show timeout dialog&#10;        gameState = gameState.copy(&#10;            isPaused = true,&#10;            showTimeExpiredDialog = true&#10;        )&#10;    }&#10;&#10;    fun dismissTimeExpiredDialog() {&#10;        gameState = gameState.copy(showTimeExpiredDialog = false)&#10;    }&#10;&#10;    fun continueAfterTimeout() {&#10;        // Reset timer to full duration and resume game&#10;        gameState = gameState.copy(&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            isPaused = false,&#10;            showTimeExpiredDialog = false&#10;        )&#10;        startTimer()&#10;    }&#10;&#10;    private fun playAlert() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_CDMA_ALERT_CALL_GUARD, 200)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun playTurnPassBeep() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_PROP_BEEP, 150)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun speakCountdown(seconds: Int) {&#10;        if (ttsReady) {&#10;            textToSpeech?.speak(seconds.toString(), TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    fun updateConfiguration(newConfig: GameConfiguration) {&#10;        gameConfiguration = newConfig&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(newConfig.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = newConfig.turnDurationSeconds,&#10;                timeRemainingMillis = newConfig.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun saveConfiguration(name: String) {&#10;        if (name.isBlank()) return&#10;&#10;        val newConfig = SavedConfiguration(name, gameConfiguration)&#10;        val updatedConfigs = savedConfigurations.toMutableList()&#10;&#10;        // Remove existing config with same name&#10;        updatedConfigs.removeAll { it.name == name }&#10;        updatedConfigs.add(newConfig)&#10;&#10;        savedConfigurations = updatedConfigs&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    fun loadConfiguration(savedConfig: SavedConfiguration) {&#10;        gameConfiguration = savedConfig.configuration&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;                timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun deleteConfiguration(configName: String) {&#10;        savedConfigurations = savedConfigurations.filter { it.name != configName }&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    private fun loadSavedConfigurations() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = prefs.getString(&quot;saved_configurations&quot;, &quot;[]&quot;)&#10;            val type = object : TypeToken&lt;List&lt;SavedConfiguration&gt;&gt;() {}.type&#10;            try {&#10;                savedConfigurations = gson.fromJson(json, type) ?: emptyList()&#10;            } catch (e: Exception) {&#10;                savedConfigurations = emptyList()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveToPersistentStorage() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = gson.toJson(savedConfigurations)&#10;            prefs.edit().putString(&quot;saved_configurations&quot;, json).apply()&#10;        }&#10;    }&#10;&#10;    fun showOptions() {&#10;        showOptions = true&#10;    }&#10;&#10;    fun hideOptions() {&#10;        showOptions = false&#10;    }&#10;&#10;    fun hideStats() {&#10;        showStats = false&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        toneGenerator?.release()&#10;        textToSpeech?.shutdown()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>