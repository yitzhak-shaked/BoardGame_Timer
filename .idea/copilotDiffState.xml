<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/OptionsActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/OptionsActivity.kt" />
              <option name="originalContent" value="package com.example.boardgametimer&#10;&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material.icons.filled.KeyboardArrowDown&#10;import androidx.compose.material.icons.filled.KeyboardArrowUp&#10;import androidx.compose.material.icons.filled.Remove&#10;import androidx.compose.material.icons.filled.SwapVert&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.SavedConfiguration&#10;import com.example.boardgametimer.model.TurnPhase&#10;import com.example.boardgametimer.ui.theme.BoardGameTimerTheme&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;import java.util.Locale&#10;&#10;class OptionsActivity : ComponentActivity() {&#10;    private val gson = Gson()&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Get the current configuration from the intent&#10;        val configJson = intent.getStringExtra(&quot;gameConfiguration&quot;)&#10;        val currentConfig = if (configJson != null) {&#10;            gson.fromJson(configJson, GameConfiguration::class.java)&#10;        } else {&#10;            GameConfiguration()&#10;        }&#10;&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            BoardGameTimerTheme {&#10;                Surface(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    color = MaterialTheme.colorScheme.background&#10;                ) {&#10;                    OptionsScreen(&#10;                        initialConfiguration = currentConfig,&#10;                        onSave = { config -&gt;&#10;                            val resultIntent = Intent().apply {&#10;                                putExtra(&quot;gameConfiguration&quot;, gson.toJson(config))&#10;                            }&#10;                            setResult(RESULT_OK, resultIntent)&#10;                            finish()&#10;                        },&#10;                        onCancel = {&#10;                            setResult(RESULT_CANCELED)&#10;                            finish()&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun OptionsScreen(&#10;    initialConfiguration: GameConfiguration,&#10;    onSave: (GameConfiguration) -&gt; Unit,&#10;    onCancel: () -&gt; Unit&#10;) {&#10;    var tempConfig by remember { mutableStateOf(initialConfiguration) }&#10;    var playerNames by remember {&#10;        mutableStateOf(&#10;            List(tempConfig.numberOfPlayers) { index -&gt;&#10;                if (index &lt; tempConfig.playerNames.size) tempConfig.playerNames[index] else &quot;&quot;&#10;            }&#10;        )&#10;    }&#10;    var saveConfigName by remember { mutableStateOf(&quot;&quot;) }&#10;    var showSaveDialog by remember { mutableStateOf(false) }&#10;&#10;    // Load saved configurations (memoized to prevent recreation)&#10;    val context = LocalContext.current&#10;    val gson = remember { Gson() }&#10;    val prefs = remember { context.getSharedPreferences(&quot;BoardGameTimer&quot;, Context.MODE_PRIVATE) }&#10;&#10;    var savedConfigurations by remember {&#10;        mutableStateOf&lt;List&lt;SavedConfiguration&gt;&gt;(&#10;            try {&#10;                val json = prefs.getString(&quot;saved_configurations&quot;, &quot;[]&quot;)&#10;                gson.fromJson&lt;List&lt;SavedConfiguration&gt;&gt;(json, object : TypeToken&lt;List&lt;SavedConfiguration&gt;&gt;() {}.type) ?: emptyList&lt;SavedConfiguration&gt;()&#10;            } catch (e: Exception) {&#10;                emptyList&lt;SavedConfiguration&gt;()&#10;            }&#10;        )&#10;    }&#10;&#10;    fun saveConfigsToPrefs(configs: List&lt;SavedConfiguration&gt;) {&#10;        val json = gson.toJson(configs)&#10;        prefs.edit().putString(&quot;saved_configurations&quot;, json).apply()&#10;        savedConfigurations = configs&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Game Options&quot;) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onCancel) {&#10;                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = &quot;Back&quot;)&#10;                    }&#10;                },&#10;                actions = {&#10;                    // Add Save Config button to the top bar&#10;                    TextButton(onClick = { showSaveDialog = true }) {&#10;                        Text(&quot;SAVE CONFIG&quot;)&#10;                    }&#10;                    TextButton(&#10;                        onClick = {&#10;                            val finalConfig = tempConfig.copy(playerNames = playerNames.filter { it.isNotBlank() })&#10;                            onSave(finalConfig)&#10;                        }&#10;                    ) {&#10;                        Text(&quot;SAVE&quot;, fontWeight = FontWeight.Bold)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .padding(horizontal = 16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(12.dp), // Reduced spacing&#10;            contentPadding = PaddingValues(vertical = 8.dp) // Use contentPadding instead of items&#10;        ) {&#10;            // Saved Configurations - Only show if not empty&#10;            if (savedConfigurations.isNotEmpty()) {&#10;                item(key = &quot;saved_configs&quot;) {&#10;                    SavedConfigurationsCard(&#10;                        savedConfigurations = savedConfigurations,&#10;                        onLoadConfiguration = { savedConfig -&gt;&#10;                            tempConfig = savedConfig.configuration&#10;                            playerNames = List(savedConfig.configuration.numberOfPlayers) { index -&gt;&#10;                                if (index &lt; savedConfig.configuration.playerNames.size) {&#10;                                    savedConfig.configuration.playerNames[index]&#10;                                } else &quot;&quot;&#10;                            }&#10;                        },&#10;                        onDeleteConfiguration = { configName -&gt;&#10;                            val updatedConfigs = savedConfigurations.filter { it.name != configName }&#10;                            saveConfigsToPrefs(updatedConfigs)&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Number of Players&#10;            item(key = &quot;player_count&quot;) {&#10;                PlayerCountCard(&#10;                    numberOfPlayers = tempConfig.numberOfPlayers,&#10;                    onPlayerCountChange = { newCount -&gt;&#10;                        tempConfig = tempConfig.copy(numberOfPlayers = newCount)&#10;                        playerNames = when {&#10;                            newCount &gt; playerNames.size -&gt; playerNames + List(newCount - playerNames.size) { &quot;&quot; }&#10;                            newCount &lt; playerNames.size -&gt; playerNames.take(newCount)&#10;                            else -&gt; playerNames&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;&#10;            // Round Configuration&#10;            item(key = &quot;round_config&quot;) {&#10;                RoundConfigurationCard(&#10;                    turnPhases = tempConfig.turnPhases,&#10;                    onPhasesChange = { newPhases -&gt;&#10;                        tempConfig = tempConfig.copy(turnPhases = newPhases)&#10;                    }&#10;                )&#10;            }&#10;&#10;            // Player Names&#10;            item(key = &quot;player_names&quot;) {&#10;                PlayerNamesCard(&#10;                    numberOfPlayers = tempConfig.numberOfPlayers,&#10;                    playerNames = playerNames,&#10;                    onPlayerNamesChange = { newNames -&gt;&#10;                        playerNames = newNames&#10;                    }&#10;                )&#10;            }&#10;&#10;            // Audio Alerts&#10;            item(key = &quot;audio_alerts&quot;) {&#10;                AudioAlertsCard(&#10;                    config = tempConfig,&#10;                    onConfigChange = { newConfig -&gt;&#10;                        tempConfig = newConfig&#10;                    }&#10;                )&#10;            }&#10;&#10;            // Other Options&#10;            item(key = &quot;other_options&quot;) {&#10;                OtherOptionsCard(&#10;                    config = tempConfig,&#10;                    onConfigChange = { newConfig -&gt;&#10;                        tempConfig = newConfig&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    // Save Configuration Dialog&#10;    if (showSaveDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showSaveDialog = false },&#10;            title = { Text(&quot;Save Configuration&quot;) },&#10;            text = {&#10;                OutlinedTextField(&#10;                    value = saveConfigName,&#10;                    onValueChange = { saveConfigName = it },&#10;                    label = { Text(&quot;Configuration Name&quot;) },&#10;                    singleLine = true&#10;                )&#10;            },&#10;            confirmButton = {&#10;                TextButton(&#10;                    onClick = {&#10;                        if (saveConfigName.isNotBlank()) {&#10;                            val finalConfig = tempConfig.copy(playerNames = playerNames.filter { it.isNotBlank() })&#10;                            val newSavedConfig = SavedConfiguration(saveConfigName, finalConfig)&#10;                            val updatedConfigs = savedConfigurations.toMutableList().apply {&#10;                                removeAll { it.name == saveConfigName }&#10;                                add(newSavedConfig)&#10;                            }&#10;                            saveConfigsToPrefs(updatedConfigs)&#10;                            showSaveDialog = false&#10;                            saveConfigName = &quot;&quot;&#10;                        }&#10;                    }&#10;                ) {&#10;                    Text(&quot;Save&quot;)&#10;                }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { showSaveDialog = false }) {&#10;                    Text(&quot;Cancel&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;// Separate composables for each card to improve performance&#10;@Composable&#10;private fun SavedConfigurationsCard(&#10;    savedConfigurations: List&lt;SavedConfiguration&gt;,&#10;    onLoadConfiguration: (SavedConfiguration) -&gt; Unit,&#10;    onDeleteConfiguration: (String) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Text(&#10;                text = &quot;Saved Configurations&quot;,&#10;                fontWeight = FontWeight.Medium,&#10;                fontSize = 18.sp&#10;            )&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            savedConfigurations.forEach { savedConfig -&gt;&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(vertical = 4.dp),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Column(modifier = Modifier.weight(1f)) {&#10;                        Text(&#10;                            text = savedConfig.name,&#10;                            fontWeight = FontWeight.Medium&#10;                        )&#10;                        Text(&#10;                            text = &quot;${savedConfig.configuration.numberOfPlayers} players, ${savedConfig.configuration.turnPhases.size} phases&quot;,&#10;                            fontSize = 12.sp,&#10;                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)&#10;                        )&#10;                    }&#10;                    Row {&#10;                        TextButton(onClick = { onLoadConfiguration(savedConfig) }) {&#10;                            Text(&quot;Load&quot;)&#10;                        }&#10;                        IconButton(onClick = { onDeleteConfiguration(savedConfig.name) }) {&#10;                            Icon(&#10;                                Icons.Default.Delete,&#10;                                contentDescription = &quot;Delete&quot;,&#10;                                tint = MaterialTheme.colorScheme.error&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                if (savedConfig != savedConfigurations.last()) {&#10;                    HorizontalDivider()&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun PlayerCountCard(&#10;    numberOfPlayers: Int,&#10;    onPlayerCountChange: (Int) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Text(&#10;                text = &quot;Number of Players&quot;,&#10;                fontWeight = FontWeight.Medium,&#10;                fontSize = 18.sp&#10;            )&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                horizontalArrangement = Arrangement.Center&#10;            ) {&#10;                IconButton(&#10;                    onClick = {&#10;                        if (numberOfPlayers &gt; 1) {&#10;                            onPlayerCountChange(numberOfPlayers - 1)&#10;                        }&#10;                    }&#10;                ) {&#10;                    Icon(Icons.Default.Remove, contentDescription = &quot;Decrease players&quot;)&#10;                }&#10;&#10;                Text(&#10;                    text = numberOfPlayers.toString(),&#10;                    fontSize = 24.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    modifier = Modifier.padding(horizontal = 32.dp)&#10;                )&#10;&#10;                IconButton(&#10;                    onClick = {&#10;                        if (numberOfPlayers &lt; 15) {&#10;                            onPlayerCountChange(numberOfPlayers + 1)&#10;                        }&#10;                    }&#10;                ) {&#10;                    Icon(Icons.Default.Add, contentDescription = &quot;Increase players&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun RoundConfigurationCard(&#10;    turnPhases: List&lt;TurnPhase&gt;,&#10;    onPhasesChange: (List&lt;TurnPhase&gt;) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;Round Configuration&quot;,&#10;                    fontWeight = FontWeight.Medium,&#10;                    fontSize = 18.sp&#10;                )&#10;&#10;                IconButton(&#10;                    onClick = {&#10;                        val newPhases = turnPhases + TurnPhase(&quot;Phase ${turnPhases.size + 1}&quot;, 60)&#10;                        onPhasesChange(newPhases)&#10;                    }&#10;                ) {&#10;                    Icon(Icons.Default.Add, contentDescription = &quot;Add Phase&quot;)&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // Use key for each phase to improve performance&#10;            turnPhases.forEachIndexed { index, phase -&gt;&#10;                key(index) {&#10;                    PhaseConfigCard(&#10;                        phase = phase,&#10;                        phaseIndex = index,&#10;                        canDelete = turnPhases.size &gt; 1,&#10;                        onPhaseChange = { newPhase -&gt;&#10;                            val newPhases = turnPhases.toMutableList()&#10;                            newPhases[index] = newPhase&#10;                            onPhasesChange(newPhases)&#10;                        },&#10;                        onDeletePhase = {&#10;                            val newPhases = turnPhases.toMutableList()&#10;                            newPhases.removeAt(index)&#10;                            onPhasesChange(newPhases)&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun PhaseConfigCard(&#10;    phase: TurnPhase,&#10;    phaseIndex: Int,&#10;    canDelete: Boolean,&#10;    onPhaseChange: (TurnPhase) -&gt; Unit,&#10;    onDeletePhase: () -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;        )&#10;    ) {&#10;        Column(modifier = Modifier.padding(12.dp)) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;Phase ${phaseIndex + 1}&quot;,&#10;                    fontWeight = FontWeight.Medium,&#10;                    fontSize = 16.sp&#10;                )&#10;&#10;                if (canDelete) {&#10;                    IconButton(onClick = onDeletePhase) {&#10;                        Icon(Icons.Default.Delete, contentDescription = &quot;Delete Phase&quot;)&#10;                    }&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Phase name input&#10;            OutlinedTextField(&#10;                value = phase.name,&#10;                onValueChange = { newName -&gt;&#10;                    onPhaseChange(phase.copy(name = newName))&#10;                },&#10;                label = { Text(&quot;Phase Name&quot;) },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                singleLine = true&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // Quick select chips - memoized&#10;            val timeOptions = remember { listOf(30, 60, 90, 120, 180, 300, 600) }&#10;            val timeLabels = remember { listOf(&quot;30s&quot;, &quot;1m&quot;, &quot;1.5m&quot;, &quot;2m&quot;, &quot;3m&quot;, &quot;5m&quot;, &quot;10m&quot;) }&#10;&#10;            Text(&#10;                text = &quot;Quick Select:&quot;,&#10;                fontSize = 14.sp,&#10;                fontWeight = FontWeight.Medium&#10;            )&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            LazyRow(&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                contentPadding = PaddingValues(0.dp)&#10;            ) {&#10;                items(&#10;                    count = timeOptions.size,&#10;                    key = { index -&gt; timeOptions[index] }&#10;                ) { index -&gt;&#10;                    FilterChip(&#10;                        onClick = {&#10;                            onPhaseChange(phase.copy(durationSeconds = timeOptions[index]))&#10;                        },&#10;                        label = { Text(timeLabels[index]) },&#10;                        selected = phase.durationSeconds == timeOptions[index]&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // Duration controls&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                horizontalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                Text(&#10;                    text = &quot;Duration:&quot;,&#10;                    fontSize = 16.sp,&#10;                    fontWeight = FontWeight.Medium&#10;                )&#10;&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.spacedBy(4.dp)&#10;                ) {&#10;                    IconButton(&#10;                        onClick = {&#10;                            if (phase.durationSeconds &gt; 10) {&#10;                                onPhaseChange(phase.copy(durationSeconds = phase.durationSeconds - 10))&#10;                            }&#10;                        }&#10;                    ) {&#10;                        Icon(Icons.Default.Remove, contentDescription = &quot;Decrease duration&quot;)&#10;                    }&#10;&#10;                    Text(&#10;                        text = &quot;${phase.durationSeconds / 60}:${String.format(Locale.getDefault(), &quot;%02d&quot;, phase.durationSeconds % 60)}&quot;,&#10;                        fontWeight = FontWeight.Bold,&#10;                        fontSize = 18.sp,&#10;                        modifier = Modifier.widthIn(min = 80.dp)&#10;                    )&#10;&#10;                    IconButton(&#10;                        onClick = {&#10;                            if (phase.durationSeconds &lt; 600) {&#10;                                onPhaseChange(phase.copy(durationSeconds = phase.durationSeconds + 10))&#10;                            }&#10;                        }&#10;                    ) {&#10;                        Icon(Icons.Default.Add, contentDescription = &quot;Increase duration&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun PlayerNamesCard(&#10;    numberOfPlayers: Int,&#10;    playerNames: List&lt;String&gt;,&#10;    onPlayerNamesChange: (List&lt;String&gt;) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;Player Names (Optional)&quot;,&#10;                    fontWeight = FontWeight.Medium,&#10;                    fontSize = 18.sp&#10;                )&#10;                IconButton(&#10;                    onClick = {&#10;                        onPlayerNamesChange(playerNames.reversed())&#10;                    }&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.SwapVert,&#10;                        contentDescription = &quot;Reverse player order&quot;&#10;                    )&#10;                }&#10;            }&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            repeat(numberOfPlayers) { index -&gt;&#10;                key(index) {&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(vertical = 2.dp), // Reduced padding&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        // Move up button&#10;                        IconButton(&#10;                            onClick = {&#10;                                if (index &gt; 0) {&#10;                                    val newNames = playerNames.toMutableList()&#10;                                    val temp = newNames[index]&#10;                                    newNames[index] = newNames[index - 1]&#10;                                    newNames[index - 1] = temp&#10;                                    onPlayerNamesChange(newNames)&#10;                                }&#10;                            },&#10;                            enabled = index &gt; 0&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.KeyboardArrowUp,&#10;                                contentDescription = &quot;Move up&quot;&#10;                            )&#10;                        }&#10;&#10;                        // Player name text field&#10;                        OutlinedTextField(&#10;                            value = if (index &lt; playerNames.size) playerNames[index] else &quot;&quot;,&#10;                            onValueChange = { newName -&gt;&#10;                                val updatedNames = playerNames.toMutableList()&#10;                                while (updatedNames.size &lt;= index) {&#10;                                    updatedNames.add(&quot;&quot;)&#10;                                }&#10;                                updatedNames[index] = newName&#10;                                onPlayerNamesChange(updatedNames)&#10;                            },&#10;                            label = { Text(&quot;Player ${index + 1}&quot;) },&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .padding(horizontal = 8.dp),&#10;                            singleLine = true&#10;                        )&#10;&#10;                        // Move down button&#10;                        IconButton(&#10;                            onClick = {&#10;                                if (index &lt; numberOfPlayers - 1) {&#10;                                    val newNames = playerNames.toMutableList()&#10;                                    val temp = newNames[index]&#10;                                    newNames[index] = newNames[index + 1]&#10;                                    newNames[index + 1] = temp&#10;                                    onPlayerNamesChange(newNames)&#10;                                }&#10;                            },&#10;                            enabled = index &lt; numberOfPlayers - 1&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.KeyboardArrowDown,&#10;                                contentDescription = &quot;Move down&quot;&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun AudioAlertsCard(&#10;    config: GameConfiguration,&#10;    onConfigChange: (GameConfiguration) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Text(&#10;                text = &quot;Audio Alerts&quot;,&#10;                fontWeight = FontWeight.Medium,&#10;                fontSize = 18.sp&#10;            )&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            OptionsCheckboxOption(&#10;                text = &quot;60 seconds remaining&quot;,&#10;                checked = config.audioAlert60s,&#10;                onCheckedChange = { onConfigChange(config.copy(audioAlert60s = it)) }&#10;            )&#10;&#10;            OptionsCheckboxOption(&#10;                text = &quot;30 seconds remaining&quot;,&#10;                checked = config.audioAlert30s,&#10;                onCheckedChange = { onConfigChange(config.copy(audioAlert30s = it)) }&#10;            )&#10;&#10;            OptionsCheckboxOption(&#10;                text = &quot;10 second countdown&quot;,&#10;                checked = config.audioAlert10sCountdown,&#10;                onCheckedChange = { onConfigChange(config.copy(audioAlert10sCountdown = it)) }&#10;            )&#10;&#10;            OptionsCheckboxOption(&#10;                text = &quot;Time out alert&quot;,&#10;                checked = config.audioAlertTimeOut,&#10;                onCheckedChange = { onConfigChange(config.copy(audioAlertTimeOut = it)) }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun OtherOptionsCard(&#10;    config: GameConfiguration,&#10;    onConfigChange: (GameConfiguration) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Text(&#10;                text = &quot;Other Options&quot;,&#10;                fontWeight = FontWeight.Medium,&#10;                fontSize = 18.sp&#10;            )&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            OptionsCheckboxOption(&#10;                text = &quot;Vibrate on alerts&quot;,&#10;                checked = config.vibrateOnAlerts,&#10;                onCheckedChange = { onConfigChange(config.copy(vibrateOnAlerts = it)) }&#10;            )&#10;&#10;            OptionsCheckboxOption(&#10;                text = &quot;Keep counter alignment fixed&quot;,&#10;                checked = config.keepCounterAlignmentFixed,&#10;                onCheckedChange = { onConfigChange(config.copy(keepCounterAlignmentFixed = it)) }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun OptionsCheckboxOption(&#10;    text: String,&#10;    checked: Boolean,&#10;    onCheckedChange: (Boolean) -&gt; Unit&#10;) {&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 6.dp),&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        Checkbox(&#10;            checked = checked,&#10;            onCheckedChange = onCheckedChange&#10;        )&#10;        Spacer(modifier = Modifier.width(12.dp))&#10;        Text(&#10;            text = text,&#10;            fontSize = 16.sp&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.boardgametimer&#10;&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material.icons.filled.KeyboardArrowDown&#10;import androidx.compose.material.icons.filled.KeyboardArrowUp&#10;import androidx.compose.material.icons.filled.Remove&#10;import androidx.compose.material.icons.filled.SwapVert&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.SavedConfiguration&#10;import com.example.boardgametimer.model.TurnPhase&#10;import com.example.boardgametimer.ui.theme.BoardGameTimerTheme&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;import java.util.Locale&#10;&#10;class OptionsActivity : ComponentActivity() {&#10;    private val gson = Gson()&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Get the current configuration from the intent&#10;        val configJson = intent.getStringExtra(&quot;gameConfiguration&quot;)&#10;        val currentConfig = if (configJson != null) {&#10;            gson.fromJson(configJson, GameConfiguration::class.java)&#10;        } else {&#10;            GameConfiguration()&#10;        }&#10;&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            BoardGameTimerTheme {&#10;                Surface(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    color = MaterialTheme.colorScheme.background&#10;                ) {&#10;                    OptionsScreen(&#10;                        initialConfiguration = currentConfig,&#10;                        onSave = { config -&gt;&#10;                            val resultIntent = Intent().apply {&#10;                                putExtra(&quot;gameConfiguration&quot;, gson.toJson(config))&#10;                            }&#10;                            setResult(RESULT_OK, resultIntent)&#10;                            finish()&#10;                        },&#10;                        onCancel = {&#10;                            setResult(RESULT_CANCELED)&#10;                            finish()&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun OptionsScreen(&#10;    initialConfiguration: GameConfiguration,&#10;    onSave: (GameConfiguration) -&gt; Unit,&#10;    onCancel: () -&gt; Unit&#10;) {&#10;    var tempConfig by remember { mutableStateOf(initialConfiguration) }&#10;    var playerNames by remember {&#10;        mutableStateOf(&#10;            List(tempConfig.numberOfPlayers) { index -&gt;&#10;                if (index &lt; tempConfig.playerNames.size) tempConfig.playerNames[index] else &quot;&quot;&#10;            }&#10;        )&#10;    }&#10;    var saveConfigName by remember { mutableStateOf(&quot;&quot;) }&#10;    var showSaveDialog by remember { mutableStateOf(false) }&#10;    &#10;    // Load saved configurations (memoized to prevent recreation)&#10;    val context = LocalContext.current&#10;    val gson = remember { Gson() }&#10;    val prefs = remember { context.getSharedPreferences(&quot;BoardGameTimer&quot;, Context.MODE_PRIVATE) }&#10;    &#10;    var savedConfigurations by remember {&#10;        mutableStateOf&lt;List&lt;SavedConfiguration&gt;&gt;(&#10;            try {&#10;                val json = prefs.getString(&quot;saved_configurations&quot;, &quot;[]&quot;)&#10;                gson.fromJson&lt;List&lt;SavedConfiguration&gt;&gt;(json, object : TypeToken&lt;List&lt;SavedConfiguration&gt;&gt;() {}.type) ?: emptyList&lt;SavedConfiguration&gt;()&#10;            } catch (_: Exception) {&#10;                emptyList&lt;SavedConfiguration&gt;()&#10;            }&#10;        )&#10;    }&#10;&#10;    // Memoize callbacks to prevent unnecessary recompositions&#10;    val saveConfigsToPrefs = remember {&#10;        { configs: List&lt;SavedConfiguration&gt; -&gt;&#10;            val json = gson.toJson(configs)&#10;            prefs.edit().putString(&quot;saved_configurations&quot;, json).apply()&#10;            savedConfigurations = configs&#10;        }&#10;    }&#10;&#10;    val onPlayerCountChange = remember {&#10;        { newCount: Int -&gt;&#10;            tempConfig = tempConfig.copy(numberOfPlayers = newCount)&#10;            playerNames = when {&#10;                newCount &gt; playerNames.size -&gt; playerNames + List(newCount - playerNames.size) { &quot;&quot; }&#10;                newCount &lt; playerNames.size -&gt; playerNames.take(newCount)&#10;                else -&gt; playerNames&#10;            }&#10;        }&#10;    }&#10;&#10;    val onPhasesChange = remember {&#10;        { newPhases: List&lt;TurnPhase&gt; -&gt;&#10;            tempConfig = tempConfig.copy(turnPhases = newPhases)&#10;        }&#10;    }&#10;&#10;    val onConfigChange = remember {&#10;        { newConfig: GameConfiguration -&gt;&#10;            tempConfig = newConfig&#10;        }&#10;    }&#10;&#10;    val onPlayerNamesChange = remember {&#10;        { newNames: List&lt;String&gt; -&gt;&#10;            playerNames = newNames&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Game Options&quot;) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onCancel) {&#10;                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = &quot;Back&quot;)&#10;                    }&#10;                },&#10;                actions = {&#10;                    // Add Save Config button to the top bar&#10;                    TextButton(onClick = { showSaveDialog = true }) {&#10;                        Text(&quot;SAVE CONFIG&quot;)&#10;                    }&#10;                    TextButton(&#10;                        onClick = {&#10;                            val finalConfig = tempConfig.copy(playerNames = playerNames.filter { it.isNotBlank() })&#10;                            onSave(finalConfig)&#10;                        }&#10;                    ) {&#10;                        Text(&quot;SAVE&quot;, fontWeight = FontWeight.Bold)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .padding(horizontal = 16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(12.dp),&#10;            contentPadding = PaddingValues(vertical = 8.dp)&#10;        ) {&#10;            // Saved Configurations - Only show if not empty&#10;            if (savedConfigurations.isNotEmpty()) {&#10;                item(&#10;                    key = &quot;saved_configs&quot;,&#10;                    contentType = &quot;saved_configs_card&quot;&#10;                ) {&#10;                    SavedConfigurationsCard(&#10;                        savedConfigurations = savedConfigurations,&#10;                        onLoadConfiguration = remember {&#10;                            { savedConfig: SavedConfiguration -&gt;&#10;                                tempConfig = savedConfig.configuration&#10;                                playerNames = List(savedConfig.configuration.numberOfPlayers) { index -&gt;&#10;                                    if (index &lt; savedConfig.configuration.playerNames.size) {&#10;                                        savedConfig.configuration.playerNames[index]&#10;                                    } else &quot;&quot;&#10;                                }&#10;                            }&#10;                        },&#10;                        onDeleteConfiguration = remember {&#10;                            { configName: String -&gt;&#10;                                val updatedConfigs = savedConfigurations.filter { it.name != configName }&#10;                                saveConfigsToPrefs(updatedConfigs)&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Number of Players&#10;            item(&#10;                key = &quot;player_count&quot;,&#10;                contentType = &quot;player_count_card&quot;&#10;            ) {&#10;                PlayerCountCard(&#10;                    numberOfPlayers = tempConfig.numberOfPlayers,&#10;                    onPlayerCountChange = onPlayerCountChange&#10;                )&#10;            }&#10;&#10;            // Round Configuration&#10;            item(&#10;                key = &quot;round_config&quot;,&#10;                contentType = &quot;round_config_card&quot;&#10;            ) {&#10;                RoundConfigurationCard(&#10;                    turnPhases = tempConfig.turnPhases,&#10;                    onPhasesChange = onPhasesChange&#10;                )&#10;            }&#10;&#10;            // Player Names&#10;            item(&#10;                key = &quot;player_names&quot;,&#10;                contentType = &quot;player_names_card&quot;&#10;            ) {&#10;                PlayerNamesCard(&#10;                    numberOfPlayers = tempConfig.numberOfPlayers,&#10;                    playerNames = playerNames,&#10;                    onPlayerNamesChange = onPlayerNamesChange&#10;                )&#10;            }&#10;&#10;            // Audio Alerts&#10;            item(&#10;                key = &quot;audio_alerts&quot;,&#10;                contentType = &quot;audio_alerts_card&quot;&#10;            ) {&#10;                AudioAlertsCard(&#10;                    config = tempConfig,&#10;                    onConfigChange = onConfigChange&#10;                )&#10;            }&#10;&#10;            // Other Options&#10;            item(&#10;                key = &quot;other_options&quot;,&#10;                contentType = &quot;other_options_card&quot;&#10;            ) {&#10;                OtherOptionsCard(&#10;                    config = tempConfig,&#10;                    onConfigChange = onConfigChange&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    // Save Configuration Dialog&#10;    if (showSaveDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showSaveDialog = false },&#10;            title = { Text(&quot;Save Configuration&quot;) },&#10;            text = {&#10;                OutlinedTextField(&#10;                    value = saveConfigName,&#10;                    onValueChange = { saveConfigName = it },&#10;                    label = { Text(&quot;Configuration Name&quot;) },&#10;                    singleLine = true&#10;                )&#10;            },&#10;            confirmButton = {&#10;                TextButton(&#10;                    onClick = {&#10;                        if (saveConfigName.isNotBlank()) {&#10;                            val finalConfig = tempConfig.copy(playerNames = playerNames.filter { it.isNotBlank() })&#10;                            val newSavedConfig = SavedConfiguration(saveConfigName, finalConfig)&#10;                            val updatedConfigs = savedConfigurations.toMutableList().apply {&#10;                                removeAll { it.name == saveConfigName }&#10;                                add(newSavedConfig)&#10;                            }&#10;                            saveConfigsToPrefs(updatedConfigs)&#10;                            showSaveDialog = false&#10;                            saveConfigName = &quot;&quot;&#10;                        }&#10;                    }&#10;                ) {&#10;                    Text(&quot;Save&quot;)&#10;                }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { showSaveDialog = false }) {&#10;                    Text(&quot;Cancel&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;// Separate composables for each card to improve performance&#10;@Composable&#10;private fun SavedConfigurationsCard(&#10;    savedConfigurations: List&lt;SavedConfiguration&gt;,&#10;    onLoadConfiguration: (SavedConfiguration) -&gt; Unit,&#10;    onDeleteConfiguration: (String) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Text(&#10;                text = &quot;Saved Configurations&quot;,&#10;                fontWeight = FontWeight.Medium,&#10;                fontSize = 18.sp&#10;            )&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            savedConfigurations.forEach { savedConfig -&gt;&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(vertical = 4.dp),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Column(modifier = Modifier.weight(1f)) {&#10;                        Text(&#10;                            text = savedConfig.name,&#10;                            fontWeight = FontWeight.Medium&#10;                        )&#10;                        Text(&#10;                            text = &quot;${savedConfig.configuration.numberOfPlayers} players, ${savedConfig.configuration.turnPhases.size} phases&quot;,&#10;                            fontSize = 12.sp,&#10;                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)&#10;                        )&#10;                    }&#10;                    Row {&#10;                        TextButton(onClick = { onLoadConfiguration(savedConfig) }) {&#10;                            Text(&quot;Load&quot;)&#10;                        }&#10;                        IconButton(onClick = { onDeleteConfiguration(savedConfig.name) }) {&#10;                            Icon(&#10;                                Icons.Default.Delete,&#10;                                contentDescription = &quot;Delete&quot;,&#10;                                tint = MaterialTheme.colorScheme.error&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                if (savedConfig != savedConfigurations.last()) {&#10;                    HorizontalDivider()&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun PlayerCountCard(&#10;    numberOfPlayers: Int,&#10;    onPlayerCountChange: (Int) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Text(&#10;                text = &quot;Number of Players&quot;,&#10;                fontWeight = FontWeight.Medium,&#10;                fontSize = 18.sp&#10;            )&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                horizontalArrangement = Arrangement.Center&#10;            ) {&#10;                IconButton(&#10;                    onClick = {&#10;                        if (numberOfPlayers &gt; 1) {&#10;                            onPlayerCountChange(numberOfPlayers - 1)&#10;                        }&#10;                    }&#10;                ) {&#10;                    Icon(Icons.Default.Remove, contentDescription = &quot;Decrease players&quot;)&#10;                }&#10;&#10;                Text(&#10;                    text = numberOfPlayers.toString(),&#10;                    fontSize = 24.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    modifier = Modifier.padding(horizontal = 32.dp)&#10;                )&#10;&#10;                IconButton(&#10;                    onClick = {&#10;                        if (numberOfPlayers &lt; 15) {&#10;                            onPlayerCountChange(numberOfPlayers + 1)&#10;                        }&#10;                    }&#10;                ) {&#10;                    Icon(Icons.Default.Add, contentDescription = &quot;Increase players&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun RoundConfigurationCard(&#10;    turnPhases: List&lt;TurnPhase&gt;,&#10;    onPhasesChange: (List&lt;TurnPhase&gt;) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;Round Configuration&quot;,&#10;                    fontWeight = FontWeight.Medium,&#10;                    fontSize = 18.sp&#10;                )&#10;&#10;                IconButton(&#10;                    onClick = {&#10;                        val newPhases = turnPhases + TurnPhase(&quot;Phase ${turnPhases.size + 1}&quot;, 60)&#10;                        onPhasesChange(newPhases)&#10;                    }&#10;                ) {&#10;                    Icon(Icons.Default.Add, contentDescription = &quot;Add Phase&quot;)&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // Use key for each phase to improve performance&#10;            turnPhases.forEachIndexed { index, phase -&gt;&#10;                key(index) {&#10;                    PhaseConfigCard(&#10;                        phase = phase,&#10;                        phaseIndex = index,&#10;                        canDelete = turnPhases.size &gt; 1,&#10;                        onPhaseChange = { newPhase -&gt;&#10;                            val newPhases = turnPhases.toMutableList()&#10;                            newPhases[index] = newPhase&#10;                            onPhasesChange(newPhases)&#10;                        },&#10;                        onDeletePhase = {&#10;                            val newPhases = turnPhases.toMutableList()&#10;                            newPhases.removeAt(index)&#10;                            onPhasesChange(newPhases)&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun PhaseConfigCard(&#10;    phase: TurnPhase,&#10;    phaseIndex: Int,&#10;    canDelete: Boolean,&#10;    onPhaseChange: (TurnPhase) -&gt; Unit,&#10;    onDeletePhase: () -&gt; Unit&#10;) {&#10;    // Memoize expensive computations&#10;    val timeOptions = remember { listOf(30, 60, 90, 120, 180, 300, 600) }&#10;    val timeLabels = remember { listOf(&quot;30s&quot;, &quot;1m&quot;, &quot;1.5m&quot;, &quot;2m&quot;, &quot;3m&quot;, &quot;5m&quot;, &quot;10m&quot;) }&#10;    val formattedTime = remember(phase.durationSeconds) {&#10;        &quot;${phase.durationSeconds / 60}:${String.format(Locale.getDefault(), &quot;%02d&quot;, phase.durationSeconds % 60)}&quot;&#10;    }&#10;    &#10;    // Memoize callbacks&#10;    val onNameChange = remember {&#10;        { newName: String -&gt;&#10;            onPhaseChange(phase.copy(name = newName))&#10;        }&#10;    }&#10;    &#10;    val onDurationDecrease = remember {&#10;        {&#10;            if (phase.durationSeconds &gt; 10) {&#10;                onPhaseChange(phase.copy(durationSeconds = phase.durationSeconds - 10))&#10;            }&#10;        }&#10;    }&#10;    &#10;    val onDurationIncrease = remember {&#10;        {&#10;            if (phase.durationSeconds &lt; 600) {&#10;                onPhaseChange(phase.copy(durationSeconds = phase.durationSeconds + 10))&#10;            }&#10;        }&#10;    }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;        )&#10;    ) {&#10;        Column(modifier = Modifier.padding(12.dp)) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;Phase ${phaseIndex + 1}&quot;,&#10;                    fontWeight = FontWeight.Medium,&#10;                    fontSize = 16.sp&#10;                )&#10;&#10;                if (canDelete) {&#10;                    IconButton(onClick = onDeletePhase) {&#10;                        Icon(Icons.Default.Delete, contentDescription = &quot;Delete Phase&quot;)&#10;                    }&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Phase name input&#10;            OutlinedTextField(&#10;                value = phase.name,&#10;                onValueChange = onNameChange,&#10;                label = { Text(&quot;Phase Name&quot;) },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                singleLine = true&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            Text(&#10;                text = &quot;Quick Select:&quot;,&#10;                fontSize = 14.sp,&#10;                fontWeight = FontWeight.Medium&#10;            )&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Replace LazyRow with FlowRow for better performance&#10;            QuickSelectChips(&#10;                timeOptions = timeOptions,&#10;                timeLabels = timeLabels,&#10;                currentDuration = phase.durationSeconds,&#10;                onDurationSelect = { duration -&gt;&#10;                    onPhaseChange(phase.copy(durationSeconds = duration))&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // Duration controls&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                horizontalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                Text(&#10;                    text = &quot;Duration:&quot;,&#10;                    fontSize = 16.sp,&#10;                    fontWeight = FontWeight.Medium&#10;                )&#10;&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.spacedBy(4.dp)&#10;                ) {&#10;                    IconButton(onClick = onDurationDecrease) {&#10;                        Icon(Icons.Default.Remove, contentDescription = &quot;Decrease duration&quot;)&#10;                    }&#10;&#10;                    Text(&#10;                        text = formattedTime,&#10;                        fontWeight = FontWeight.Bold,&#10;                        fontSize = 18.sp,&#10;                        modifier = Modifier.widthIn(min = 80.dp)&#10;                    )&#10;&#10;                    IconButton(onClick = onDurationIncrease) {&#10;                        Icon(Icons.Default.Add, contentDescription = &quot;Increase duration&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun QuickSelectChips(&#10;    timeOptions: List&lt;Int&gt;,&#10;    timeLabels: List&lt;String&gt;,&#10;    currentDuration: Int,&#10;    onDurationSelect: (Int) -&gt; Unit&#10;) {&#10;    // Use FlowRow instead of LazyRow for better performance with small lists&#10;    Row(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        horizontalArrangement = Arrangement.spacedBy(6.dp)&#10;    ) {&#10;        timeOptions.forEachIndexed { index, duration -&gt;&#10;            FilterChip(&#10;                onClick = { onDurationSelect(duration) },&#10;                label = { Text(timeLabels[index]) },&#10;                selected = currentDuration == duration,&#10;                modifier = Modifier.padding(horizontal = 2.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun PlayerNamesCard(&#10;    numberOfPlayers: Int,&#10;    playerNames: List&lt;String&gt;,&#10;    onPlayerNamesChange: (List&lt;String&gt;) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;Player Names (Optional)&quot;,&#10;                    fontWeight = FontWeight.Medium,&#10;                    fontSize = 18.sp&#10;                )&#10;                IconButton(&#10;                    onClick = {&#10;                        onPlayerNamesChange(playerNames.reversed())&#10;                    }&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.SwapVert,&#10;                        contentDescription = &quot;Reverse player order&quot;&#10;                    )&#10;                }&#10;            }&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            repeat(numberOfPlayers) { index -&gt;&#10;                key(index) {&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(vertical = 2.dp), // Reduced padding&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        // Move up button&#10;                        IconButton(&#10;                            onClick = {&#10;                                if (index &gt; 0) {&#10;                                    val newNames = playerNames.toMutableList()&#10;                                    val temp = newNames[index]&#10;                                    newNames[index] = newNames[index - 1]&#10;                                    newNames[index - 1] = temp&#10;                                    onPlayerNamesChange(newNames)&#10;                                }&#10;                            },&#10;                            enabled = index &gt; 0&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.KeyboardArrowUp,&#10;                                contentDescription = &quot;Move up&quot;&#10;                            )&#10;                        }&#10;&#10;                        // Player name text field&#10;                        OutlinedTextField(&#10;                            value = if (index &lt; playerNames.size) playerNames[index] else &quot;&quot;,&#10;                            onValueChange = { newName -&gt;&#10;                                val updatedNames = playerNames.toMutableList()&#10;                                while (updatedNames.size &lt;= index) {&#10;                                    updatedNames.add(&quot;&quot;)&#10;                                }&#10;                                updatedNames[index] = newName&#10;                                onPlayerNamesChange(updatedNames)&#10;                            },&#10;                            label = { Text(&quot;Player ${index + 1}&quot;) },&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .padding(horizontal = 8.dp),&#10;                            singleLine = true&#10;                        )&#10;&#10;                        // Move down button&#10;                        IconButton(&#10;                            onClick = {&#10;                                if (index &lt; numberOfPlayers - 1) {&#10;                                    val newNames = playerNames.toMutableList()&#10;                                    val temp = newNames[index]&#10;                                    newNames[index] = newNames[index + 1]&#10;                                    newNames[index + 1] = temp&#10;                                    onPlayerNamesChange(newNames)&#10;                                }&#10;                            },&#10;                            enabled = index &lt; numberOfPlayers - 1&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.KeyboardArrowDown,&#10;                                contentDescription = &quot;Move down&quot;&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun AudioAlertsCard(&#10;    config: GameConfiguration,&#10;    onConfigChange: (GameConfiguration) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Text(&#10;                text = &quot;Audio Alerts&quot;,&#10;                fontWeight = FontWeight.Medium,&#10;                fontSize = 18.sp&#10;            )&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            OptionsCheckboxOption(&#10;                text = &quot;60 seconds remaining&quot;,&#10;                checked = config.audioAlert60s,&#10;                onCheckedChange = { onConfigChange(config.copy(audioAlert60s = it)) }&#10;            )&#10;&#10;            OptionsCheckboxOption(&#10;                text = &quot;30 seconds remaining&quot;,&#10;                checked = config.audioAlert30s,&#10;                onCheckedChange = { onConfigChange(config.copy(audioAlert30s = it)) }&#10;            )&#10;&#10;            OptionsCheckboxOption(&#10;                text = &quot;10 second countdown&quot;,&#10;                checked = config.audioAlert10sCountdown,&#10;                onCheckedChange = { onConfigChange(config.copy(audioAlert10sCountdown = it)) }&#10;            )&#10;&#10;            OptionsCheckboxOption(&#10;                text = &quot;Time out alert&quot;,&#10;                checked = config.audioAlertTimeOut,&#10;                onCheckedChange = { onConfigChange(config.copy(audioAlertTimeOut = it)) }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun OtherOptionsCard(&#10;    config: GameConfiguration,&#10;    onConfigChange: (GameConfiguration) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Text(&#10;                text = &quot;Other Options&quot;,&#10;                fontWeight = FontWeight.Medium,&#10;                fontSize = 18.sp&#10;            )&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            OptionsCheckboxOption(&#10;                text = &quot;Vibrate on alerts&quot;,&#10;                checked = config.vibrateOnAlerts,&#10;                onCheckedChange = { onConfigChange(config.copy(vibrateOnAlerts = it)) }&#10;            )&#10;&#10;            OptionsCheckboxOption(&#10;                text = &quot;Keep counter alignment fixed&quot;,&#10;                checked = config.keepCounterAlignmentFixed,&#10;                onCheckedChange = { onConfigChange(config.copy(keepCounterAlignmentFixed = it)) }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun OptionsCheckboxOption(&#10;    text: String,&#10;    checked: Boolean,&#10;    onCheckedChange: (Boolean) -&gt; Unit&#10;) {&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 6.dp),&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        Checkbox(&#10;            checked = checked,&#10;            onCheckedChange = onCheckedChange&#10;        )&#10;        Spacer(modifier = Modifier.width(12.dp))&#10;        Text(&#10;            text = text,&#10;            fontSize = 16.sp&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModelNew.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModelNew.kt" />
              <option name="updatedContent" value="package com.example.boardgametimer.viewmodel&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.media.AudioManager&#10;import android.media.ToneGenerator&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.speech.tts.TextToSpeech&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.GameState&#10;import com.example.boardgametimer.model.SavedConfiguration&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.util.Locale&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;&#10;class GameTimerViewModel : ViewModel() {&#10;&#10;    var gameState by mutableStateOf(GameState())&#10;        private set&#10;&#10;    var gameConfiguration by mutableStateOf(GameConfiguration())&#10;        private set&#10;&#10;    var showOptions by mutableStateOf(false)&#10;        private set&#10;&#10;    var showStats by mutableStateOf(false)&#10;        private set&#10;&#10;    var undoHistory by mutableStateOf&lt;GameState?&gt;(null)&#10;        private set&#10;&#10;    var savedConfigurations by mutableStateOf&lt;List&lt;SavedConfiguration&gt;&gt;(emptyList())&#10;        private set&#10;&#10;    private var timerJob: Job? = null&#10;    private var toneGenerator: ToneGenerator? = null&#10;    private var vibrator: Vibrator? = null&#10;    private var textToSpeech: TextToSpeech? = null&#10;    private var ttsReady = false&#10;    private var sharedPreferences: SharedPreferences? = null&#10;    private val gson = Gson()&#10;&#10;    fun initializeAudio(context: Context) {&#10;        toneGenerator = ToneGenerator(AudioManager.STREAM_NOTIFICATION, 100)&#10;&#10;        // Use modern vibrator API&#10;        vibrator = if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.S) {&#10;            val vibratorManager = context.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            vibratorManager.defaultVibrator&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;&#10;        textToSpeech = TextToSpeech(context) { status -&gt;&#10;            if (status == TextToSpeech.SUCCESS) {&#10;                textToSpeech?.language = Locale.getDefault()&#10;                ttsReady = true&#10;            }&#10;        }&#10;&#10;        // Initialize SharedPreferences for saving configurations&#10;        sharedPreferences = context.getSharedPreferences(&quot;BoardGameTimer&quot;, Context.MODE_PRIVATE)&#10;        loadSavedConfigurations()&#10;    }&#10;&#10;    fun startNewGame() {&#10;        val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;        gameState = GameState(&#10;            currentPlayerIndex = 0,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            isGameRunning = true,&#10;            isPaused = true, // Start paused&#10;            roundCount = 0,&#10;            playerTurnTimes = playerTurnTimes,&#10;            gameStartTime = System.currentTimeMillis(),&#10;            turnStartTime = System.currentTimeMillis()&#10;        )&#10;        // Don't start timer automatically - wait for user to resume&#10;    }&#10;&#10;    fun nextPlayer() {&#10;        if (!gameState.isGameRunning) return&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        // Record the time taken for current player's turn&#10;        val timeTaken = gameConfiguration.turnDurationSeconds - gameState.timeRemainingSeconds&#10;        val currentPlayerTimes = gameState.playerTurnTimes[gameState.currentPlayerIndex].toMutableList()&#10;        currentPlayerTimes.add(timeTaken)&#10;&#10;        val updatedPlayerTurnTimes = gameState.playerTurnTimes.toMutableList()&#10;        updatedPlayerTurnTimes[gameState.currentPlayerIndex] = currentPlayerTimes&#10;&#10;        val nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameConfiguration.numberOfPlayers&#10;        val newRoundCount = if (nextPlayerIndex == 0) gameState.roundCount + 1 else gameState.roundCount&#10;&#10;        gameState = gameState.copy(&#10;            currentPlayerIndex = nextPlayerIndex,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            playerTurnTimes = updatedPlayerTurnTimes,&#10;            roundCount = newRoundCount,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = true // Pause after each player switch&#10;        )&#10;&#10;        // Don't auto-start timer - let user resume manually&#10;    }&#10;&#10;    fun undoLastAction() {&#10;        undoHistory?.let { previousState -&gt;&#10;            gameState = previousState&#10;            undoHistory = null&#10;            if (gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun pauseResumeGame() {&#10;        if (gameState.isGameRunning) {&#10;            gameState = gameState.copy(isPaused = !gameState.isPaused)&#10;            if (gameState.isPaused) {&#10;                timerJob?.cancel()&#10;            } else {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun endGame() {&#10;        timerJob?.cancel()&#10;        gameState = gameState.copy(isGameRunning = false, isPaused = false)&#10;        showStats = true&#10;    }&#10;&#10;    private fun startTimer() {&#10;        timerJob?.cancel()&#10;        timerJob = viewModelScope.launch {&#10;            var lastUpdateTime = System.currentTimeMillis()&#10;            var lastSecond = gameState.timeRemainingSeconds&#10;            &#10;            while (gameState.timeRemainingMillis &gt; 0 &amp;&amp; gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                delay(16) // Update every 16ms for smooth animation (~60fps)&#10;                &#10;                val currentTime = System.currentTimeMillis()&#10;                val deltaTime = currentTime - lastUpdateTime&#10;                lastUpdateTime = currentTime&#10;                &#10;                val newTimeMillis = (gameState.timeRemainingMillis - deltaTime).coerceAtLeast(0L)&#10;                val newTimeSeconds = (newTimeMillis / 1000).toInt()&#10;                &#10;                gameState = gameState.copy(&#10;                    timeRemainingMillis = newTimeMillis,&#10;                    timeRemainingSeconds = newTimeSeconds&#10;                )&#10;&#10;                // Handle audio alerts (only on second changes)&#10;                if (newTimeSeconds != lastSecond) {&#10;                    lastSecond = newTimeSeconds&#10;                    when (newTimeSeconds) {&#10;                        60 -&gt; if (gameConfiguration.audioAlert60s) playAlert()&#10;                        30 -&gt; if (gameConfiguration.audioAlert30s) playAlert()&#10;                        10, 9, 8, 7, 6, 5, 4, 3, 2, 1 -&gt; {&#10;                            if (gameConfiguration.audioAlert10sCountdown) {&#10;                                speakCountdown(newTimeSeconds)&#10;                            }&#10;                        }&#10;                        0 -&gt; {&#10;                            if (gameConfiguration.audioAlertTimeOut) playAlert()&#10;                            break&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun playAlert() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_CDMA_ALERT_CALL_GUARD, 200)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun speakCountdown(seconds: Int) {&#10;        if (ttsReady) {&#10;            textToSpeech?.speak(seconds.toString(), TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    fun updateConfiguration(newConfig: GameConfiguration) {&#10;        gameConfiguration = newConfig&#10;        // Reset game state with new configuration&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(newConfig.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = newConfig.turnDurationSeconds,&#10;                timeRemainingMillis = newConfig.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = true&#10;            )&#10;        }&#10;    }&#10;&#10;    fun saveConfiguration(name: String) {&#10;        if (name.isBlank()) return&#10;        &#10;        val newConfig = SavedConfiguration(name, gameConfiguration)&#10;        val updatedConfigs = savedConfigurations.toMutableList()&#10;        &#10;        // Remove existing config with same name&#10;        updatedConfigs.removeAll { it.name == name }&#10;        updatedConfigs.add(newConfig)&#10;        &#10;        savedConfigurations = updatedConfigs&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    fun loadConfiguration(savedConfig: SavedConfiguration) {&#10;        gameConfiguration = savedConfig.configuration&#10;        // Reset game state with new configuration&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;                timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = true&#10;            )&#10;        }&#10;    }&#10;&#10;    fun deleteConfiguration(configName: String) {&#10;        savedConfigurations = savedConfigurations.filter { it.name != configName }&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    private fun loadSavedConfigurations() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = prefs.getString(&quot;saved_configurations&quot;, &quot;[]&quot;)&#10;            val type = object : TypeToken&lt;List&lt;SavedConfiguration&gt;&gt;() {}.type&#10;            try {&#10;                savedConfigurations = gson.fromJson(json, type) ?: emptyList()&#10;            } catch (e: Exception) {&#10;                savedConfigurations = emptyList()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveToPersistentStorage() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = gson.toJson(savedConfigurations)&#10;            prefs.edit().putString(&quot;saved_configurations&quot;, json).apply()&#10;        }&#10;    }&#10;&#10;    fun showOptions() {&#10;        showOptions = true&#10;    }&#10;&#10;    fun hideOptions() {&#10;        showOptions = false&#10;    }&#10;&#10;    fun hideStats() {&#10;        showStats = false&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        toneGenerator?.release()&#10;        textToSpeech?.shutdown()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModel_Fixed.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModel_Fixed.kt" />
              <option name="updatedContent" value="package com.example.boardgametimer.viewmodel&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.media.AudioManager&#10;import android.media.ToneGenerator&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.speech.tts.TextToSpeech&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.GameState&#10;import com.example.boardgametimer.model.SavedConfiguration&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.util.Locale&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;&#10;class GameTimerViewModel : ViewModel() {&#10;&#10;    var gameState by mutableStateOf(GameState())&#10;        private set&#10;&#10;    var gameConfiguration by mutableStateOf(GameConfiguration())&#10;        private set&#10;&#10;    var showOptions by mutableStateOf(false)&#10;        private set&#10;&#10;    var showStats by mutableStateOf(false)&#10;        private set&#10;&#10;    var undoHistory by mutableStateOf&lt;GameState?&gt;(null)&#10;        private set&#10;&#10;    var savedConfigurations by mutableStateOf&lt;List&lt;SavedConfiguration&gt;&gt;(emptyList())&#10;        private set&#10;&#10;    private var timerJob: Job? = null&#10;    private var toneGenerator: ToneGenerator? = null&#10;    private var vibrator: Vibrator? = null&#10;    private var textToSpeech: TextToSpeech? = null&#10;    private var ttsReady = false&#10;    private var sharedPreferences: SharedPreferences? = null&#10;    private val gson = Gson()&#10;&#10;    fun initializeAudio(context: Context) {&#10;        toneGenerator = ToneGenerator(AudioManager.STREAM_NOTIFICATION, 100)&#10;&#10;        // Use modern vibrator API&#10;        vibrator = if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.S) {&#10;            val vibratorManager = context.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            vibratorManager.defaultVibrator&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;&#10;        textToSpeech = TextToSpeech(context) { status -&gt;&#10;            if (status == TextToSpeech.SUCCESS) {&#10;                textToSpeech?.language = Locale.getDefault()&#10;                ttsReady = true&#10;            }&#10;        }&#10;&#10;        // Initialize SharedPreferences for saving configurations&#10;        sharedPreferences = context.getSharedPreferences(&quot;BoardGameTimer&quot;, Context.MODE_PRIVATE)&#10;        loadSavedConfigurations()&#10;    }&#10;&#10;    fun startNewGame() {&#10;        val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;        gameState = GameState(&#10;            currentPlayerIndex = 0,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            isGameRunning = true,&#10;            isPaused = false, // Start ready to play, not paused&#10;            roundCount = 0,&#10;            playerTurnTimes = playerTurnTimes,&#10;            gameStartTime = System.currentTimeMillis(),&#10;            turnStartTime = System.currentTimeMillis()&#10;        )&#10;        startTimer() // Auto-start the timer for the first player&#10;    }&#10;&#10;    fun nextPlayer() {&#10;        if (!gameState.isGameRunning) return&#10;&#10;        // Play a beep sound when passing turn&#10;        playTurnPassBeep()&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        // Record the time taken for current player's turn&#10;        val timeTaken = gameConfiguration.turnDurationSeconds - gameState.timeRemainingSeconds&#10;        val currentPlayerTimes = gameState.playerTurnTimes[gameState.currentPlayerIndex].toMutableList()&#10;        currentPlayerTimes.add(timeTaken)&#10;&#10;        val updatedPlayerTurnTimes = gameState.playerTurnTimes.toMutableList()&#10;        updatedPlayerTurnTimes[gameState.currentPlayerIndex] = currentPlayerTimes&#10;&#10;        val nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameConfiguration.numberOfPlayers&#10;        val newRoundCount = if (nextPlayerIndex == 0) gameState.roundCount + 1 else gameState.roundCount&#10;&#10;        gameState = gameState.copy(&#10;            currentPlayerIndex = nextPlayerIndex,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            playerTurnTimes = updatedPlayerTurnTimes,&#10;            roundCount = newRoundCount,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = false // Don't pause after each player switch&#10;        )&#10;&#10;        // Auto-start timer for next player&#10;        startTimer()&#10;    }&#10;&#10;    fun undoLastAction() {&#10;        undoHistory?.let { previousState -&gt;&#10;            gameState = previousState&#10;            undoHistory = null&#10;            if (gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun pauseResumeGame() {&#10;        if (gameState.isGameRunning) {&#10;            gameState = gameState.copy(isPaused = !gameState.isPaused)&#10;            if (gameState.isPaused) {&#10;                timerJob?.cancel()&#10;            } else {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun endGame() {&#10;        timerJob?.cancel()&#10;        gameState = gameState.copy(isGameRunning = false, isPaused = false)&#10;        showStats = true&#10;    }&#10;&#10;    private fun startTimer() {&#10;        timerJob?.cancel()&#10;        timerJob = viewModelScope.launch {&#10;            var lastUpdateTime = System.currentTimeMillis()&#10;            var lastSecond = gameState.timeRemainingSeconds&#10;&#10;            while (gameState.timeRemainingMillis &gt; 0 &amp;&amp; gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                delay(16) // Update every 16ms for smooth animation (~60fps)&#10;&#10;                val currentTime = System.currentTimeMillis()&#10;                val deltaTime = currentTime - lastUpdateTime&#10;                lastUpdateTime = currentTime&#10;&#10;                val newTimeMillis = (gameState.timeRemainingMillis - deltaTime).coerceAtLeast(0L)&#10;                val newTimeSeconds = (newTimeMillis / 1000).toInt()&#10;&#10;                gameState = gameState.copy(&#10;                    timeRemainingMillis = newTimeMillis,&#10;                    timeRemainingSeconds = newTimeSeconds&#10;                )&#10;&#10;                // Handle audio alerts (only on second changes)&#10;                if (newTimeSeconds != lastSecond) {&#10;                    lastSecond = newTimeSeconds&#10;                    when (newTimeSeconds) {&#10;                        60 -&gt; if (gameConfiguration.audioAlert60s) playAlert()&#10;                        30 -&gt; if (gameConfiguration.audioAlert30s) playAlert()&#10;                        10, 9, 8, 7, 6, 5, 4, 3, 2, 1 -&gt; {&#10;                            if (gameConfiguration.audioAlert10sCountdown) {&#10;                                speakCountdown(newTimeSeconds)&#10;                            }&#10;                        }&#10;                        0 -&gt; {&#10;                            if (gameConfiguration.audioAlertTimeOut) playAlert()&#10;                            break&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun playAlert() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_CDMA_ALERT_CALL_GUARD, 200)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun playTurnPassBeep() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_PROP_BEEP, 150)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun speakCountdown(seconds: Int) {&#10;        if (ttsReady) {&#10;            textToSpeech?.speak(seconds.toString(), TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    fun updateConfiguration(newConfig: GameConfiguration) {&#10;        gameConfiguration = newConfig&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(newConfig.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = newConfig.turnDurationSeconds,&#10;                timeRemainingMillis = newConfig.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun saveConfiguration(name: String) {&#10;        if (name.isBlank()) return&#10;&#10;        val newConfig = SavedConfiguration(name, gameConfiguration)&#10;        val updatedConfigs = savedConfigurations.toMutableList()&#10;&#10;        // Remove existing config with same name&#10;        updatedConfigs.removeAll { it.name == name }&#10;        updatedConfigs.add(newConfig)&#10;&#10;        savedConfigurations = updatedConfigs&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    fun loadConfiguration(savedConfig: SavedConfiguration) {&#10;        gameConfiguration = savedConfig.configuration&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;                timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun deleteConfiguration(configName: String) {&#10;        savedConfigurations = savedConfigurations.filter { it.name != configName }&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    private fun loadSavedConfigurations() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = prefs.getString(&quot;saved_configurations&quot;, &quot;[]&quot;)&#10;            val type = object : TypeToken&lt;List&lt;SavedConfiguration&gt;&gt;() {}.type&#10;            try {&#10;                savedConfigurations = gson.fromJson(json, type) ?: emptyList()&#10;            } catch (e: Exception) {&#10;                savedConfigurations = emptyList()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveToPersistentStorage() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = gson.toJson(savedConfigurations)&#10;            prefs.edit().putString(&quot;saved_configurations&quot;, json).apply()&#10;        }&#10;    }&#10;&#10;    fun showOptions() {&#10;        showOptions = true&#10;    }&#10;&#10;    fun hideOptions() {&#10;        showOptions = false&#10;    }&#10;&#10;    fun hideStats() {&#10;        showStats = false&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        toneGenerator?.release()&#10;        textToSpeech?.shutdown()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModel_updated.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModel_updated.kt" />
              <option name="updatedContent" value="package com.example.boardgametimer.viewmodel&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.media.AudioManager&#10;import android.media.ToneGenerator&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.speech.tts.TextToSpeech&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.GameState&#10;import com.example.boardgametimer.model.SavedConfiguration&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.util.Locale&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;&#10;class GameTimerViewModel : ViewModel() {&#10;&#10;    var gameState by mutableStateOf(GameState())&#10;        private set&#10;&#10;    var gameConfiguration by mutableStateOf(GameConfiguration())&#10;        private set&#10;&#10;    var showOptions by mutableStateOf(false)&#10;        private set&#10;&#10;    var showStats by mutableStateOf(false)&#10;        private set&#10;&#10;    var undoHistory by mutableStateOf&lt;GameState?&gt;(null)&#10;        private set&#10;&#10;    var savedConfigurations by mutableStateOf&lt;List&lt;SavedConfiguration&gt;&gt;(emptyList())&#10;        private set&#10;&#10;    private var timerJob: Job? = null&#10;    private var toneGenerator: ToneGenerator? = null&#10;    private var vibrator: Vibrator? = null&#10;    private var textToSpeech: TextToSpeech? = null&#10;    private var ttsReady = false&#10;    private var sharedPreferences: SharedPreferences? = null&#10;    private val gson = Gson()&#10;&#10;    fun initializeAudio(context: Context) {&#10;        toneGenerator = ToneGenerator(AudioManager.STREAM_NOTIFICATION, 100)&#10;&#10;        // Use modern vibrator API&#10;        vibrator = if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.S) {&#10;            val vibratorManager = context.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            vibratorManager.defaultVibrator&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;&#10;        textToSpeech = TextToSpeech(context) { status -&gt;&#10;            if (status == TextToSpeech.SUCCESS) {&#10;                textToSpeech?.language = Locale.getDefault()&#10;                ttsReady = true&#10;            }&#10;        }&#10;&#10;        // Initialize SharedPreferences for saving configurations&#10;        sharedPreferences = context.getSharedPreferences(&quot;BoardGameTimer&quot;, Context.MODE_PRIVATE)&#10;        loadSavedConfigurations()&#10;    }&#10;&#10;    fun startNewGame() {&#10;        val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;        gameState = GameState(&#10;            currentPlayerIndex = 0,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            isGameRunning = true,&#10;            isPaused = false, // Start ready to play, not paused&#10;            roundCount = 0,&#10;            playerTurnTimes = playerTurnTimes,&#10;            gameStartTime = System.currentTimeMillis(),&#10;            turnStartTime = System.currentTimeMillis()&#10;        )&#10;        startTimer() // Auto-start the timer for the first player&#10;    }&#10;&#10;    fun nextPlayer() {&#10;        if (!gameState.isGameRunning) return&#10;&#10;        // Play a beep sound when passing turn&#10;        playTurnPassBeep()&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        // Record the time taken for current player's turn&#10;        val timeTaken = gameConfiguration.turnDurationSeconds - gameState.timeRemainingSeconds&#10;        val currentPlayerTimes = gameState.playerTurnTimes[gameState.currentPlayerIndex].toMutableList()&#10;        currentPlayerTimes.add(timeTaken)&#10;&#10;        val updatedPlayerTurnTimes = gameState.playerTurnTimes.toMutableList()&#10;        updatedPlayerTurnTimes[gameState.currentPlayerIndex] = currentPlayerTimes&#10;&#10;        val nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameConfiguration.numberOfPlayers&#10;        val newRoundCount = if (nextPlayerIndex == 0) gameState.roundCount + 1 else gameState.roundCount&#10;&#10;        gameState = gameState.copy(&#10;            currentPlayerIndex = nextPlayerIndex,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            playerTurnTimes = updatedPlayerTurnTimes,&#10;            roundCount = newRoundCount,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = false // Don't pause after each player switch&#10;        )&#10;&#10;        // Auto-start timer for next player&#10;        startTimer()&#10;    }&#10;&#10;    fun undoLastAction() {&#10;        undoHistory?.let { previousState -&gt;&#10;            gameState = previousState&#10;            undoHistory = null&#10;            if (gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun pauseResumeGame() {&#10;        if (gameState.isGameRunning) {&#10;            gameState = gameState.copy(isPaused = !gameState.isPaused)&#10;            if (gameState.isPaused) {&#10;                timerJob?.cancel()&#10;            } else {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun endGame() {&#10;        timerJob?.cancel()&#10;        gameState = gameState.copy(isGameRunning = false, isPaused = false)&#10;        showStats = true&#10;    }&#10;&#10;    private fun startTimer() {&#10;        timerJob?.cancel()&#10;        timerJob = viewModelScope.launch {&#10;            var lastUpdateTime = System.currentTimeMillis()&#10;            var lastSecond = gameState.timeRemainingSeconds&#10;&#10;            while (gameState.timeRemainingMillis &gt; 0 &amp;&amp; gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                delay(16) // Update every 16ms for smooth animation (~60fps)&#10;&#10;                val currentTime = System.currentTimeMillis()&#10;                val deltaTime = currentTime - lastUpdateTime&#10;                lastUpdateTime = currentTime&#10;&#10;                val newTimeMillis = (gameState.timeRemainingMillis - deltaTime).coerceAtLeast(0L)&#10;                val newTimeSeconds = (newTimeMillis / 1000).toInt()&#10;&#10;                gameState = gameState.copy(&#10;                    timeRemainingMillis = newTimeMillis,&#10;                    timeRemainingSeconds = newTimeSeconds&#10;                )&#10;&#10;                // Handle audio alerts (only on second changes)&#10;                if (newTimeSeconds != lastSecond) {&#10;                    lastSecond = newTimeSeconds&#10;                    when (newTimeSeconds) {&#10;                        60 -&gt; if (gameConfiguration.audioAlert60s) playAlert()&#10;                        30 -&gt; if (gameConfiguration.audioAlert30s) playAlert()&#10;                        10, 9, 8, 7, 6, 5, 4, 3, 2, 1 -&gt; {&#10;                            if (gameConfiguration.audioAlert10sCountdown) {&#10;                                speakCountdown(newTimeSeconds)&#10;                            }&#10;                        }&#10;                        0 -&gt; {&#10;                            // Handle timeout with enhanced functionality&#10;                            handlePlayerTimeout()&#10;                            break&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handlePlayerTimeout() {&#10;        // Play timeout alert if enabled&#10;        if (gameConfiguration.audioAlertTimeOut) {&#10;            playAlert()&#10;        }&#10;        &#10;        // Announce timeout with text-to-speech if enabled&#10;        if (gameConfiguration.audioAlertTimeOut &amp;&amp; ttsReady) {&#10;            val playerName = gameConfiguration.getPlayerName(gameState.currentPlayerIndex)&#10;            textToSpeech?.speak(&quot;$playerName ran out of time!&quot;, TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;        &#10;        // Pause the game and show timeout dialog&#10;        gameState = gameState.copy(&#10;            isPaused = true,&#10;            showTimeExpiredDialog = true&#10;        )&#10;    }&#10;&#10;    fun dismissTimeExpiredDialog() {&#10;        gameState = gameState.copy(showTimeExpiredDialog = false)&#10;    }&#10;&#10;    fun continueAfterTimeout() {&#10;        // Reset timer to full duration and resume game&#10;        gameState = gameState.copy(&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            isPaused = false,&#10;            showTimeExpiredDialog = false&#10;        )&#10;        startTimer()&#10;    }&#10;&#10;    private fun playAlert() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_CDMA_ALERT_CALL_GUARD, 200)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun playTurnPassBeep() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_PROP_BEEP, 150)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun speakCountdown(seconds: Int) {&#10;        if (ttsReady) {&#10;            textToSpeech?.speak(seconds.toString(), TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    fun updateConfiguration(newConfig: GameConfiguration) {&#10;        gameConfiguration = newConfig&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(newConfig.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = newConfig.turnDurationSeconds,&#10;                timeRemainingMillis = newConfig.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun saveConfiguration(name: String) {&#10;        if (name.isBlank()) return&#10;&#10;        val newConfig = SavedConfiguration(name, gameConfiguration)&#10;        val updatedConfigs = savedConfigurations.toMutableList()&#10;&#10;        // Remove existing config with same name&#10;        updatedConfigs.removeAll { it.name == name }&#10;        updatedConfigs.add(newConfig)&#10;&#10;        savedConfigurations = updatedConfigs&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    fun loadConfiguration(savedConfig: SavedConfiguration) {&#10;        gameConfiguration = savedConfig.configuration&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;                timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun deleteConfiguration(configName: String) {&#10;        savedConfigurations = savedConfigurations.filter { it.name != configName }&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    private fun loadSavedConfigurations() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = prefs.getString(&quot;saved_configurations&quot;, &quot;[]&quot;)&#10;            val type = object : TypeToken&lt;List&lt;SavedConfiguration&gt;&gt;() {}.type&#10;            try {&#10;                savedConfigurations = gson.fromJson(json, type) ?: emptyList()&#10;            } catch (e: Exception) {&#10;                savedConfigurations = emptyList()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveToPersistentStorage() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = gson.toJson(savedConfigurations)&#10;            prefs.edit().putString(&quot;saved_configurations&quot;, json).apply()&#10;        }&#10;    }&#10;&#10;    fun showOptions() {&#10;        showOptions = true&#10;    }&#10;&#10;    fun hideOptions() {&#10;        showOptions = false&#10;    }&#10;&#10;    fun hideStats() {&#10;        showStats = false&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        toneGenerator?.release()&#10;        textToSpeech?.shutdown()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>