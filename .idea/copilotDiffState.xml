<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/ui/components/DiceComponents.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/ui/components/DiceComponents.kt" />
              <option name="originalContent" value="package com.example.boardgametimer.ui.components&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.*&#10;import androidx.compose.ui.graphics.drawscope.DrawScope&#10;import androidx.compose.ui.graphics.drawscope.Stroke&#10;import androidx.compose.ui.graphics.drawscope.rotate&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.example.boardgametimer.model.DiceType&#10;import com.example.boardgametimer.model.DiceResult&#10;import kotlin.math.*&#10;&#10;@Composable&#10;fun DiceDisplay(&#10;    diceType: DiceType,&#10;    diceCount: Int,&#10;    diceResult: DiceResult?,&#10;    isAnimating: Boolean,&#10;    circleSize: Dp,&#10;    onDiceClick: () -&gt; Unit,&#10;    onNextPhase: () -&gt; Unit = {},&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Box(&#10;        modifier = modifier&#10;            .size(circleSize * 0.6f)&#10;            .clip(CircleShape)&#10;            .clickable {&#10;                if (diceResult != null &amp;&amp; !isAnimating) {&#10;                    // After dice are thrown, clicking should move to next phase&#10;                    onNextPhase()&#10;                } else {&#10;                    // Before throwing, clicking should throw dice&#10;                    onDiceClick()&#10;                }&#10;            },&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        if (diceResult != null) {&#10;            if (diceCount == 1) {&#10;                // Single die - show large die with polygon and number&#10;                SingleDiceDisplay(&#10;                    diceType = diceType,&#10;                    value = diceResult.values.first(),&#10;                    isAnimating = isAnimating,&#10;                    size = circleSize * 0.5f&#10;                )&#10;            } else {&#10;                // Multiple dice - show individual results with sum below&#10;                MultipleDiceDisplay(&#10;                    diceType = diceType,&#10;                    diceResult = diceResult,&#10;                    isAnimating = isAnimating,&#10;                    circleSize = circleSize&#10;                )&#10;            }&#10;        } else {&#10;            // Waiting to throw - show instruction&#10;            WaitingToThrowDisplay(diceType, diceCount, circleSize)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SingleDiceDisplay(&#10;    diceType: DiceType,&#10;    value: Int,&#10;    isAnimating: Boolean,&#10;    size: Dp&#10;) {&#10;    // Draw the polygon shape for the die with the number inside&#10;    DicePolygon(&#10;        diceType = diceType,&#10;        size = size,&#10;        isAnimating = isAnimating,&#10;        value = value&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun MultipleDiceDisplay(&#10;    diceType: DiceType,&#10;    diceResult: DiceResult,&#10;    isAnimating: Boolean,&#10;    circleSize: Dp&#10;) {&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        // Show individual dice results in a grid-like layout&#10;        val diceSize = (circleSize.value / (diceResult.values.size + 1)).dp.coerceAtMost(40.dp)&#10;&#10;        if (diceResult.values.size &lt;= 5) {&#10;            // Single row for 5 or fewer dice&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(4.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                diceResult.values.forEach { value -&gt;&#10;                    IndividualDie(&#10;                        diceType = diceType,&#10;                        value = value,&#10;                        size = diceSize,&#10;                        isAnimating = isAnimating&#10;                    )&#10;                }&#10;            }&#10;        } else {&#10;            // Two rows for more than 5 dice&#10;            val firstRowCount = ceil(diceResult.values.size / 2.0).toInt()&#10;&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(4.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                diceResult.values.take(firstRowCount).forEach { value -&gt;&#10;                    IndividualDie(&#10;                        diceType = diceType,&#10;                        value = value,&#10;                        size = diceSize,&#10;                        isAnimating = isAnimating&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(4.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                diceResult.values.drop(firstRowCount).forEach { value -&gt;&#10;                    IndividualDie(&#10;                        diceType = diceType,&#10;                        value = value,&#10;                        size = diceSize,&#10;                        isAnimating = isAnimating&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        // Show total sum&#10;        Text(&#10;            text = &quot;Total: ${diceResult.total}&quot;,&#10;            fontSize = (circleSize.value / 12).sp,&#10;            fontWeight = FontWeight.Bold,&#10;            textAlign = TextAlign.Center,&#10;            color = MaterialTheme.colorScheme.primary&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun IndividualDie(&#10;    diceType: DiceType,&#10;    value: Int,&#10;    size: Dp,&#10;    isAnimating: Boolean&#10;) {&#10;    // Draw the polygon shape for the die with the number inside&#10;    DicePolygon(&#10;        diceType = diceType,&#10;        size = size,&#10;        isAnimating = isAnimating,&#10;        value = value&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun WaitingToThrowDisplay(&#10;    diceType: DiceType,&#10;    diceCount: Int,&#10;    circleSize: Dp&#10;) {&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        Text(&#10;            text = &quot;${diceCount}${diceType.displayName}&quot;,&#10;            fontSize = (circleSize.value / 10).sp,&#10;            fontWeight = FontWeight.Bold,&#10;            textAlign = TextAlign.Center,&#10;            color = MaterialTheme.colorScheme.primary&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(4.dp))&#10;&#10;        Text(&#10;            text = &quot;Tap to throw&quot;,&#10;            fontSize = (circleSize.value / 14).sp,&#10;            fontWeight = FontWeight.Medium,&#10;            textAlign = TextAlign.Center,&#10;            color = MaterialTheme.colorScheme.onSurface&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        // Show a preview of the die shape&#10;        DicePolygon(&#10;            diceType = diceType,&#10;            size = circleSize * 0.25f,&#10;            isAnimating = false&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun DicePolygon(&#10;    diceType: DiceType,&#10;    size: Dp,&#10;    isAnimating: Boolean,&#10;    value: Int? = null // Optional value for dice display&#10;) {&#10;    // Synchronize rotation changes with value changes&#10;    val animationRotation = if (isAnimating &amp;&amp; value != null) {&#10;        // Create a rotation that changes when the value changes&#10;        var currentRotation by remember { mutableStateOf(0f) }&#10;        LaunchedEffect(value) {&#10;            // When value changes, pick a new random rotation&#10;            currentRotation = (0..7).random() * 45f&#10;        }&#10;        currentRotation&#10;    } else {&#10;        0f&#10;    }&#10;&#10;    Box(&#10;        modifier = Modifier.size(size),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        // Draw the polygon shape&#10;        Canvas(&#10;            modifier = Modifier.size(size)&#10;        ) {&#10;            val center = Offset(size.toPx() / 2, size.toPx() / 2)&#10;            val radius = size.toPx() / 2 * 0.8f&#10;&#10;            rotate(animationRotation, center) {&#10;                when (diceType) {&#10;                    DiceType.D2 -&gt; drawCircle(center, radius)&#10;                    DiceType.D4 -&gt; drawTriangle(center, radius)&#10;                    DiceType.D6 -&gt; drawSquare(center, radius)&#10;                    DiceType.D8 -&gt; drawOctagon(center, radius)&#10;                    DiceType.D10 -&gt; drawDecagon(center, radius)&#10;                    DiceType.D20 -&gt; drawIcosagon(center, radius)&#10;                    DiceType.D100 -&gt; drawDecagon(center, radius) // Use decagon for d100&#10;                }&#10;            }&#10;        }&#10;&#10;        // Draw the value as a Text component overlayed on top&#10;        if (value != null) {&#10;            Text(&#10;                text = value.toString(),&#10;                fontSize = (size.value / 3.5f).sp,&#10;                fontWeight = FontWeight.Bold,&#10;                color = Color.White,&#10;                textAlign = TextAlign.Center,&#10;                modifier = Modifier&#10;                    .align(Alignment.Center)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;private fun DrawScope.drawCircle(center: Offset, radius: Float) {&#10;    drawCircle(&#10;        color = Color.Blue,&#10;        radius = radius,&#10;        center = center,&#10;        style = Stroke(width = 3.dp.toPx())&#10;    )&#10;}&#10;&#10;private fun DrawScope.drawTriangle(center: Offset, radius: Float) {&#10;    val path = Path().apply {&#10;        val angle = 2 * PI / 3&#10;        for (i in 0..2) {&#10;            val x = center.x + radius * cos(angle * i - PI / 2).toFloat()&#10;            val y = center.y + radius * sin(angle * i - PI / 2).toFloat()&#10;            if (i == 0) moveTo(x, y) else lineTo(x, y)&#10;        }&#10;        close()&#10;    }&#10;    drawPath(&#10;        path = path,&#10;        color = Color.Green,&#10;        style = Stroke(width = 3.dp.toPx())&#10;    )&#10;}&#10;&#10;private fun DrawScope.drawSquare(center: Offset, radius: Float) {&#10;    val side = radius * sqrt(2f)&#10;    drawRect(&#10;        color = Color.Red,&#10;        topLeft = Offset(center.x - side / 2, center.y - side / 2),&#10;        size = Size(side, side),&#10;        style = Stroke(width = 3.dp.toPx())&#10;    )&#10;}&#10;&#10;private fun DrawScope.drawPolygon(center: Offset, radius: Float, sides: Int, color: Color) {&#10;    val path = Path().apply {&#10;        val angle = 2 * PI / sides&#10;        for (i in 0 until sides) {&#10;            val x = center.x + radius * cos(angle * i - PI / 2).toFloat()&#10;            val y = center.y + radius * sin(angle * i - PI / 2).toFloat()&#10;            if (i == 0) moveTo(x, y) else lineTo(x, y)&#10;        }&#10;        close()&#10;    }&#10;    drawPath(&#10;        path = path,&#10;        color = color,&#10;        style = Stroke(width = 3.dp.toPx())&#10;    )&#10;}&#10;&#10;private fun DrawScope.drawOctagon(center: Offset, radius: Float) {&#10;    drawPolygon(center, radius, 8, Color.Magenta)&#10;}&#10;&#10;private fun DrawScope.drawDecagon(center: Offset, radius: Float) {&#10;    drawPolygon(center, radius, 10, Color.Cyan)&#10;}&#10;&#10;private fun DrawScope.drawIcosagon(center: Offset, radius: Float) {&#10;    drawPolygon(center, radius, 20, Color.Yellow)&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.boardgametimer.ui.components&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.*&#10;import androidx.compose.ui.graphics.drawscope.DrawScope&#10;import androidx.compose.ui.graphics.drawscope.Stroke&#10;import androidx.compose.ui.graphics.drawscope.rotate&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.example.boardgametimer.model.DiceType&#10;import com.example.boardgametimer.model.DiceResult&#10;import kotlin.math.*&#10;&#10;@Composable&#10;fun DiceDisplay(&#10;    diceType: DiceType,&#10;    diceCount: Int,&#10;    diceResult: DiceResult?,&#10;    isAnimating: Boolean,&#10;    circleSize: Dp,&#10;    onDiceClick: () -&gt; Unit,&#10;    onNextPhase: () -&gt; Unit = {},&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Box(&#10;        modifier = modifier&#10;            .size(circleSize * 0.6f)&#10;            .clip(CircleShape)&#10;            .clickable {&#10;                if (diceResult != null &amp;&amp; !isAnimating) {&#10;                    // After dice are thrown, clicking should move to next phase&#10;                    onNextPhase()&#10;                } else {&#10;                    // Before throwing, clicking should throw dice&#10;                    onDiceClick()&#10;                }&#10;            },&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        if (diceResult != null) {&#10;            if (diceCount == 1) {&#10;                // Single die - show large die with polygon and number&#10;                SingleDiceDisplay(&#10;                    diceType = diceType,&#10;                    value = diceResult.values.first(),&#10;                    isAnimating = isAnimating,&#10;                    size = circleSize * 0.5f&#10;                )&#10;            } else {&#10;                // Multiple dice - show individual results with sum below&#10;                MultipleDiceDisplay(&#10;                    diceType = diceType,&#10;                    diceResult = diceResult,&#10;                    isAnimating = isAnimating,&#10;                    circleSize = circleSize&#10;                )&#10;            }&#10;        } else {&#10;            // Waiting to throw - show instruction&#10;            WaitingToThrowDisplay(diceType, diceCount, circleSize)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SingleDiceDisplay(&#10;    diceType: DiceType,&#10;    value: Int,&#10;    isAnimating: Boolean,&#10;    size: Dp&#10;) {&#10;    // Draw the polygon shape for the die with the number inside&#10;    DicePolygon(&#10;        diceType = diceType,&#10;        size = size,&#10;        isAnimating = isAnimating,&#10;        value = value&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun MultipleDiceDisplay(&#10;    diceType: DiceType,&#10;    diceResult: DiceResult,&#10;    isAnimating: Boolean,&#10;    circleSize: Dp&#10;) {&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        // Calculate dice size based on actual available space&#10;        // The DiceDisplay container uses circleSize * 0.6f, so we need to work within that&#10;        val containerSize = circleSize * 0.6f&#10;        val availableWidth = containerSize * 0.95f // Use 95% of container width for better space utilization&#10;        val spacing = 3.dp // Reduced spacing to allow for larger dice&#10;        val diceCount = diceResult.values.size&#10;&#10;        val diceSize = if (diceCount &lt;= 5) {&#10;            // Single row - calculate size based on available width&#10;            val totalSpacing = spacing * (diceCount - 1)&#10;            val availableForDice = availableWidth - totalSpacing&#10;            val calculatedSize = (availableForDice.value / diceCount).dp&#10;            &#10;            // Use more generous size limits for better space utilization&#10;            when (diceCount) {&#10;                1 -&gt; calculatedSize.coerceAtMost(120.dp).coerceAtLeast(60.dp)&#10;                2 -&gt; calculatedSize.coerceAtMost(100.dp).coerceAtLeast(50.dp)&#10;                3 -&gt; calculatedSize.coerceAtMost(80.dp).coerceAtLeast(40.dp)&#10;                4 -&gt; calculatedSize.coerceAtMost(70.dp).coerceAtLeast(35.dp)&#10;                5 -&gt; calculatedSize.coerceAtMost(60.dp).coerceAtLeast(30.dp)&#10;                else -&gt; calculatedSize.coerceAtMost(50.dp).coerceAtLeast(25.dp)&#10;            }&#10;        } else {&#10;            // Two rows - calculate based on the larger row&#10;            val firstRowCount = ceil(diceCount / 2.0).toInt()&#10;            val totalSpacing = spacing * (firstRowCount - 1)&#10;            val availableForDice = availableWidth - totalSpacing&#10;            (availableForDice.value / firstRowCount).dp.coerceAtMost(50.dp).coerceAtLeast(20.dp)&#10;        }&#10;&#10;        if (diceResult.values.size &lt;= 5) {&#10;            // Single row for 5 or fewer dice&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(4.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                diceResult.values.forEach { value -&gt;&#10;                    IndividualDie(&#10;                        diceType = diceType,&#10;                        value = value,&#10;                        size = diceSize,&#10;                        isAnimating = isAnimating&#10;                    )&#10;                }&#10;            }&#10;        } else {&#10;            // Two rows for more than 5 dice&#10;            val firstRowCount = ceil(diceResult.values.size / 2.0).toInt()&#10;&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(4.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                diceResult.values.take(firstRowCount).forEach { value -&gt;&#10;                    IndividualDie(&#10;                        diceType = diceType,&#10;                        value = value,&#10;                        size = diceSize,&#10;                        isAnimating = isAnimating&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(4.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                diceResult.values.drop(firstRowCount).forEach { value -&gt;&#10;                    IndividualDie(&#10;                        diceType = diceType,&#10;                        value = value,&#10;                        size = diceSize,&#10;                        isAnimating = isAnimating&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        // Show total sum&#10;        Text(&#10;            text = &quot;Total: ${diceResult.total}&quot;,&#10;            fontSize = (circleSize.value / 12).sp,&#10;            fontWeight = FontWeight.Bold,&#10;            textAlign = TextAlign.Center,&#10;            color = MaterialTheme.colorScheme.primary&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun IndividualDie(&#10;    diceType: DiceType,&#10;    value: Int,&#10;    size: Dp,&#10;    isAnimating: Boolean&#10;) {&#10;    // Draw the polygon shape for the die with the number inside&#10;    DicePolygon(&#10;        diceType = diceType,&#10;        size = size,&#10;        isAnimating = isAnimating,&#10;        value = value&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun WaitingToThrowDisplay(&#10;    diceType: DiceType,&#10;    diceCount: Int,&#10;    circleSize: Dp&#10;) {&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        Text(&#10;            text = &quot;${diceCount}${diceType.displayName}&quot;,&#10;            fontSize = (circleSize.value / 10).sp,&#10;            fontWeight = FontWeight.Bold,&#10;            textAlign = TextAlign.Center,&#10;            color = MaterialTheme.colorScheme.primary&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(4.dp))&#10;&#10;        Text(&#10;            text = &quot;Tap to throw&quot;,&#10;            fontSize = (circleSize.value / 14).sp,&#10;            fontWeight = FontWeight.Medium,&#10;            textAlign = TextAlign.Center,&#10;            color = MaterialTheme.colorScheme.onSurface&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        // Show a preview of the die shape&#10;        DicePolygon(&#10;            diceType = diceType,&#10;            size = circleSize * 0.25f,&#10;            isAnimating = false&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun DicePolygon(&#10;    diceType: DiceType,&#10;    size: Dp,&#10;    isAnimating: Boolean,&#10;    value: Int? = null // Optional value for dice display&#10;) {&#10;    // Synchronize rotation changes with value changes&#10;    val animationRotation = if (isAnimating &amp;&amp; value != null) {&#10;        // Create a rotation that changes when the value changes&#10;        var currentRotation by remember { mutableStateOf(0f) }&#10;        LaunchedEffect(value) {&#10;            // When value changes, pick a new random rotation with more possibilities&#10;            // Use 72 different orientations (every 5 degrees) to ensure visible changes&#10;            currentRotation = (0..71).random() * 5f&#10;        }&#10;        currentRotation&#10;    } else {&#10;        0f&#10;    }&#10;&#10;    Box(&#10;        modifier = Modifier.size(size),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        // Draw the polygon shape&#10;        Canvas(&#10;            modifier = Modifier.size(size)&#10;        ) {&#10;            val center = Offset(size.toPx() / 2, size.toPx() / 2)&#10;            val radius = size.toPx() / 2 * 0.8f&#10;&#10;            rotate(animationRotation, center) {&#10;                when (diceType) {&#10;                    DiceType.D2 -&gt; drawCircle(center, radius)&#10;                    DiceType.D4 -&gt; drawTriangle(center, radius)&#10;                    DiceType.D6 -&gt; drawSquare(center, radius)&#10;                    DiceType.D8 -&gt; drawOctagon(center, radius)&#10;                    DiceType.D10 -&gt; drawDecagon(center, radius)&#10;                    DiceType.D20 -&gt; drawIcosagon(center, radius)&#10;                    DiceType.D100 -&gt; drawDecagon(center, radius) // Use decagon for d100&#10;                }&#10;            }&#10;        }&#10;&#10;        // Draw the value as a Text component overlayed on top&#10;        if (value != null) {&#10;            Text(&#10;                text = value.toString(),&#10;                fontSize = (size.value / 3.5f).sp,&#10;                fontWeight = FontWeight.Bold,&#10;                color = Color.White,&#10;                textAlign = TextAlign.Center,&#10;                modifier = Modifier&#10;                    .align(Alignment.Center)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;private fun DrawScope.drawCircle(center: Offset, radius: Float) {&#10;    drawCircle(&#10;        color = Color.Blue,&#10;        radius = radius,&#10;        center = center,&#10;        style = Stroke(width = 3.dp.toPx())&#10;    )&#10;}&#10;&#10;private fun DrawScope.drawTriangle(center: Offset, radius: Float) {&#10;    val path = Path().apply {&#10;        val angle = 2 * PI / 3&#10;        for (i in 0..2) {&#10;            val x = center.x + radius * cos(angle * i - PI / 2).toFloat()&#10;            val y = center.y + radius * sin(angle * i - PI / 2).toFloat()&#10;            if (i == 0) moveTo(x, y) else lineTo(x, y)&#10;        }&#10;        close()&#10;    }&#10;    drawPath(&#10;        path = path,&#10;        color = Color.Green,&#10;        style = Stroke(width = 3.dp.toPx())&#10;    )&#10;}&#10;&#10;private fun DrawScope.drawSquare(center: Offset, radius: Float) {&#10;    val side = radius * sqrt(2f)&#10;    drawRect(&#10;        color = Color.Red,&#10;        topLeft = Offset(center.x - side / 2, center.y - side / 2),&#10;        size = Size(side, side),&#10;        style = Stroke(width = 3.dp.toPx())&#10;    )&#10;}&#10;&#10;private fun DrawScope.drawPolygon(center: Offset, radius: Float, sides: Int, color: Color) {&#10;    val path = Path().apply {&#10;        val angle = 2 * PI / sides&#10;        for (i in 0 until sides) {&#10;            val x = center.x + radius * cos(angle * i - PI / 2).toFloat()&#10;            val y = center.y + radius * sin(angle * i - PI / 2).toFloat()&#10;            if (i == 0) moveTo(x, y) else lineTo(x, y)&#10;        }&#10;        close()&#10;    }&#10;    drawPath(&#10;        path = path,&#10;        color = color,&#10;        style = Stroke(width = 3.dp.toPx())&#10;    )&#10;}&#10;&#10;private fun DrawScope.drawOctagon(center: Offset, radius: Float) {&#10;    drawPolygon(center, radius, 8, Color.Magenta)&#10;}&#10;&#10;private fun DrawScope.drawDecagon(center: Offset, radius: Float) {&#10;    drawPolygon(center, radius, 10, Color.Cyan)&#10;}&#10;&#10;private fun DrawScope.drawIcosagon(center: Offset, radius: Float) {&#10;    drawPolygon(center, radius, 20, Color.Yellow)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModel.kt" />
              <option name="originalContent" value="package com.example.boardgametimer.viewmodel&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.media.AudioManager&#10;import android.media.ToneGenerator&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.speech.tts.TextToSpeech&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.GameState&#10;import com.example.boardgametimer.model.SavedConfiguration&#10;import com.example.boardgametimer.model.DicePhaseState&#10;import com.example.boardgametimer.model.PhaseType&#10;import com.example.boardgametimer.model.TurnPhase&#10;import com.example.boardgametimer.model.DiceResult&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.util.Locale&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;&#10;class GameTimerViewModel : ViewModel() {&#10;&#10;    var gameState by mutableStateOf(GameState())&#10;        private set&#10;&#10;    var gameConfiguration by mutableStateOf(GameConfiguration())&#10;        private set&#10;&#10;    var showOptions by mutableStateOf(false)&#10;        private set&#10;&#10;    var showStats by mutableStateOf(false)&#10;        private set&#10;&#10;    var undoHistory by mutableStateOf&lt;GameState?&gt;(null)&#10;        private set&#10;&#10;    var savedConfigurations by mutableStateOf&lt;List&lt;SavedConfiguration&gt;&gt;(emptyList())&#10;        private set&#10;&#10;    private var timerJob: Job? = null&#10;    private var toneGenerator: ToneGenerator? = null&#10;    private var vibrator: Vibrator? = null&#10;    private var textToSpeech: TextToSpeech? = null&#10;    private var ttsReady = false&#10;    private var sharedPreferences: SharedPreferences? = null&#10;    private val gson = Gson()&#10;&#10;    fun initializeAudio(context: Context) {&#10;        toneGenerator = ToneGenerator(AudioManager.STREAM_NOTIFICATION, 100)&#10;&#10;        // Use modern vibrator API&#10;        vibrator = if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.S) {&#10;            val vibratorManager = context.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            vibratorManager.defaultVibrator&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;&#10;        textToSpeech = TextToSpeech(context) { status -&gt;&#10;            if (status == TextToSpeech.SUCCESS) {&#10;                textToSpeech?.language = Locale.getDefault()&#10;                ttsReady = true&#10;            }&#10;        }&#10;&#10;        // Initialize SharedPreferences for saving configurations&#10;        sharedPreferences = context.getSharedPreferences(&quot;BoardGameTimer&quot;, Context.MODE_PRIVATE)&#10;        loadSavedConfigurations()&#10;    }&#10;&#10;    fun startNewGame() {&#10;        val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;        val firstPhaseDuration = gameConfiguration.getCurrentPhaseDuration(0)&#10;        gameState = GameState(&#10;            currentPlayerIndex = 0,&#10;            currentPhaseIndex = 0, // Start with first phase&#10;            timeRemainingSeconds = firstPhaseDuration,&#10;            timeRemainingMillis = firstPhaseDuration * 1000L,&#10;            isGameRunning = true,&#10;            isPaused = false, // Start ready to play, not paused&#10;            roundCount = 0,&#10;            playerTurnTimes = playerTurnTimes,&#10;            gameStartTime = System.currentTimeMillis(),&#10;            turnStartTime = System.currentTimeMillis()&#10;        )&#10;        startTimer() // Auto-start the timer for the first player&#10;    }&#10;&#10;    fun nextPlayer() {&#10;        if (!gameState.isGameRunning) return&#10;&#10;        // Check if we need to advance to next phase or next player&#10;        val nextPhaseIndex = gameState.currentPhaseIndex + 1&#10;        val totalPhases = gameConfiguration.getTotalPhases()&#10;&#10;        if (nextPhaseIndex &lt; totalPhases) {&#10;            // Move to next phase for same player&#10;            nextPhase()&#10;        } else {&#10;            // Move to next player (reset to first phase)&#10;            moveToNextPlayer()&#10;        }&#10;    }&#10;&#10;    private fun nextPhase() {&#10;        // Play a beep sound when passing to next phase&#10;        playTurnPassBeep()&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        val nextPhaseIndex = gameState.currentPhaseIndex + 1&#10;        val phaseDuration = gameConfiguration.getCurrentPhaseDuration(nextPhaseIndex)&#10;        val nextPhase = gameConfiguration.turnPhases[nextPhaseIndex]&#10;&#10;        gameState = gameState.copy(&#10;            currentPhaseIndex = nextPhaseIndex,&#10;            timeRemainingSeconds = phaseDuration,&#10;            timeRemainingMillis = phaseDuration * 1000L,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = false,&#10;            // Reset dice state for new phase&#10;            dicePhaseState = DicePhaseState.WAITING_TO_THROW,&#10;            diceResult = null,&#10;            isDiceAnimating = false&#10;        )&#10;&#10;        // Auto-start timer for next phase (unless it's a dice phase waiting for throw)&#10;        if (nextPhase.phaseType != PhaseType.DICE_THROW || !shouldWaitForDiceThrow()) {&#10;            startTimer()&#10;        }&#10;    }&#10;&#10;    private fun moveToNextPlayer() {&#10;        // Play a beep sound when passing turn&#10;        playTurnPassBeep()&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        // Record the time taken for current player's turn (only record when completing all phases)&#10;        val timeTaken = gameConfiguration.getCurrentPhaseDuration(gameState.currentPhaseIndex) - gameState.timeRemainingSeconds&#10;        val currentPlayerTimes = gameState.playerTurnTimes[gameState.currentPlayerIndex].toMutableList()&#10;        currentPlayerTimes.add(timeTaken)&#10;&#10;        val updatedPlayerTurnTimes = gameState.playerTurnTimes.toMutableList()&#10;        updatedPlayerTurnTimes[gameState.currentPlayerIndex] = currentPlayerTimes&#10;&#10;        val nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameConfiguration.numberOfPlayers&#10;        val newRoundCount = if (nextPlayerIndex == 0) gameState.roundCount + 1 else gameState.roundCount&#10;        val firstPhaseDuration = gameConfiguration.getCurrentPhaseDuration(0)&#10;        val firstPhase = gameConfiguration.turnPhases[0]&#10;&#10;        gameState = gameState.copy(&#10;            currentPlayerIndex = nextPlayerIndex,&#10;            currentPhaseIndex = 0, // Reset to first phase for new player&#10;            timeRemainingSeconds = firstPhaseDuration,&#10;            timeRemainingMillis = firstPhaseDuration * 1000L,&#10;            playerTurnTimes = updatedPlayerTurnTimes,&#10;            roundCount = newRoundCount,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = false,&#10;            // Reset dice state for new player&#10;            dicePhaseState = DicePhaseState.WAITING_TO_THROW,&#10;            diceResult = null,&#10;            isDiceAnimating = false&#10;        )&#10;&#10;        // Auto-start timer for next player (unless first phase is a dice phase waiting for throw)&#10;        if (firstPhase.phaseType != PhaseType.DICE_THROW || !shouldWaitForDiceThrow()) {&#10;            startTimer()&#10;        }&#10;    }&#10;&#10;    fun undoLastAction() {&#10;        undoHistory?.let { previousState -&gt;&#10;            gameState = previousState&#10;            undoHistory = null&#10;            if (gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun pauseResumeGame() {&#10;        if (gameState.isGameRunning) {&#10;            gameState = gameState.copy(isPaused = !gameState.isPaused)&#10;            if (gameState.isPaused) {&#10;                timerJob?.cancel()&#10;            } else {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun endGame() {&#10;        timerJob?.cancel()&#10;        gameState = gameState.copy(isGameRunning = false, isPaused = false)&#10;        showStats = true&#10;    }&#10;&#10;    private fun startTimer() {&#10;        timerJob?.cancel()&#10;        timerJob = viewModelScope.launch {&#10;            var lastUpdateTime = System.currentTimeMillis()&#10;            var lastSecond = gameState.timeRemainingSeconds&#10;&#10;            while (gameState.timeRemainingMillis &gt; 0 &amp;&amp; gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                delay(16) // Update every 16ms for smooth animation (~60fps)&#10;&#10;                val currentTime = System.currentTimeMillis()&#10;                val deltaTime = currentTime - lastUpdateTime&#10;                lastUpdateTime = currentTime&#10;&#10;                val newTimeMillis = (gameState.timeRemainingMillis - deltaTime).coerceAtLeast(0L)&#10;                val newTimeSeconds = (newTimeMillis / 1000).toInt()&#10;&#10;                gameState = gameState.copy(&#10;                    timeRemainingMillis = newTimeMillis,&#10;                    timeRemainingSeconds = newTimeSeconds&#10;                )&#10;&#10;                // Handle audio alerts (only on second changes)&#10;                if (newTimeSeconds != lastSecond) {&#10;                    lastSecond = newTimeSeconds&#10;                    when (newTimeSeconds) {&#10;                        60 -&gt; if (gameConfiguration.audioAlert60s) playAlert()&#10;                        30 -&gt; if (gameConfiguration.audioAlert30s) playAlert()&#10;                        10, 9, 8, 7, 6, 5, 4, 3, 2, 1 -&gt; {&#10;                            if (gameConfiguration.audioAlert10sCountdown) {&#10;                                speakCountdown(newTimeSeconds)&#10;                            }&#10;                        }&#10;                        0 -&gt; {&#10;                            // Handle timeout with enhanced functionality&#10;                            handlePlayerTimeout()&#10;                            break&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handlePlayerTimeout() {&#10;        // Play timeout alert if enabled&#10;        if (gameConfiguration.audioAlertTimeOut) {&#10;            playAlert()&#10;        }&#10;&#10;        // Announce timeout with text-to-speech if enabled&#10;        if (gameConfiguration.audioAlertTimeOut &amp;&amp; ttsReady) {&#10;            val playerName = gameConfiguration.getPlayerName(gameState.currentPlayerIndex)&#10;            textToSpeech?.speak(&quot;$playerName ran out of time!&quot;, TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;&#10;        // Pause the game and show timeout dialog&#10;        gameState = gameState.copy(&#10;            isPaused = true,&#10;            showTimeExpiredDialog = true&#10;        )&#10;    }&#10;&#10;    fun dismissTimeExpiredDialog() {&#10;        gameState = gameState.copy(showTimeExpiredDialog = false)&#10;    }&#10;&#10;    fun continueAfterTimeout() {&#10;        // Reset timer to full duration and resume game&#10;        gameState = gameState.copy(&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            isPaused = false,&#10;            showTimeExpiredDialog = false&#10;        )&#10;        startTimer()&#10;    }&#10;&#10;    private fun playAlert() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_CDMA_ALERT_CALL_GUARD, 200)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun playTurnPassBeep() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_PROP_BEEP, 150)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun speakCountdown(seconds: Int) {&#10;        if (ttsReady) {&#10;            textToSpeech?.speak(seconds.toString(), TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    fun updateConfiguration(newConfig: GameConfiguration) {&#10;        gameConfiguration = newConfig&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(newConfig.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = newConfig.turnDurationSeconds,&#10;                timeRemainingMillis = newConfig.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun saveConfiguration(name: String) {&#10;        if (name.isBlank()) return&#10;&#10;        val newConfig = SavedConfiguration(name, gameConfiguration)&#10;        val updatedConfigs = savedConfigurations.toMutableList()&#10;&#10;        // Remove existing config with same name&#10;        updatedConfigs.removeAll { it.name == name }&#10;        updatedConfigs.add(newConfig)&#10;&#10;        savedConfigurations = updatedConfigs&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    fun loadConfiguration(savedConfig: SavedConfiguration) {&#10;        gameConfiguration = savedConfig.configuration&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;                timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun deleteConfiguration(configName: String) {&#10;        savedConfigurations = savedConfigurations.filter { it.name != configName }&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    private fun loadSavedConfigurations() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = prefs.getString(&quot;saved_configurations&quot;, &quot;[]&quot;)&#10;            val type = object : TypeToken&lt;List&lt;SavedConfiguration&gt;&gt;() {}.type&#10;            try {&#10;                savedConfigurations = gson.fromJson(json, type) ?: emptyList()&#10;            } catch (e: Exception) {&#10;                savedConfigurations = emptyList()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveToPersistentStorage() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = gson.toJson(savedConfigurations)&#10;            prefs.edit().putString(&quot;saved_configurations&quot;, json).apply()&#10;        }&#10;    }&#10;&#10;    fun showOptions() {&#10;        showOptions = true&#10;    }&#10;&#10;    fun hideOptions() {&#10;        showOptions = false&#10;    }&#10;&#10;    fun hideStats() {&#10;        showStats = false&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        toneGenerator?.release()&#10;        textToSpeech?.shutdown()&#10;    }&#10;&#10;    fun throwDice() {&#10;        val currentPhase = gameConfiguration.turnPhases[gameState.currentPhaseIndex]&#10;        if (currentPhase.phaseType != PhaseType.DICE_THROW) return&#10;&#10;        // Prevent throwing dice if already thrown in this phase&#10;        if (gameState.dicePhaseState != DicePhaseState.WAITING_TO_THROW) return&#10;&#10;        // Start dice animation&#10;        gameState = gameState.copy(&#10;            isDiceAnimating = true,&#10;            dicePhaseState = DicePhaseState.THROWING&#10;        )&#10;&#10;        // Simulate dice animation with out-of-sync changes for multiple dice&#10;        viewModelScope.launch {&#10;            val animationDuration = 4000L // Increased from 3000L to make it slower&#10;            val startTime = System.currentTimeMillis()&#10;&#10;            // Store previous values and last change time for each die to track changes properly&#10;            var previousValues = (1..currentPhase.diceCount).map { 1 }&#10;            val lastChangeTime = mutableListOf&lt;Long&gt;()&#10;            repeat(currentPhase.diceCount) { lastChangeTime.add(0L) }&#10;&#10;            while (System.currentTimeMillis() - startTime &lt; animationDuration) {&#10;                val currentTime = System.currentTimeMillis() - startTime&#10;                val progress = currentTime.toFloat() / animationDuration.toFloat()&#10;&#10;                // Create deceleration curve - starts fast, gets slower&#10;                val decelerationFactor = 1.0f - (progress * progress) // Quadratic deceleration&#10;                val adjustedBaseInterval = (300L + (1200L * progress)).toLong() // 300ms to 1500ms (slower)&#10;&#10;                // Generate random dice values with proper change tracking for each die&#10;                val randomValues = (1..currentPhase.diceCount).map { dieIndex -&gt;&#10;                    // Convert 1-based dieIndex to 0-based array index&#10;                    val arrayIndex = dieIndex - 1&#10;&#10;                    // Each die changes at slightly different intervals to create out-of-sync effect&#10;                    val dieInterval = (adjustedBaseInterval + (arrayIndex * 200L * decelerationFactor)).toLong()&#10;&#10;                    // Check if enough time has passed since this die's last change&#10;                    if (currentTime - lastChangeTime[arrayIndex] &gt;= dieInterval) {&#10;                        // Time to change this die's value&#10;                        lastChangeTime[arrayIndex] = currentTime&#10;                        (1..currentPhase.diceType.sides).random()&#10;                    } else {&#10;                        // Keep previous value - not time to change yet&#10;                        previousValues.getOrNull(arrayIndex) ?: (1..currentPhase.diceType.sides).random()&#10;                    }&#10;                }&#10;&#10;                // Only update state if ANY dice values actually changed&#10;                if (randomValues != previousValues) {&#10;                    previousValues = randomValues&#10;                    gameState = gameState.copy(&#10;                        diceResult = DiceResult(randomValues, randomValues.sum())&#10;                    )&#10;                }&#10;&#10;                // Dynamic delay based on progress - gets longer as animation progresses&#10;                val dynamicDelay = (80L + (220L * progress)).toLong() // 80ms to 300ms (slower)&#10;                delay(dynamicDelay)&#10;            }&#10;&#10;            // Generate final result&#10;            val finalValues = (1..currentPhase.diceCount).map {&#10;                (1..currentPhase.diceType.sides).random()&#10;            }&#10;            gameState = gameState.copy(&#10;                isDiceAnimating = false,&#10;                diceResult = DiceResult(finalValues, finalValues.sum()),&#10;                dicePhaseState = DicePhaseState.SHOWING_RESULT&#10;            )&#10;&#10;            // Play dice sound effect&#10;            playDiceSound()&#10;&#10;            // Handle timer based on phase configuration&#10;            if (currentPhase.waitForPress) {&#10;                // If wait for press is enabled, just pause and wait for manual progression&#10;                gameState = gameState.copy(isPaused = true)&#10;            } else if (currentPhase.durationSeconds &gt; 0) {&#10;                // Start the timer with the configured duration&#10;                gameState = gameState.copy(&#10;                    timeRemainingSeconds = currentPhase.durationSeconds,&#10;                    timeRemainingMillis = currentPhase.durationSeconds * 1000L,&#10;                    isPaused = false&#10;                )&#10;                startTimer()&#10;            } else {&#10;                // Duration is 0, automatically proceed to next phase/player&#10;                delay(1000) // Show result for 1 second&#10;                nextPlayer()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun playDiceSound() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_PROP_BEEP, 200)&#10;    }&#10;&#10;    fun getCurrentPhase(): TurnPhase {&#10;        return gameConfiguration.turnPhases[gameState.currentPhaseIndex]&#10;    }&#10;&#10;    fun isDicePhase(): Boolean {&#10;        return getCurrentPhase().phaseType == PhaseType.DICE_THROW&#10;    }&#10;&#10;    fun shouldWaitForDiceThrow(): Boolean {&#10;        val currentPhase = getCurrentPhase()&#10;        return currentPhase.phaseType == PhaseType.DICE_THROW &amp;&amp;&#10;               gameState.dicePhaseState == DicePhaseState.WAITING_TO_THROW&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.boardgametimer.viewmodel&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.media.AudioManager&#10;import android.media.ToneGenerator&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.speech.tts.TextToSpeech&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.GameState&#10;import com.example.boardgametimer.model.SavedConfiguration&#10;import com.example.boardgametimer.model.DicePhaseState&#10;import com.example.boardgametimer.model.PhaseType&#10;import com.example.boardgametimer.model.TurnPhase&#10;import com.example.boardgametimer.model.DiceResult&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.util.Locale&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;&#10;class GameTimerViewModel : ViewModel() {&#10;&#10;    var gameState by mutableStateOf(GameState())&#10;        private set&#10;&#10;    var gameConfiguration by mutableStateOf(GameConfiguration())&#10;        private set&#10;&#10;    var showOptions by mutableStateOf(false)&#10;        private set&#10;&#10;    var showStats by mutableStateOf(false)&#10;        private set&#10;&#10;    var undoHistory by mutableStateOf&lt;GameState?&gt;(null)&#10;        private set&#10;&#10;    var savedConfigurations by mutableStateOf&lt;List&lt;SavedConfiguration&gt;&gt;(emptyList())&#10;        private set&#10;&#10;    private var timerJob: Job? = null&#10;    private var toneGenerator: ToneGenerator? = null&#10;    private var vibrator: Vibrator? = null&#10;    private var textToSpeech: TextToSpeech? = null&#10;    private var ttsReady = false&#10;    private var sharedPreferences: SharedPreferences? = null&#10;    private val gson = Gson()&#10;&#10;    fun initializeAudio(context: Context) {&#10;        toneGenerator = ToneGenerator(AudioManager.STREAM_NOTIFICATION, 100)&#10;&#10;        // Use modern vibrator API&#10;        vibrator = if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.S) {&#10;            val vibratorManager = context.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            vibratorManager.defaultVibrator&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;&#10;        textToSpeech = TextToSpeech(context) { status -&gt;&#10;            if (status == TextToSpeech.SUCCESS) {&#10;                textToSpeech?.language = Locale.getDefault()&#10;                ttsReady = true&#10;            }&#10;        }&#10;&#10;        // Initialize SharedPreferences for saving configurations&#10;        sharedPreferences = context.getSharedPreferences(&quot;BoardGameTimer&quot;, Context.MODE_PRIVATE)&#10;        loadSavedConfigurations()&#10;    }&#10;&#10;    fun startNewGame() {&#10;        val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;        val firstPhaseDuration = gameConfiguration.getCurrentPhaseDuration(0)&#10;        gameState = GameState(&#10;            currentPlayerIndex = 0,&#10;            currentPhaseIndex = 0, // Start with first phase&#10;            timeRemainingSeconds = firstPhaseDuration,&#10;            timeRemainingMillis = firstPhaseDuration * 1000L,&#10;            isGameRunning = true,&#10;            isPaused = false, // Start ready to play, not paused&#10;            roundCount = 0,&#10;            playerTurnTimes = playerTurnTimes,&#10;            gameStartTime = System.currentTimeMillis(),&#10;            turnStartTime = System.currentTimeMillis()&#10;        )&#10;        startTimer() // Auto-start the timer for the first player&#10;    }&#10;&#10;    fun nextPlayer() {&#10;        if (!gameState.isGameRunning) return&#10;&#10;        // Check if we need to advance to next phase or next player&#10;        val nextPhaseIndex = gameState.currentPhaseIndex + 1&#10;        val totalPhases = gameConfiguration.getTotalPhases()&#10;&#10;        if (nextPhaseIndex &lt; totalPhases) {&#10;            // Move to next phase for same player&#10;            nextPhase()&#10;        } else {&#10;            // Move to next player (reset to first phase)&#10;            moveToNextPlayer()&#10;        }&#10;    }&#10;&#10;    private fun nextPhase() {&#10;        // Play a beep sound when passing to next phase&#10;        playTurnPassBeep()&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        val nextPhaseIndex = gameState.currentPhaseIndex + 1&#10;        val phaseDuration = gameConfiguration.getCurrentPhaseDuration(nextPhaseIndex)&#10;        val nextPhase = gameConfiguration.turnPhases[nextPhaseIndex]&#10;&#10;        gameState = gameState.copy(&#10;            currentPhaseIndex = nextPhaseIndex,&#10;            timeRemainingSeconds = phaseDuration,&#10;            timeRemainingMillis = phaseDuration * 1000L,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = false,&#10;            // Reset dice state for new phase&#10;            dicePhaseState = DicePhaseState.WAITING_TO_THROW,&#10;            diceResult = null,&#10;            isDiceAnimating = false&#10;        )&#10;&#10;        // Auto-start timer for next phase (unless it's a dice phase waiting for throw)&#10;        if (nextPhase.phaseType != PhaseType.DICE_THROW || !shouldWaitForDiceThrow()) {&#10;            startTimer()&#10;        }&#10;    }&#10;&#10;    private fun moveToNextPlayer() {&#10;        // Play a beep sound when passing turn&#10;        playTurnPassBeep()&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        // Record the time taken for current player's turn (only record when completing all phases)&#10;        val timeTaken = gameConfiguration.getCurrentPhaseDuration(gameState.currentPhaseIndex) - gameState.timeRemainingSeconds&#10;        val currentPlayerTimes = gameState.playerTurnTimes[gameState.currentPlayerIndex].toMutableList()&#10;        currentPlayerTimes.add(timeTaken)&#10;&#10;        val updatedPlayerTurnTimes = gameState.playerTurnTimes.toMutableList()&#10;        updatedPlayerTurnTimes[gameState.currentPlayerIndex] = currentPlayerTimes&#10;&#10;        val nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameConfiguration.numberOfPlayers&#10;        val newRoundCount = if (nextPlayerIndex == 0) gameState.roundCount + 1 else gameState.roundCount&#10;        val firstPhaseDuration = gameConfiguration.getCurrentPhaseDuration(0)&#10;        val firstPhase = gameConfiguration.turnPhases[0]&#10;&#10;        gameState = gameState.copy(&#10;            currentPlayerIndex = nextPlayerIndex,&#10;            currentPhaseIndex = 0, // Reset to first phase for new player&#10;            timeRemainingSeconds = firstPhaseDuration,&#10;            timeRemainingMillis = firstPhaseDuration * 1000L,&#10;            playerTurnTimes = updatedPlayerTurnTimes,&#10;            roundCount = newRoundCount,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = false,&#10;            // Reset dice state for new player&#10;            dicePhaseState = DicePhaseState.WAITING_TO_THROW,&#10;            diceResult = null,&#10;            isDiceAnimating = false&#10;        )&#10;&#10;        // Auto-start timer for next player (unless first phase is a dice phase waiting for throw)&#10;        if (firstPhase.phaseType != PhaseType.DICE_THROW || !shouldWaitForDiceThrow()) {&#10;            startTimer()&#10;        }&#10;    }&#10;&#10;    fun undoLastAction() {&#10;        undoHistory?.let { previousState -&gt;&#10;            gameState = previousState&#10;            undoHistory = null&#10;            if (gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun pauseResumeGame() {&#10;        if (gameState.isGameRunning) {&#10;            gameState = gameState.copy(isPaused = !gameState.isPaused)&#10;            if (gameState.isPaused) {&#10;                timerJob?.cancel()&#10;            } else {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun endGame() {&#10;        timerJob?.cancel()&#10;        gameState = gameState.copy(isGameRunning = false, isPaused = false)&#10;        showStats = true&#10;    }&#10;&#10;    private fun startTimer() {&#10;        timerJob?.cancel()&#10;        timerJob = viewModelScope.launch {&#10;            var lastUpdateTime = System.currentTimeMillis()&#10;            var lastSecond = gameState.timeRemainingSeconds&#10;&#10;            while (gameState.timeRemainingMillis &gt; 0 &amp;&amp; gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                delay(16) // Update every 16ms for smooth animation (~60fps)&#10;&#10;                val currentTime = System.currentTimeMillis()&#10;                val deltaTime = currentTime - lastUpdateTime&#10;                lastUpdateTime = currentTime&#10;&#10;                val newTimeMillis = (gameState.timeRemainingMillis - deltaTime).coerceAtLeast(0L)&#10;                val newTimeSeconds = (newTimeMillis / 1000).toInt()&#10;&#10;                gameState = gameState.copy(&#10;                    timeRemainingMillis = newTimeMillis,&#10;                    timeRemainingSeconds = newTimeSeconds&#10;                )&#10;&#10;                // Handle audio alerts (only on second changes)&#10;                if (newTimeSeconds != lastSecond) {&#10;                    lastSecond = newTimeSeconds&#10;                    when (newTimeSeconds) {&#10;                        60 -&gt; if (gameConfiguration.audioAlert60s) playAlert()&#10;                        30 -&gt; if (gameConfiguration.audioAlert30s) playAlert()&#10;                        10, 9, 8, 7, 6, 5, 4, 3, 2, 1 -&gt; {&#10;                            if (gameConfiguration.audioAlert10sCountdown) {&#10;                                speakCountdown(newTimeSeconds)&#10;                            }&#10;                        }&#10;                        0 -&gt; {&#10;                            // Handle timeout with enhanced functionality&#10;                            handlePlayerTimeout()&#10;                            break&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handlePlayerTimeout() {&#10;        // Play timeout alert if enabled&#10;        if (gameConfiguration.audioAlertTimeOut) {&#10;            playAlert()&#10;        }&#10;&#10;        // Announce timeout with text-to-speech if enabled&#10;        if (gameConfiguration.audioAlertTimeOut &amp;&amp; ttsReady) {&#10;            val playerName = gameConfiguration.getPlayerName(gameState.currentPlayerIndex)&#10;            textToSpeech?.speak(&quot;$playerName ran out of time!&quot;, TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;&#10;        // Pause the game and show timeout dialog&#10;        gameState = gameState.copy(&#10;            isPaused = true,&#10;            showTimeExpiredDialog = true&#10;        )&#10;    }&#10;&#10;    fun dismissTimeExpiredDialog() {&#10;        gameState = gameState.copy(showTimeExpiredDialog = false)&#10;    }&#10;&#10;    fun continueAfterTimeout() {&#10;        // Reset timer to full duration and resume game&#10;        gameState = gameState.copy(&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            isPaused = false,&#10;            showTimeExpiredDialog = false&#10;        )&#10;        startTimer()&#10;    }&#10;&#10;    private fun playAlert() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_CDMA_ALERT_CALL_GUARD, 200)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun playTurnPassBeep() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_PROP_BEEP, 150)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun speakCountdown(seconds: Int) {&#10;        if (ttsReady) {&#10;            textToSpeech?.speak(seconds.toString(), TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    fun updateConfiguration(newConfig: GameConfiguration) {&#10;        gameConfiguration = newConfig&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(newConfig.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = newConfig.turnDurationSeconds,&#10;                timeRemainingMillis = newConfig.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun saveConfiguration(name: String) {&#10;        if (name.isBlank()) return&#10;&#10;        val newConfig = SavedConfiguration(name, gameConfiguration)&#10;        val updatedConfigs = savedConfigurations.toMutableList()&#10;&#10;        // Remove existing config with same name&#10;        updatedConfigs.removeAll { it.name == name }&#10;        updatedConfigs.add(newConfig)&#10;&#10;        savedConfigurations = updatedConfigs&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    fun loadConfiguration(savedConfig: SavedConfiguration) {&#10;        gameConfiguration = savedConfig.configuration&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;                timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun deleteConfiguration(configName: String) {&#10;        savedConfigurations = savedConfigurations.filter { it.name != configName }&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    private fun loadSavedConfigurations() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = prefs.getString(&quot;saved_configurations&quot;, &quot;[]&quot;)&#10;            val type = object : TypeToken&lt;List&lt;SavedConfiguration&gt;&gt;() {}.type&#10;            try {&#10;                savedConfigurations = gson.fromJson(json, type) ?: emptyList()&#10;            } catch (e: Exception) {&#10;                savedConfigurations = emptyList()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveToPersistentStorage() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = gson.toJson(savedConfigurations)&#10;            prefs.edit().putString(&quot;saved_configurations&quot;, json).apply()&#10;        }&#10;    }&#10;&#10;    fun showOptions() {&#10;        showOptions = true&#10;    }&#10;&#10;    fun hideOptions() {&#10;        showOptions = false&#10;    }&#10;&#10;    fun hideStats() {&#10;        showStats = false&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        toneGenerator?.release()&#10;        textToSpeech?.shutdown()&#10;    }&#10;&#10;    fun throwDice() {&#10;        val currentPhase = gameConfiguration.turnPhases[gameState.currentPhaseIndex]&#10;        if (currentPhase.phaseType != PhaseType.DICE_THROW) return&#10;&#10;        // Prevent throwing dice if game is not running&#10;        if (!gameState.isGameRunning) return&#10;&#10;        // Prevent throwing dice if already thrown in this phase&#10;        if (gameState.dicePhaseState != DicePhaseState.WAITING_TO_THROW) return&#10;&#10;        // Start dice animation&#10;        gameState = gameState.copy(&#10;            isDiceAnimating = true,&#10;            dicePhaseState = DicePhaseState.THROWING&#10;        )&#10;&#10;        // Simulate dice animation with out-of-sync changes for multiple dice&#10;        viewModelScope.launch {&#10;            val animationDuration = 3000L // Fixed at 3 seconds&#10;            val startTime = System.currentTimeMillis()&#10;&#10;            // Initialize with random values immediately to replace &quot;Tap to throw&quot;&#10;            var previousValues = (1..currentPhase.diceCount).map { (1..currentPhase.diceType.sides).random() }&#10;            val lastChangeTime = mutableListOf&lt;Long&gt;()&#10;            repeat(currentPhase.diceCount) { lastChangeTime.add(0L) }&#10;&#10;            // Set initial values immediately&#10;            gameState = gameState.copy(&#10;                diceResult = DiceResult(previousValues, previousValues.sum())&#10;            )&#10;&#10;            while (System.currentTimeMillis() - startTime &lt; animationDuration) {&#10;                val currentTime = System.currentTimeMillis() - startTime&#10;                val progress = currentTime.toFloat() / animationDuration.toFloat()&#10;&#10;                // Create deceleration curve - starts fast, gets slower&#10;                val decelerationFactor = 1.0f - (progress * progress) // Quadratic deceleration&#10;                val adjustedBaseInterval = (120L + (300L * progress)).toLong() // 120ms to 420ms (more controlled)&#10;&#10;                // Check each die individually and update immediately when it's time to change&#10;                for (index in 0 until currentPhase.diceCount) {&#10;                    val dieInterval = (adjustedBaseInterval + (index * 80L * decelerationFactor)).toLong()&#10;&#10;                    // Check if enough time has passed since this die's last change&#10;                    if (currentTime - lastChangeTime[index] &gt;= dieInterval) {&#10;                        // Time to change this die's value - update immediately&#10;                        lastChangeTime[index] = currentTime&#10;                        val newValue = (1..currentPhase.diceType.sides).random()&#10;&#10;                        // Update only this die's value immediately for perfect sync&#10;                        val updatedValues = previousValues.toMutableList()&#10;                        updatedValues[index] = newValue&#10;                        previousValues = updatedValues&#10;&#10;                        // Update state immediately when value changes&#10;                        gameState = gameState.copy(&#10;                            diceResult = DiceResult(previousValues, previousValues.sum())&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Fixed frame rate&#10;                delay(50L)&#10;            }&#10;&#10;            // Generate final result&#10;            val finalValues = (1..currentPhase.diceCount).map {&#10;                (1..currentPhase.diceType.sides).random()&#10;            }&#10;            gameState = gameState.copy(&#10;                isDiceAnimating = false,&#10;                diceResult = DiceResult(finalValues, finalValues.sum()),&#10;                dicePhaseState = DicePhaseState.SHOWING_RESULT&#10;            )&#10;&#10;            // Play dice sound effect&#10;            playDiceSound()&#10;&#10;            // Handle timer based on phase configuration&#10;            if (currentPhase.waitForPress) {&#10;                // If wait for press is enabled, just pause and wait for manual progression&#10;                gameState = gameState.copy(isPaused = true)&#10;            } else if (currentPhase.durationSeconds &gt; 0) {&#10;                // Start the timer with the configured duration&#10;                gameState = gameState.copy(&#10;                    timeRemainingSeconds = currentPhase.durationSeconds,&#10;                    timeRemainingMillis = currentPhase.durationSeconds * 1000L,&#10;                    isPaused = false&#10;                )&#10;                startTimer()&#10;            } else {&#10;                // Duration is 0, automatically proceed to next phase/player&#10;                delay(1000) // Show result for 1 second&#10;                nextPlayer()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun playDiceSound() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_PROP_BEEP, 200)&#10;    }&#10;&#10;    fun getCurrentPhase(): TurnPhase {&#10;        return gameConfiguration.turnPhases[gameState.currentPhaseIndex]&#10;    }&#10;&#10;    fun isDicePhase(): Boolean {&#10;        return getCurrentPhase().phaseType == PhaseType.DICE_THROW&#10;    }&#10;&#10;    fun shouldWaitForDiceThrow(): Boolean {&#10;        val currentPhase = getCurrentPhase()&#10;        return currentPhase.phaseType == PhaseType.DICE_THROW &amp;&amp;&#10;               gameState.dicePhaseState == DicePhaseState.WAITING_TO_THROW&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModelNew.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModelNew.kt" />
              <option name="updatedContent" value="package com.example.boardgametimer.viewmodel&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.media.AudioManager&#10;import android.media.ToneGenerator&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.speech.tts.TextToSpeech&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.GameState&#10;import com.example.boardgametimer.model.SavedConfiguration&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.util.Locale&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;&#10;class GameTimerViewModel : ViewModel() {&#10;&#10;    var gameState by mutableStateOf(GameState())&#10;        private set&#10;&#10;    var gameConfiguration by mutableStateOf(GameConfiguration())&#10;        private set&#10;&#10;    var showOptions by mutableStateOf(false)&#10;        private set&#10;&#10;    var showStats by mutableStateOf(false)&#10;        private set&#10;&#10;    var undoHistory by mutableStateOf&lt;GameState?&gt;(null)&#10;        private set&#10;&#10;    var savedConfigurations by mutableStateOf&lt;List&lt;SavedConfiguration&gt;&gt;(emptyList())&#10;        private set&#10;&#10;    private var timerJob: Job? = null&#10;    private var toneGenerator: ToneGenerator? = null&#10;    private var vibrator: Vibrator? = null&#10;    private var textToSpeech: TextToSpeech? = null&#10;    private var ttsReady = false&#10;    private var sharedPreferences: SharedPreferences? = null&#10;    private val gson = Gson()&#10;&#10;    fun initializeAudio(context: Context) {&#10;        toneGenerator = ToneGenerator(AudioManager.STREAM_NOTIFICATION, 100)&#10;&#10;        // Use modern vibrator API&#10;        vibrator = if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.S) {&#10;            val vibratorManager = context.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            vibratorManager.defaultVibrator&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;&#10;        textToSpeech = TextToSpeech(context) { status -&gt;&#10;            if (status == TextToSpeech.SUCCESS) {&#10;                textToSpeech?.language = Locale.getDefault()&#10;                ttsReady = true&#10;            }&#10;        }&#10;&#10;        // Initialize SharedPreferences for saving configurations&#10;        sharedPreferences = context.getSharedPreferences(&quot;BoardGameTimer&quot;, Context.MODE_PRIVATE)&#10;        loadSavedConfigurations()&#10;    }&#10;&#10;    fun startNewGame() {&#10;        val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;        gameState = GameState(&#10;            currentPlayerIndex = 0,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            isGameRunning = true,&#10;            isPaused = true, // Start paused&#10;            roundCount = 0,&#10;            playerTurnTimes = playerTurnTimes,&#10;            gameStartTime = System.currentTimeMillis(),&#10;            turnStartTime = System.currentTimeMillis()&#10;        )&#10;        // Don't start timer automatically - wait for user to resume&#10;    }&#10;&#10;    fun nextPlayer() {&#10;        if (!gameState.isGameRunning) return&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        // Record the time taken for current player's turn&#10;        val timeTaken = gameConfiguration.turnDurationSeconds - gameState.timeRemainingSeconds&#10;        val currentPlayerTimes = gameState.playerTurnTimes[gameState.currentPlayerIndex].toMutableList()&#10;        currentPlayerTimes.add(timeTaken)&#10;&#10;        val updatedPlayerTurnTimes = gameState.playerTurnTimes.toMutableList()&#10;        updatedPlayerTurnTimes[gameState.currentPlayerIndex] = currentPlayerTimes&#10;&#10;        val nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameConfiguration.numberOfPlayers&#10;        val newRoundCount = if (nextPlayerIndex == 0) gameState.roundCount + 1 else gameState.roundCount&#10;&#10;        gameState = gameState.copy(&#10;            currentPlayerIndex = nextPlayerIndex,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            playerTurnTimes = updatedPlayerTurnTimes,&#10;            roundCount = newRoundCount,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = true // Pause after each player switch&#10;        )&#10;&#10;        // Don't auto-start timer - let user resume manually&#10;    }&#10;&#10;    fun undoLastAction() {&#10;        undoHistory?.let { previousState -&gt;&#10;            gameState = previousState&#10;            undoHistory = null&#10;            if (gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun pauseResumeGame() {&#10;        if (gameState.isGameRunning) {&#10;            gameState = gameState.copy(isPaused = !gameState.isPaused)&#10;            if (gameState.isPaused) {&#10;                timerJob?.cancel()&#10;            } else {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun endGame() {&#10;        timerJob?.cancel()&#10;        gameState = gameState.copy(isGameRunning = false, isPaused = false)&#10;        showStats = true&#10;    }&#10;&#10;    private fun startTimer() {&#10;        timerJob?.cancel()&#10;        timerJob = viewModelScope.launch {&#10;            var lastUpdateTime = System.currentTimeMillis()&#10;            var lastSecond = gameState.timeRemainingSeconds&#10;            &#10;            while (gameState.timeRemainingMillis &gt; 0 &amp;&amp; gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                delay(16) // Update every 16ms for smooth animation (~60fps)&#10;                &#10;                val currentTime = System.currentTimeMillis()&#10;                val deltaTime = currentTime - lastUpdateTime&#10;                lastUpdateTime = currentTime&#10;                &#10;                val newTimeMillis = (gameState.timeRemainingMillis - deltaTime).coerceAtLeast(0L)&#10;                val newTimeSeconds = (newTimeMillis / 1000).toInt()&#10;                &#10;                gameState = gameState.copy(&#10;                    timeRemainingMillis = newTimeMillis,&#10;                    timeRemainingSeconds = newTimeSeconds&#10;                )&#10;&#10;                // Handle audio alerts (only on second changes)&#10;                if (newTimeSeconds != lastSecond) {&#10;                    lastSecond = newTimeSeconds&#10;                    when (newTimeSeconds) {&#10;                        60 -&gt; if (gameConfiguration.audioAlert60s) playAlert()&#10;                        30 -&gt; if (gameConfiguration.audioAlert30s) playAlert()&#10;                        10, 9, 8, 7, 6, 5, 4, 3, 2, 1 -&gt; {&#10;                            if (gameConfiguration.audioAlert10sCountdown) {&#10;                                speakCountdown(newTimeSeconds)&#10;                            }&#10;                        }&#10;                        0 -&gt; {&#10;                            if (gameConfiguration.audioAlertTimeOut) playAlert()&#10;                            break&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun playAlert() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_CDMA_ALERT_CALL_GUARD, 200)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun speakCountdown(seconds: Int) {&#10;        if (ttsReady) {&#10;            textToSpeech?.speak(seconds.toString(), TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    fun updateConfiguration(newConfig: GameConfiguration) {&#10;        gameConfiguration = newConfig&#10;        // Reset game state with new configuration&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(newConfig.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = newConfig.turnDurationSeconds,&#10;                timeRemainingMillis = newConfig.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = true&#10;            )&#10;        }&#10;    }&#10;&#10;    fun saveConfiguration(name: String) {&#10;        if (name.isBlank()) return&#10;        &#10;        val newConfig = SavedConfiguration(name, gameConfiguration)&#10;        val updatedConfigs = savedConfigurations.toMutableList()&#10;        &#10;        // Remove existing config with same name&#10;        updatedConfigs.removeAll { it.name == name }&#10;        updatedConfigs.add(newConfig)&#10;        &#10;        savedConfigurations = updatedConfigs&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    fun loadConfiguration(savedConfig: SavedConfiguration) {&#10;        gameConfiguration = savedConfig.configuration&#10;        // Reset game state with new configuration&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;                timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = true&#10;            )&#10;        }&#10;    }&#10;&#10;    fun deleteConfiguration(configName: String) {&#10;        savedConfigurations = savedConfigurations.filter { it.name != configName }&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    private fun loadSavedConfigurations() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = prefs.getString(&quot;saved_configurations&quot;, &quot;[]&quot;)&#10;            val type = object : TypeToken&lt;List&lt;SavedConfiguration&gt;&gt;() {}.type&#10;            try {&#10;                savedConfigurations = gson.fromJson(json, type) ?: emptyList()&#10;            } catch (e: Exception) {&#10;                savedConfigurations = emptyList()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveToPersistentStorage() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = gson.toJson(savedConfigurations)&#10;            prefs.edit().putString(&quot;saved_configurations&quot;, json).apply()&#10;        }&#10;    }&#10;&#10;    fun showOptions() {&#10;        showOptions = true&#10;    }&#10;&#10;    fun hideOptions() {&#10;        showOptions = false&#10;    }&#10;&#10;    fun hideStats() {&#10;        showStats = false&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        toneGenerator?.release()&#10;        textToSpeech?.shutdown()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModel_Fixed.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModel_Fixed.kt" />
              <option name="updatedContent" value="package com.example.boardgametimer.viewmodel&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.media.AudioManager&#10;import android.media.ToneGenerator&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.speech.tts.TextToSpeech&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.GameState&#10;import com.example.boardgametimer.model.SavedConfiguration&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.util.Locale&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;&#10;class GameTimerViewModel : ViewModel() {&#10;&#10;    var gameState by mutableStateOf(GameState())&#10;        private set&#10;&#10;    var gameConfiguration by mutableStateOf(GameConfiguration())&#10;        private set&#10;&#10;    var showOptions by mutableStateOf(false)&#10;        private set&#10;&#10;    var showStats by mutableStateOf(false)&#10;        private set&#10;&#10;    var undoHistory by mutableStateOf&lt;GameState?&gt;(null)&#10;        private set&#10;&#10;    var savedConfigurations by mutableStateOf&lt;List&lt;SavedConfiguration&gt;&gt;(emptyList())&#10;        private set&#10;&#10;    private var timerJob: Job? = null&#10;    private var toneGenerator: ToneGenerator? = null&#10;    private var vibrator: Vibrator? = null&#10;    private var textToSpeech: TextToSpeech? = null&#10;    private var ttsReady = false&#10;    private var sharedPreferences: SharedPreferences? = null&#10;    private val gson = Gson()&#10;&#10;    fun initializeAudio(context: Context) {&#10;        toneGenerator = ToneGenerator(AudioManager.STREAM_NOTIFICATION, 100)&#10;&#10;        // Use modern vibrator API&#10;        vibrator = if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.S) {&#10;            val vibratorManager = context.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            vibratorManager.defaultVibrator&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;&#10;        textToSpeech = TextToSpeech(context) { status -&gt;&#10;            if (status == TextToSpeech.SUCCESS) {&#10;                textToSpeech?.language = Locale.getDefault()&#10;                ttsReady = true&#10;            }&#10;        }&#10;&#10;        // Initialize SharedPreferences for saving configurations&#10;        sharedPreferences = context.getSharedPreferences(&quot;BoardGameTimer&quot;, Context.MODE_PRIVATE)&#10;        loadSavedConfigurations()&#10;    }&#10;&#10;    fun startNewGame() {&#10;        val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;        gameState = GameState(&#10;            currentPlayerIndex = 0,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            isGameRunning = true,&#10;            isPaused = false, // Start ready to play, not paused&#10;            roundCount = 0,&#10;            playerTurnTimes = playerTurnTimes,&#10;            gameStartTime = System.currentTimeMillis(),&#10;            turnStartTime = System.currentTimeMillis()&#10;        )&#10;        startTimer() // Auto-start the timer for the first player&#10;    }&#10;&#10;    fun nextPlayer() {&#10;        if (!gameState.isGameRunning) return&#10;&#10;        // Play a beep sound when passing turn&#10;        playTurnPassBeep()&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        // Record the time taken for current player's turn&#10;        val timeTaken = gameConfiguration.turnDurationSeconds - gameState.timeRemainingSeconds&#10;        val currentPlayerTimes = gameState.playerTurnTimes[gameState.currentPlayerIndex].toMutableList()&#10;        currentPlayerTimes.add(timeTaken)&#10;&#10;        val updatedPlayerTurnTimes = gameState.playerTurnTimes.toMutableList()&#10;        updatedPlayerTurnTimes[gameState.currentPlayerIndex] = currentPlayerTimes&#10;&#10;        val nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameConfiguration.numberOfPlayers&#10;        val newRoundCount = if (nextPlayerIndex == 0) gameState.roundCount + 1 else gameState.roundCount&#10;&#10;        gameState = gameState.copy(&#10;            currentPlayerIndex = nextPlayerIndex,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            playerTurnTimes = updatedPlayerTurnTimes,&#10;            roundCount = newRoundCount,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = false // Don't pause after each player switch&#10;        )&#10;&#10;        // Auto-start timer for next player&#10;        startTimer()&#10;    }&#10;&#10;    fun undoLastAction() {&#10;        undoHistory?.let { previousState -&gt;&#10;            gameState = previousState&#10;            undoHistory = null&#10;            if (gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun pauseResumeGame() {&#10;        if (gameState.isGameRunning) {&#10;            gameState = gameState.copy(isPaused = !gameState.isPaused)&#10;            if (gameState.isPaused) {&#10;                timerJob?.cancel()&#10;            } else {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun endGame() {&#10;        timerJob?.cancel()&#10;        gameState = gameState.copy(isGameRunning = false, isPaused = false)&#10;        showStats = true&#10;    }&#10;&#10;    private fun startTimer() {&#10;        timerJob?.cancel()&#10;        timerJob = viewModelScope.launch {&#10;            var lastUpdateTime = System.currentTimeMillis()&#10;            var lastSecond = gameState.timeRemainingSeconds&#10;&#10;            while (gameState.timeRemainingMillis &gt; 0 &amp;&amp; gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                delay(16) // Update every 16ms for smooth animation (~60fps)&#10;&#10;                val currentTime = System.currentTimeMillis()&#10;                val deltaTime = currentTime - lastUpdateTime&#10;                lastUpdateTime = currentTime&#10;&#10;                val newTimeMillis = (gameState.timeRemainingMillis - deltaTime).coerceAtLeast(0L)&#10;                val newTimeSeconds = (newTimeMillis / 1000).toInt()&#10;&#10;                gameState = gameState.copy(&#10;                    timeRemainingMillis = newTimeMillis,&#10;                    timeRemainingSeconds = newTimeSeconds&#10;                )&#10;&#10;                // Handle audio alerts (only on second changes)&#10;                if (newTimeSeconds != lastSecond) {&#10;                    lastSecond = newTimeSeconds&#10;                    when (newTimeSeconds) {&#10;                        60 -&gt; if (gameConfiguration.audioAlert60s) playAlert()&#10;                        30 -&gt; if (gameConfiguration.audioAlert30s) playAlert()&#10;                        10, 9, 8, 7, 6, 5, 4, 3, 2, 1 -&gt; {&#10;                            if (gameConfiguration.audioAlert10sCountdown) {&#10;                                speakCountdown(newTimeSeconds)&#10;                            }&#10;                        }&#10;                        0 -&gt; {&#10;                            if (gameConfiguration.audioAlertTimeOut) playAlert()&#10;                            break&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun playAlert() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_CDMA_ALERT_CALL_GUARD, 200)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun playTurnPassBeep() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_PROP_BEEP, 150)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun speakCountdown(seconds: Int) {&#10;        if (ttsReady) {&#10;            textToSpeech?.speak(seconds.toString(), TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    fun updateConfiguration(newConfig: GameConfiguration) {&#10;        gameConfiguration = newConfig&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(newConfig.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = newConfig.turnDurationSeconds,&#10;                timeRemainingMillis = newConfig.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun saveConfiguration(name: String) {&#10;        if (name.isBlank()) return&#10;&#10;        val newConfig = SavedConfiguration(name, gameConfiguration)&#10;        val updatedConfigs = savedConfigurations.toMutableList()&#10;&#10;        // Remove existing config with same name&#10;        updatedConfigs.removeAll { it.name == name }&#10;        updatedConfigs.add(newConfig)&#10;&#10;        savedConfigurations = updatedConfigs&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    fun loadConfiguration(savedConfig: SavedConfiguration) {&#10;        gameConfiguration = savedConfig.configuration&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;                timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun deleteConfiguration(configName: String) {&#10;        savedConfigurations = savedConfigurations.filter { it.name != configName }&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    private fun loadSavedConfigurations() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = prefs.getString(&quot;saved_configurations&quot;, &quot;[]&quot;)&#10;            val type = object : TypeToken&lt;List&lt;SavedConfiguration&gt;&gt;() {}.type&#10;            try {&#10;                savedConfigurations = gson.fromJson(json, type) ?: emptyList()&#10;            } catch (e: Exception) {&#10;                savedConfigurations = emptyList()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveToPersistentStorage() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = gson.toJson(savedConfigurations)&#10;            prefs.edit().putString(&quot;saved_configurations&quot;, json).apply()&#10;        }&#10;    }&#10;&#10;    fun showOptions() {&#10;        showOptions = true&#10;    }&#10;&#10;    fun hideOptions() {&#10;        showOptions = false&#10;    }&#10;&#10;    fun hideStats() {&#10;        showStats = false&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        toneGenerator?.release()&#10;        textToSpeech?.shutdown()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModel_updated.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModel_updated.kt" />
              <option name="updatedContent" value="package com.example.boardgametimer.viewmodel&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.media.AudioManager&#10;import android.media.ToneGenerator&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.speech.tts.TextToSpeech&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.GameState&#10;import com.example.boardgametimer.model.SavedConfiguration&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.util.Locale&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;&#10;class GameTimerViewModel : ViewModel() {&#10;&#10;    var gameState by mutableStateOf(GameState())&#10;        private set&#10;&#10;    var gameConfiguration by mutableStateOf(GameConfiguration())&#10;        private set&#10;&#10;    var showOptions by mutableStateOf(false)&#10;        private set&#10;&#10;    var showStats by mutableStateOf(false)&#10;        private set&#10;&#10;    var undoHistory by mutableStateOf&lt;GameState?&gt;(null)&#10;        private set&#10;&#10;    var savedConfigurations by mutableStateOf&lt;List&lt;SavedConfiguration&gt;&gt;(emptyList())&#10;        private set&#10;&#10;    private var timerJob: Job? = null&#10;    private var toneGenerator: ToneGenerator? = null&#10;    private var vibrator: Vibrator? = null&#10;    private var textToSpeech: TextToSpeech? = null&#10;    private var ttsReady = false&#10;    private var sharedPreferences: SharedPreferences? = null&#10;    private val gson = Gson()&#10;&#10;    fun initializeAudio(context: Context) {&#10;        toneGenerator = ToneGenerator(AudioManager.STREAM_NOTIFICATION, 100)&#10;&#10;        // Use modern vibrator API&#10;        vibrator = if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.S) {&#10;            val vibratorManager = context.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            vibratorManager.defaultVibrator&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;&#10;        textToSpeech = TextToSpeech(context) { status -&gt;&#10;            if (status == TextToSpeech.SUCCESS) {&#10;                textToSpeech?.language = Locale.getDefault()&#10;                ttsReady = true&#10;            }&#10;        }&#10;&#10;        // Initialize SharedPreferences for saving configurations&#10;        sharedPreferences = context.getSharedPreferences(&quot;BoardGameTimer&quot;, Context.MODE_PRIVATE)&#10;        loadSavedConfigurations()&#10;    }&#10;&#10;    fun startNewGame() {&#10;        val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;        gameState = GameState(&#10;            currentPlayerIndex = 0,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            isGameRunning = true,&#10;            isPaused = false, // Start ready to play, not paused&#10;            roundCount = 0,&#10;            playerTurnTimes = playerTurnTimes,&#10;            gameStartTime = System.currentTimeMillis(),&#10;            turnStartTime = System.currentTimeMillis()&#10;        )&#10;        startTimer() // Auto-start the timer for the first player&#10;    }&#10;&#10;    fun nextPlayer() {&#10;        if (!gameState.isGameRunning) return&#10;&#10;        // Play a beep sound when passing turn&#10;        playTurnPassBeep()&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        // Record the time taken for current player's turn&#10;        val timeTaken = gameConfiguration.turnDurationSeconds - gameState.timeRemainingSeconds&#10;        val currentPlayerTimes = gameState.playerTurnTimes[gameState.currentPlayerIndex].toMutableList()&#10;        currentPlayerTimes.add(timeTaken)&#10;&#10;        val updatedPlayerTurnTimes = gameState.playerTurnTimes.toMutableList()&#10;        updatedPlayerTurnTimes[gameState.currentPlayerIndex] = currentPlayerTimes&#10;&#10;        val nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameConfiguration.numberOfPlayers&#10;        val newRoundCount = if (nextPlayerIndex == 0) gameState.roundCount + 1 else gameState.roundCount&#10;&#10;        gameState = gameState.copy(&#10;            currentPlayerIndex = nextPlayerIndex,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            playerTurnTimes = updatedPlayerTurnTimes,&#10;            roundCount = newRoundCount,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = false // Don't pause after each player switch&#10;        )&#10;&#10;        // Auto-start timer for next player&#10;        startTimer()&#10;    }&#10;&#10;    fun undoLastAction() {&#10;        undoHistory?.let { previousState -&gt;&#10;            gameState = previousState&#10;            undoHistory = null&#10;            if (gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun pauseResumeGame() {&#10;        if (gameState.isGameRunning) {&#10;            gameState = gameState.copy(isPaused = !gameState.isPaused)&#10;            if (gameState.isPaused) {&#10;                timerJob?.cancel()&#10;            } else {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun endGame() {&#10;        timerJob?.cancel()&#10;        gameState = gameState.copy(isGameRunning = false, isPaused = false)&#10;        showStats = true&#10;    }&#10;&#10;    private fun startTimer() {&#10;        timerJob?.cancel()&#10;        timerJob = viewModelScope.launch {&#10;            var lastUpdateTime = System.currentTimeMillis()&#10;            var lastSecond = gameState.timeRemainingSeconds&#10;&#10;            while (gameState.timeRemainingMillis &gt; 0 &amp;&amp; gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                delay(16) // Update every 16ms for smooth animation (~60fps)&#10;&#10;                val currentTime = System.currentTimeMillis()&#10;                val deltaTime = currentTime - lastUpdateTime&#10;                lastUpdateTime = currentTime&#10;&#10;                val newTimeMillis = (gameState.timeRemainingMillis - deltaTime).coerceAtLeast(0L)&#10;                val newTimeSeconds = (newTimeMillis / 1000).toInt()&#10;&#10;                gameState = gameState.copy(&#10;                    timeRemainingMillis = newTimeMillis,&#10;                    timeRemainingSeconds = newTimeSeconds&#10;                )&#10;&#10;                // Handle audio alerts (only on second changes)&#10;                if (newTimeSeconds != lastSecond) {&#10;                    lastSecond = newTimeSeconds&#10;                    when (newTimeSeconds) {&#10;                        60 -&gt; if (gameConfiguration.audioAlert60s) playAlert()&#10;                        30 -&gt; if (gameConfiguration.audioAlert30s) playAlert()&#10;                        10, 9, 8, 7, 6, 5, 4, 3, 2, 1 -&gt; {&#10;                            if (gameConfiguration.audioAlert10sCountdown) {&#10;                                speakCountdown(newTimeSeconds)&#10;                            }&#10;                        }&#10;                        0 -&gt; {&#10;                            // Handle timeout with enhanced functionality&#10;                            handlePlayerTimeout()&#10;                            break&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handlePlayerTimeout() {&#10;        // Play timeout alert if enabled&#10;        if (gameConfiguration.audioAlertTimeOut) {&#10;            playAlert()&#10;        }&#10;        &#10;        // Announce timeout with text-to-speech if enabled&#10;        if (gameConfiguration.audioAlertTimeOut &amp;&amp; ttsReady) {&#10;            val playerName = gameConfiguration.getPlayerName(gameState.currentPlayerIndex)&#10;            textToSpeech?.speak(&quot;$playerName ran out of time!&quot;, TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;        &#10;        // Pause the game and show timeout dialog&#10;        gameState = gameState.copy(&#10;            isPaused = true,&#10;            showTimeExpiredDialog = true&#10;        )&#10;    }&#10;&#10;    fun dismissTimeExpiredDialog() {&#10;        gameState = gameState.copy(showTimeExpiredDialog = false)&#10;    }&#10;&#10;    fun continueAfterTimeout() {&#10;        // Reset timer to full duration and resume game&#10;        gameState = gameState.copy(&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            isPaused = false,&#10;            showTimeExpiredDialog = false&#10;        )&#10;        startTimer()&#10;    }&#10;&#10;    private fun playAlert() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_CDMA_ALERT_CALL_GUARD, 200)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun playTurnPassBeep() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_PROP_BEEP, 150)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun speakCountdown(seconds: Int) {&#10;        if (ttsReady) {&#10;            textToSpeech?.speak(seconds.toString(), TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    fun updateConfiguration(newConfig: GameConfiguration) {&#10;        gameConfiguration = newConfig&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(newConfig.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = newConfig.turnDurationSeconds,&#10;                timeRemainingMillis = newConfig.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun saveConfiguration(name: String) {&#10;        if (name.isBlank()) return&#10;&#10;        val newConfig = SavedConfiguration(name, gameConfiguration)&#10;        val updatedConfigs = savedConfigurations.toMutableList()&#10;&#10;        // Remove existing config with same name&#10;        updatedConfigs.removeAll { it.name == name }&#10;        updatedConfigs.add(newConfig)&#10;&#10;        savedConfigurations = updatedConfigs&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    fun loadConfiguration(savedConfig: SavedConfiguration) {&#10;        gameConfiguration = savedConfig.configuration&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;                timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun deleteConfiguration(configName: String) {&#10;        savedConfigurations = savedConfigurations.filter { it.name != configName }&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    private fun loadSavedConfigurations() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = prefs.getString(&quot;saved_configurations&quot;, &quot;[]&quot;)&#10;            val type = object : TypeToken&lt;List&lt;SavedConfiguration&gt;&gt;() {}.type&#10;            try {&#10;                savedConfigurations = gson.fromJson(json, type) ?: emptyList()&#10;            } catch (e: Exception) {&#10;                savedConfigurations = emptyList()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveToPersistentStorage() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = gson.toJson(savedConfigurations)&#10;            prefs.edit().putString(&quot;saved_configurations&quot;, json).apply()&#10;        }&#10;    }&#10;&#10;    fun showOptions() {&#10;        showOptions = true&#10;    }&#10;&#10;    fun hideOptions() {&#10;        showOptions = false&#10;    }&#10;&#10;    fun hideStats() {&#10;        showStats = false&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        toneGenerator?.release()&#10;        textToSpeech?.shutdown()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>