<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/MainActivity.kt" />
              <option name="originalContent" value="package com.example.boardgametimer&#10;&#10;import android.os.Bundle&#10;import android.view.WindowManager&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.boardgametimer.ui.components.GameTimerScreen&#10;import com.example.boardgametimer.ui.components.OptionsDialog&#10;import com.example.boardgametimer.ui.components.StatsDialog&#10;import com.example.boardgametimer.ui.theme.BoardGameTimerTheme&#10;import com.example.boardgametimer.viewmodel.GameTimerViewModel&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Keep screen on during gameplay&#10;        window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)&#10;&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            BoardGameTimerTheme {&#10;                Surface(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    color = MaterialTheme.colorScheme.background&#10;                ) {&#10;                    BoardGameTimerApp()&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun BoardGameTimerApp() {&#10;    val viewModel: GameTimerViewModel = viewModel()&#10;    val context = LocalContext.current&#10;&#10;    // Initialize audio when the app starts&#10;    LaunchedEffect(Unit) {&#10;        viewModel.initializeAudio(context)&#10;    }&#10;&#10;    Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;        GameTimerScreen(&#10;            gameState = viewModel.gameState,&#10;            gameConfiguration = viewModel.gameConfiguration,&#10;            onNextPlayer = viewModel::nextPlayer,&#10;            onPauseResume = viewModel::pauseResumeGame,&#10;            onShowOptions = viewModel::showOptions,&#10;            onEndGame = {&#10;                if (viewModel.gameState.isGameRunning) {&#10;                    viewModel.endGame()&#10;                } else {&#10;                    viewModel.startNewGame()&#10;                }&#10;            },&#10;            onUndo = viewModel::undoLastAction,&#10;            modifier = Modifier.padding(innerPadding)&#10;        )&#10;&#10;        // Options Dialog&#10;        if (viewModel.showOptions) {&#10;            OptionsDialog(&#10;                gameConfiguration = viewModel.gameConfiguration,&#10;                savedConfigurations = viewModel.savedConfigurations,&#10;                onConfigurationChanged = viewModel::updateConfiguration,&#10;                onSaveConfiguration = { name, config -&gt;&#10;                    // Update the game configuration first, then save it&#10;                    viewModel.updateConfiguration(config)&#10;                    viewModel.saveConfiguration(name)&#10;                },&#10;                onLoadConfiguration = viewModel::loadConfiguration,&#10;                onDeleteConfiguration = viewModel::deleteConfiguration,&#10;                onDismiss = viewModel::hideOptions&#10;            )&#10;        }&#10;&#10;        // Stats Dialog&#10;        if (viewModel.showStats) {&#10;            StatsDialog(&#10;                gameState = viewModel.gameState,&#10;                gameConfiguration = viewModel.gameConfiguration,&#10;                onDismiss = viewModel::hideStats,&#10;                onNewGame = viewModel::startNewGame&#10;            )&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.boardgametimer&#10;&#10;import android.os.Bundle&#10;import android.view.WindowManager&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.boardgametimer.ui.components.GameTimerScreen&#10;import com.example.boardgametimer.ui.components.OptionsDialog&#10;import com.example.boardgametimer.ui.components.StatsDialog&#10;import com.example.boardgametimer.ui.components.TimeExpiredDialog&#10;import com.example.boardgametimer.ui.theme.BoardGameTimerTheme&#10;import com.example.boardgametimer.viewmodel.GameTimerViewModel&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Keep screen on during gameplay&#10;        window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)&#10;&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            BoardGameTimerTheme {&#10;                Surface(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    color = MaterialTheme.colorScheme.background&#10;                ) {&#10;                    BoardGameTimerApp()&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun BoardGameTimerApp() {&#10;    val viewModel: GameTimerViewModel = viewModel()&#10;    val context = LocalContext.current&#10;&#10;    // Initialize audio when the app starts&#10;    LaunchedEffect(Unit) {&#10;        viewModel.initializeAudio(context)&#10;    }&#10;&#10;    Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;        GameTimerScreen(&#10;            gameState = viewModel.gameState,&#10;            gameConfiguration = viewModel.gameConfiguration,&#10;            onNextPlayer = viewModel::nextPlayer,&#10;            onPauseResume = viewModel::pauseResumeGame,&#10;            onShowOptions = viewModel::showOptions,&#10;            onEndGame = {&#10;                if (viewModel.gameState.isGameRunning) {&#10;                    viewModel.endGame()&#10;                } else {&#10;                    viewModel.startNewGame()&#10;                }&#10;            },&#10;            onUndo = viewModel::undoLastAction,&#10;            modifier = Modifier.padding(innerPadding)&#10;        )&#10;&#10;        // Options Dialog&#10;        if (viewModel.showOptions) {&#10;            OptionsDialog(&#10;                gameConfiguration = viewModel.gameConfiguration,&#10;                savedConfigurations = viewModel.savedConfigurations,&#10;                onConfigurationChanged = viewModel::updateConfiguration,&#10;                onSaveConfiguration = { name, config -&gt;&#10;                    // Update the game configuration first, then save it&#10;                    viewModel.updateConfiguration(config)&#10;                    viewModel.saveConfiguration(name)&#10;                },&#10;                onLoadConfiguration = viewModel::loadConfiguration,&#10;                onDeleteConfiguration = viewModel::deleteConfiguration,&#10;                onDismiss = viewModel::hideOptions&#10;            )&#10;        }&#10;&#10;        // Stats Dialog&#10;        if (viewModel.showStats) {&#10;            StatsDialog(&#10;                gameState = viewModel.gameState,&#10;                gameConfiguration = viewModel.gameConfiguration,&#10;                onDismiss = viewModel::hideStats,&#10;                onNewGame = viewModel::startNewGame&#10;            )&#10;        }&#10;&#10;        // Time Expired Dialog&#10;        if (viewModel.gameState.showTimeExpiredDialog) {&#10;            TimeExpiredDialog(&#10;                currentPlayerIndex = viewModel.gameState.currentPlayerIndex,&#10;                gameConfiguration = viewModel.gameConfiguration,&#10;                onDismiss = { viewModel.dismissTimeExpiredDialog() },&#10;                onNextPlayer = {&#10;                    viewModel.nextPlayer()&#10;                    viewModel.dismissTimeExpiredDialog()&#10;                }&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/model/GameConfiguration.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/model/GameConfiguration.kt" />
              <option name="originalContent" value="package com.example.boardgametimer.model&#10;&#10;data class GameConfiguration(&#10;    val numberOfPlayers: Int = 4,&#10;    val turnDurationSeconds: Int = 120, // 2 minutes default&#10;    val playerNames: List&lt;String&gt; = emptyList(),&#10;    val audioAlert60s: Boolean = false,&#10;    val audioAlert30s: Boolean = false,&#10;    val audioAlert10sCountdown: Boolean = true, // Enable by default&#10;    val audioAlertTimeOut: Boolean = true, // Enable timeout alert by default&#10;    val vibrateOnAlerts: Boolean = true, // Enable by default&#10;    val keepCounterAlignmentFixed: Boolean = false,&#10;    val selectedSoundIndex: Int = 0 // Index for predefined sounds&#10;) {&#10;    fun getPlayerName(index: Int): String {&#10;        return if (index &lt; playerNames.size &amp;&amp; playerNames[index].isNotBlank()) {&#10;            playerNames[index]&#10;        } else {&#10;            &quot;Player ${index + 1}&quot;&#10;        }&#10;    }&#10;}&#10;&#10;data class SavedConfiguration(&#10;    val name: String,&#10;    val configuration: GameConfiguration&#10;)&#10;" />
              <option name="updatedContent" value="package com.example.boardgametimer.model&#10;&#10;data class TurnPhase(&#10;    val name: String,&#10;    val durationSeconds: Int&#10;)&#10;&#10;data class GameConfiguration(&#10;    val numberOfPlayers: Int = 4,&#10;    val turnPhases: List&lt;TurnPhase&gt; = listOf(TurnPhase(&quot;Main Turn&quot;, 120)), // Default single phase&#10;    val turnDurationSeconds: Int = 120, // Keep for backward compatibility&#10;    val playerNames: List&lt;String&gt; = emptyList(),&#10;    val audioAlert60s: Boolean = false,&#10;    val audioAlert30s: Boolean = false,&#10;    val audioAlert10sCountdown: Boolean = true, // Enable by default&#10;    val audioAlertTimeOut: Boolean = true, // Enable timeout alert by default&#10;    val vibrateOnAlerts: Boolean = true, // Enable by default&#10;    val keepCounterAlignmentFixed: Boolean = false,&#10;    val selectedSoundIndex: Int = 0 // Index for predefined sounds&#10;) {&#10;    fun getPlayerName(index: Int): String {&#10;        return if (index &lt; playerNames.size &amp;&amp; playerNames[index].isNotBlank()) {&#10;            playerNames[index]&#10;        } else {&#10;            &quot;Player ${index + 1}&quot;&#10;        }&#10;    }&#10;    &#10;    fun getCurrentPhaseDuration(phaseIndex: Int): Int {&#10;        return if (phaseIndex &lt; turnPhases.size) {&#10;            turnPhases[phaseIndex].durationSeconds&#10;        } else {&#10;            turnDurationSeconds // Fallback to legacy duration&#10;        }&#10;    }&#10;    &#10;    fun getCurrentPhaseName(phaseIndex: Int): String {&#10;        return if (phaseIndex &lt; turnPhases.size) {&#10;            turnPhases[phaseIndex].name&#10;        } else {&#10;            &quot;Phase ${phaseIndex + 1}&quot;&#10;        }&#10;    }&#10;    &#10;    fun getTotalPhases(): Int = turnPhases.size&#10;}&#10;&#10;data class SavedConfiguration(&#10;    val name: String,&#10;    val configuration: GameConfiguration&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/model/GameState.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/model/GameState.kt" />
              <option name="originalContent" value="package com.example.boardgametimer.model&#10;&#10;data class GameState(&#10;    val currentPlayerIndex: Int = 0,&#10;    val timeRemainingSeconds: Int = 120,&#10;    val timeRemainingMillis: Long = 120000L, // Add millisecond precision for smooth animation&#10;    val isGameRunning: Boolean = false,&#10;    val isPaused: Boolean = true, // Start paused by default&#10;    val roundCount: Int = 0,&#10;    val playerTurnTimes: List&lt;MutableList&lt;Int&gt;&gt; = emptyList(), // Track turn times for each player&#10;    val gameStartTime: Long = 0L,&#10;    val turnStartTime: Long = 0L,&#10;    val showTimeExpiredDialog: Boolean = false // Show timeout dialog&#10;) {&#10;    fun getAverageTimeForPlayer(playerIndex: Int): Double {&#10;        return if (playerIndex &lt; playerTurnTimes.size &amp;&amp; playerTurnTimes[playerIndex].isNotEmpty()) {&#10;            playerTurnTimes[playerIndex].average()&#10;        } else {&#10;            0.0&#10;        }&#10;    }&#10;&#10;    fun getOverallAverageTime(): Double {&#10;        val allTimes = playerTurnTimes.flatten()&#10;        return if (allTimes.isNotEmpty()) {&#10;            allTimes.average()&#10;        } else {&#10;            0.0&#10;        }&#10;    }&#10;&#10;    fun getTotalRounds(): Int {&#10;        return playerTurnTimes.maxOfOrNull { it.size } ?: 0&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.boardgametimer.model&#10;&#10;data class GameState(&#10;    val currentPlayerIndex: Int = 0,&#10;    val currentPhaseIndex: Int = 0, // Track current phase within the turn&#10;    val timeRemainingSeconds: Int = 120,&#10;    val timeRemainingMillis: Long = 120000L, // Add millisecond precision for smooth animation&#10;    val isGameRunning: Boolean = false,&#10;    val isPaused: Boolean = true, // Start paused by default&#10;    val roundCount: Int = 0,&#10;    val playerTurnTimes: List&lt;MutableList&lt;Int&gt;&gt; = emptyList(), // Track turn times for each player&#10;    val gameStartTime: Long = 0L,&#10;    val turnStartTime: Long = 0L,&#10;    val showTimeExpiredDialog: Boolean = false // Show timeout dialog&#10;) {&#10;    fun getAverageTimeForPlayer(playerIndex: Int): Double {&#10;        return if (playerIndex &lt; playerTurnTimes.size &amp;&amp; playerTurnTimes[playerIndex].isNotEmpty()) {&#10;            playerTurnTimes[playerIndex].average()&#10;        } else {&#10;            0.0&#10;        }&#10;    }&#10;&#10;    fun getOverallAverageTime(): Double {&#10;        val allTimes = playerTurnTimes.flatten()&#10;        return if (allTimes.isNotEmpty()) {&#10;            allTimes.average()&#10;        } else {&#10;            0.0&#10;        }&#10;    }&#10;&#10;    fun getTotalRounds(): Int {&#10;        return playerTurnTimes.maxOfOrNull { it.size } ?: 0&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/ui/components/GameTimerScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/ui/components/GameTimerScreen.kt" />
              <option name="originalContent" value="package com.example.boardgametimer.ui.components&#10;&#10;import androidx.compose.animation.core.Animatable&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Pause&#10;import androidx.compose.material.icons.filled.PlayArrow&#10;import androidx.compose.material.icons.filled.Settings&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.StrokeCap&#10;import androidx.compose.ui.graphics.drawscope.DrawScope&#10;import androidx.compose.ui.graphics.drawscope.Stroke&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.GameState&#10;import java.util.Locale&#10;import kotlin.math.cos&#10;import kotlin.math.min&#10;import kotlin.math.sin&#10;&#10;@Composable&#10;fun GameTimerScreen(&#10;    gameState: GameState,&#10;    gameConfiguration: GameConfiguration,&#10;    onNextPlayer: () -&gt; Unit,&#10;    onPauseResume: () -&gt; Unit,&#10;    onShowOptions: () -&gt; Unit,&#10;    onEndGame: () -&gt; Unit,&#10;    onUndo: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val configuration = LocalConfiguration.current&#10;    val screenHeight = configuration.screenHeightDp.dp&#10;    val screenWidth = configuration.screenWidthDp.dp&#10;&#10;    // Calculate circle size based on screen size&#10;    val circleSize = min(screenWidth.value, screenHeight.value * 0.6f).dp&#10;&#10;    // Animation for pointer rotation - fix rotation to not go full circle on last player&#10;    val rotationAngle = remember { Animatable(0f) }&#10;&#10;    LaunchedEffect(gameState.currentPlayerIndex, gameConfiguration.numberOfPlayers) {&#10;        // Calculate target angle for text (original position)&#10;        val targetAngle = (gameState.currentPlayerIndex * 360f / gameConfiguration.numberOfPlayers)&#10;&#10;        // Always rotate clockwise - don't take shortest path for player transitions&#10;        val currentAngle = rotationAngle.value&#10;        val newTargetAngle = if (targetAngle &lt; currentAngle % 360f &amp;&amp; gameState.currentPlayerIndex == 0) {&#10;            // Handle wrap-around from last player to first player - continue clockwise&#10;            currentAngle + (360f - (currentAngle % 360f)) + targetAngle&#10;        } else {&#10;            // Normal clockwise progression&#10;            val baseAngle = (currentAngle / 360f).toInt() * 360f&#10;            baseAngle + targetAngle&#10;        }&#10;&#10;        rotationAngle.animateTo(&#10;            targetValue = newTargetAngle,&#10;            animationSpec = tween(durationMillis = 800)&#10;        )&#10;    }&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        verticalArrangement = Arrangement.Center&#10;    ) {&#10;&#10;        Spacer(modifier = Modifier.weight(1f))&#10;&#10;        // Game Timer Circle with Pointer&#10;        Box(&#10;            modifier = Modifier.size(circleSize),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            // Draw the pointer and circle&#10;            TimerCircleWithPointer(&#10;                gameState = gameState,&#10;                gameConfiguration = gameConfiguration,&#10;                circleSize = circleSize,&#10;                pointerRotation = rotationAngle.value,&#10;                onCircleClick = onNextPlayer&#10;            )&#10;        }&#10;&#10;        Spacer(modifier = Modifier.weight(1f))&#10;&#10;        // Control Buttons&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.SpaceEvenly,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Settings Button&#10;            IconButton(&#10;                onClick = onShowOptions,&#10;                modifier = Modifier.size(48.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Settings,&#10;                    contentDescription = &quot;Settings&quot;,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            }&#10;&#10;            // Pause/Resume Button&#10;            IconButton(&#10;                onClick = onPauseResume,&#10;                modifier = Modifier.size(48.dp),&#10;                enabled = gameState.isGameRunning&#10;            ) {&#10;                Icon(&#10;                    imageVector = if (gameState.isPaused) Icons.Default.PlayArrow else Icons.Default.Pause,&#10;                    contentDescription = if (gameState.isPaused) &quot;Resume&quot; else &quot;Pause&quot;,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        // START/END Button - Change text based on game state&#10;        Button(&#10;            onClick = if (gameState.isGameRunning) onEndGame else {&#10;                // Start new game logic will be handled in MainActivity&#10;                onEndGame&#10;            },&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(56.dp),&#10;            colors = ButtonDefaults.buttonColors(&#10;                containerColor = if (gameState.isGameRunning) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.primary&#10;            )&#10;        ) {&#10;            Text(&#10;                text = if (gameState.isGameRunning) &quot;END GAME&quot; else &quot;START GAME&quot;,&#10;                fontSize = 18.sp,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;        }&#10;&#10;        // Undo Button (if undo is available)&#10;        if (gameState.isGameRunning) {&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            TextButton(onClick = onUndo) {&#10;                Text(&quot;Undo Last Action&quot;)&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;    }&#10;}&#10;&#10;@Composable&#10;fun TimerCircleWithPointer(&#10;    gameState: GameState,&#10;    gameConfiguration: GameConfiguration,&#10;    circleSize: androidx.compose.ui.unit.Dp,&#10;    pointerRotation: Float,&#10;    onCircleClick: () -&gt; Unit&#10;) {&#10;    // Use millisecond precision for smooth animation&#10;    val progress = gameState.timeRemainingMillis.toFloat() / (gameConfiguration.turnDurationSeconds * 1000f)&#10;&#10;    // Colors for the circle (bright blue to dark blue)&#10;    val brightBlue = Color(0xFF1E88E5)&#10;    val darkBlue = Color(0xFF0D47A1)&#10;    val currentColor = androidx.compose.ui.graphics.lerp(darkBlue, brightBlue, progress)&#10;    val pointerColor = Color(0xFF81D4FA)&#10;&#10;    // Calculate rotation for text orientation based on configuration&#10;    val textRotation = if (gameConfiguration.keepCounterAlignmentFixed) 0f else pointerRotation&#10;&#10;    Box(&#10;        modifier = Modifier.size(circleSize),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        // Canvas for drawing circle and pointer&#10;        Canvas(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .clip(CircleShape)&#10;                .clickable { onCircleClick() }&#10;        ) {&#10;            val center = Offset(size.width / 2f, size.height / 2f)&#10;            val radius = size.width / 2f - 40.dp.toPx() // More space for the arrow&#10;&#10;            // Draw the timer circle&#10;            drawTimerCircle(&#10;                center = center,&#10;                radius = radius,&#10;                progress = progress,&#10;                color = currentColor&#10;            )&#10;&#10;            // Draw the pointer flipped 180 degrees from text position&#10;            drawArrowPointer(&#10;                center = center,&#10;                radius = radius,&#10;                rotation = pointerRotation + 180f, // Flip arrow by 180 degrees&#10;                color = pointerColor,&#10;                playerCount = gameConfiguration.numberOfPlayers&#10;            )&#10;        }&#10;&#10;        // Timer text in the center - use original rotation (not flipped)&#10;        Box(&#10;            modifier = Modifier&#10;                .size(circleSize * 0.6f)&#10;                .then(&#10;                    if (!gameConfiguration.keepCounterAlignmentFixed) {&#10;                        Modifier.graphicsLayer {&#10;                            rotationZ = pointerRotation // Use original rotation for text&#10;                        }&#10;                    } else Modifier&#10;                ),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Text(&#10;                    text = formatTime(gameState.timeRemainingSeconds),&#10;                    fontSize = (circleSize.value / 8).sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    textAlign = TextAlign.Center,&#10;                    color = MaterialTheme.colorScheme.onSurface&#10;                )&#10;&#10;                Text(&#10;                    text = gameConfiguration.getPlayerName(gameState.currentPlayerIndex),&#10;                    fontSize = (circleSize.value / 16).sp,&#10;                    textAlign = TextAlign.Center,&#10;                    color = MaterialTheme.colorScheme.onSurface&#10;                )&#10;&#10;                // Round counter title&#10;                Text(&#10;                    text = &quot;Round ${gameState.roundCount + 1}&quot;,&#10;                    fontSize = (circleSize.value / 20).sp,&#10;                    textAlign = TextAlign.Center,&#10;                    color = MaterialTheme.colorScheme.secondary,&#10;                    fontWeight = FontWeight.Medium&#10;                )&#10;&#10;                // Phase information&#10;                if (gameConfiguration.getTotalPhases() &gt; 1) {&#10;                    Text(&#10;                        text = gameConfiguration.getCurrentPhaseName(gameState.currentPhaseIndex),&#10;                        fontSize = (circleSize.value / 20).sp,&#10;                        textAlign = TextAlign.Center,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        fontWeight = FontWeight.Medium&#10;                    )&#10;&#10;                    Text(&#10;                        text = &quot;Phase ${gameState.currentPhaseIndex + 1}/${gameConfiguration.getTotalPhases()}&quot;,&#10;                        fontSize = (circleSize.value / 24).sp,&#10;                        textAlign = TextAlign.Center,&#10;                        color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)&#10;                    )&#10;                }&#10;&#10;                if (gameState.isPaused) {&#10;                    Text(&#10;                        text = &quot;PAUSED&quot;,&#10;                        fontSize = (circleSize.value / 20).sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.error&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private fun DrawScope.drawTimerCircle(&#10;    center: Offset,&#10;    radius: Float,&#10;    progress: Float,&#10;    color: Color&#10;) {&#10;    val strokeWidth = 20.dp.toPx()&#10;&#10;    // Draw background circle&#10;    drawCircle(&#10;        color = color.copy(alpha = 0.3f),&#10;        radius = radius,&#10;        center = center,&#10;        style = Stroke(width = strokeWidth)&#10;    )&#10;&#10;    // Draw progress arc&#10;    drawArc(&#10;        color = color,&#10;        startAngle = -90f,&#10;        sweepAngle = 360f * progress,&#10;        useCenter = false,&#10;        topLeft = Offset(center.x - radius, center.y - radius),&#10;        size = Size(radius * 2, radius * 2),&#10;        style = Stroke(width = strokeWidth, cap = StrokeCap.Round)&#10;    )&#10;}&#10;&#10;private fun DrawScope.drawPointer(&#10;    center: Offset,&#10;    radius: Float,&#10;    rotation: Float,&#10;    color: Color,&#10;    playerCount: Int&#10;) {&#10;    val pointerWidth = 360f / playerCount.toFloat()&#10;    val pointerLength = radius + 30.dp.toPx()&#10;    val pointerThickness = 15.dp.toPx()&#10;&#10;    // Calculate pointer end position&#10;    val angleRad = Math.toRadians((rotation - 90).toDouble())&#10;    val endX = center.x + cos(angleRad).toFloat() * pointerLength&#10;    val endY = center.y + sin(angleRad).toFloat() * pointerLength&#10;&#10;    // Draw pointer as a thick line&#10;    drawLine(&#10;        color = color,&#10;        start = center,&#10;        end = Offset(endX, endY),&#10;        strokeWidth = pointerThickness,&#10;        cap = StrokeCap.Round&#10;    )&#10;}&#10;&#10;private fun DrawScope.drawArrowPointer(&#10;    center: Offset,&#10;    radius: Float,&#10;    rotation: Float,&#10;    color: Color,&#10;    playerCount: Int&#10;) {&#10;    val angleWidth = 360f / playerCount.toFloat()&#10;    val outerRadius = radius + 35.dp.toPx()&#10;    val innerRadius = radius + 15.dp.toPx()&#10;&#10;    // Calculate start and end angles for the arc&#10;    val startAngle = rotation - angleWidth / 2f&#10;    val endAngle = rotation + angleWidth / 2f&#10;&#10;    // Draw the wide arc pointer&#10;    drawArc(&#10;        color = color,&#10;        startAngle = startAngle - 90f, // Offset by 90 degrees to start at top&#10;        sweepAngle = angleWidth,&#10;        useCenter = false,&#10;        topLeft = Offset(center.x - outerRadius, center.y - outerRadius),&#10;        size = Size(outerRadius * 2, outerRadius * 2),&#10;        style = Stroke(width = (outerRadius - innerRadius), cap = StrokeCap.Round)&#10;    )&#10;}&#10;&#10;private fun formatTime(seconds: Int): String {&#10;    val minutes = seconds / 60&#10;    val remainingSeconds = seconds % 60&#10;    return String.format(Locale.getDefault(), &quot;%d:%02d&quot;, minutes, remainingSeconds)&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.boardgametimer.ui.components&#10;&#10;import androidx.compose.animation.core.Animatable&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Pause&#10;import androidx.compose.material.icons.filled.PlayArrow&#10;import androidx.compose.material.icons.filled.Settings&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.StrokeCap&#10;import androidx.compose.ui.graphics.drawscope.DrawScope&#10;import androidx.compose.ui.graphics.drawscope.Stroke&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.GameState&#10;import java.util.Locale&#10;import kotlin.math.cos&#10;import kotlin.math.min&#10;import kotlin.math.sin&#10;&#10;@Composable&#10;fun GameTimerScreen(&#10;    gameState: GameState,&#10;    gameConfiguration: GameConfiguration,&#10;    onNextPlayer: () -&gt; Unit,&#10;    onPauseResume: () -&gt; Unit,&#10;    onShowOptions: () -&gt; Unit,&#10;    onEndGame: () -&gt; Unit,&#10;    onUndo: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val configuration = LocalConfiguration.current&#10;    val screenHeight = configuration.screenHeightDp.dp&#10;    val screenWidth = configuration.screenWidthDp.dp&#10;&#10;    // Calculate circle size based on screen size&#10;    val circleSize = min(screenWidth.value, screenHeight.value * 0.6f).dp&#10;&#10;    // Animation for pointer rotation - fix rotation to not go full circle on last player&#10;    val rotationAngle = remember { Animatable(0f) }&#10;&#10;    LaunchedEffect(gameState.currentPlayerIndex, gameConfiguration.numberOfPlayers) {&#10;        // Calculate target angle for text (original position)&#10;        val targetAngle = (gameState.currentPlayerIndex * 360f / gameConfiguration.numberOfPlayers)&#10;&#10;        // Always rotate clockwise - don't take shortest path for player transitions&#10;        val currentAngle = rotationAngle.value&#10;        val newTargetAngle = if (targetAngle &lt; currentAngle % 360f &amp;&amp; gameState.currentPlayerIndex == 0) {&#10;            // Handle wrap-around from last player to first player - continue clockwise&#10;            currentAngle + (360f - (currentAngle % 360f)) + targetAngle&#10;        } else {&#10;            // Normal clockwise progression&#10;            val baseAngle = (currentAngle / 360f).toInt() * 360f&#10;            baseAngle + targetAngle&#10;        }&#10;&#10;        rotationAngle.animateTo(&#10;            targetValue = newTargetAngle,&#10;            animationSpec = tween(durationMillis = 800)&#10;        )&#10;    }&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        verticalArrangement = Arrangement.Center&#10;    ) {&#10;&#10;        Spacer(modifier = Modifier.weight(1f))&#10;&#10;        // Game Timer Circle with Pointer&#10;        Box(&#10;            modifier = Modifier.size(circleSize),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            // Draw the pointer and circle&#10;            TimerCircleWithPointer(&#10;                gameState = gameState,&#10;                gameConfiguration = gameConfiguration,&#10;                circleSize = circleSize,&#10;                pointerRotation = rotationAngle.value,&#10;                onCircleClick = onNextPlayer&#10;            )&#10;        }&#10;&#10;        Spacer(modifier = Modifier.weight(1f))&#10;&#10;        // Control Buttons&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.SpaceEvenly,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Settings Button&#10;            IconButton(&#10;                onClick = onShowOptions,&#10;                modifier = Modifier.size(48.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Settings,&#10;                    contentDescription = &quot;Settings&quot;,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            }&#10;&#10;            // Pause/Resume Button&#10;            IconButton(&#10;                onClick = onPauseResume,&#10;                modifier = Modifier.size(48.dp),&#10;                enabled = gameState.isGameRunning&#10;            ) {&#10;                Icon(&#10;                    imageVector = if (gameState.isPaused) Icons.Default.PlayArrow else Icons.Default.Pause,&#10;                    contentDescription = if (gameState.isPaused) &quot;Resume&quot; else &quot;Pause&quot;,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        // START/END Button - Change text based on game state&#10;        Button(&#10;            onClick = if (gameState.isGameRunning) onEndGame else {&#10;                // Start new game logic will be handled in MainActivity&#10;                onEndGame&#10;            },&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(56.dp),&#10;            colors = ButtonDefaults.buttonColors(&#10;                containerColor = if (gameState.isGameRunning) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.primary&#10;            )&#10;        ) {&#10;            Text(&#10;                text = if (gameState.isGameRunning) &quot;END GAME&quot; else &quot;START GAME&quot;,&#10;                fontSize = 18.sp,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;        }&#10;&#10;        // Undo Button (if undo is available)&#10;        if (gameState.isGameRunning) {&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            TextButton(onClick = onUndo) {&#10;                Text(&quot;Undo Last Action&quot;)&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;    }&#10;}&#10;&#10;@Composable&#10;fun TimerCircleWithPointer(&#10;    gameState: GameState,&#10;    gameConfiguration: GameConfiguration,&#10;    circleSize: androidx.compose.ui.unit.Dp,&#10;    pointerRotation: Float,&#10;    onCircleClick: () -&gt; Unit&#10;) {&#10;    // Use millisecond precision for smooth animation with current phase duration&#10;    val currentPhaseDuration = gameConfiguration.getCurrentPhaseDuration(gameState.currentPhaseIndex)&#10;    val progress = gameState.timeRemainingMillis.toFloat() / (currentPhaseDuration * 1000f)&#10;&#10;    // Colors for the circle (bright blue to dark blue)&#10;    val brightBlue = Color(0xFF1E88E5)&#10;    val darkBlue = Color(0xFF0D47A1)&#10;    val currentColor = androidx.compose.ui.graphics.lerp(darkBlue, brightBlue, progress)&#10;    val pointerColor = Color(0xFF81D4FA)&#10;&#10;    // Calculate rotation for text orientation based on configuration&#10;    val textRotation = if (gameConfiguration.keepCounterAlignmentFixed) 0f else pointerRotation&#10;&#10;    Box(&#10;        modifier = Modifier.size(circleSize),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        // Canvas for drawing circle and pointer&#10;        Canvas(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .clip(CircleShape)&#10;                .clickable { onCircleClick() }&#10;        ) {&#10;            val center = Offset(size.width / 2f, size.height / 2f)&#10;            val radius = size.width / 2f - 40.dp.toPx() // More space for the arrow&#10;&#10;            // Draw the timer circle&#10;            drawTimerCircle(&#10;                center = center,&#10;                radius = radius,&#10;                progress = progress,&#10;                color = currentColor&#10;            )&#10;&#10;            // Draw the pointer flipped 180 degrees from text position&#10;            drawArrowPointer(&#10;                center = center,&#10;                radius = radius,&#10;                rotation = pointerRotation + 180f, // Flip arrow by 180 degrees&#10;                color = pointerColor,&#10;                playerCount = gameConfiguration.numberOfPlayers&#10;            )&#10;        }&#10;&#10;        // Timer text in the center - use original rotation (not flipped)&#10;        Box(&#10;            modifier = Modifier&#10;                .size(circleSize * 0.6f)&#10;                .then(&#10;                    if (!gameConfiguration.keepCounterAlignmentFixed) {&#10;                        Modifier.graphicsLayer {&#10;                            rotationZ = pointerRotation // Use original rotation for text&#10;                        }&#10;                    } else Modifier&#10;                ),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Text(&#10;                    text = formatTime(gameState.timeRemainingSeconds),&#10;                    fontSize = (circleSize.value / 8).sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    textAlign = TextAlign.Center,&#10;                    color = MaterialTheme.colorScheme.onSurface&#10;                )&#10;&#10;                Text(&#10;                    text = gameConfiguration.getPlayerName(gameState.currentPlayerIndex),&#10;                    fontSize = (circleSize.value / 16).sp,&#10;                    textAlign = TextAlign.Center,&#10;                    color = MaterialTheme.colorScheme.onSurface&#10;                )&#10;&#10;                // Round counter title&#10;                Text(&#10;                    text = &quot;Round ${gameState.roundCount + 1}&quot;,&#10;                    fontSize = (circleSize.value / 20).sp,&#10;                    textAlign = TextAlign.Center,&#10;                    color = MaterialTheme.colorScheme.secondary,&#10;                    fontWeight = FontWeight.Medium&#10;                )&#10;&#10;                // Phase information&#10;                if (gameConfiguration.getTotalPhases() &gt; 1) {&#10;                    Text(&#10;                        text = gameConfiguration.getCurrentPhaseName(gameState.currentPhaseIndex),&#10;                        fontSize = (circleSize.value / 20).sp,&#10;                        textAlign = TextAlign.Center,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        fontWeight = FontWeight.Medium&#10;                    )&#10;&#10;                    Text(&#10;                        text = &quot;Phase ${gameState.currentPhaseIndex + 1}/${gameConfiguration.getTotalPhases()}&quot;,&#10;                        fontSize = (circleSize.value / 24).sp,&#10;                        textAlign = TextAlign.Center,&#10;                        color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)&#10;                    )&#10;                }&#10;&#10;                if (gameState.isPaused) {&#10;                    Text(&#10;                        text = &quot;PAUSED&quot;,&#10;                        fontSize = (circleSize.value / 20).sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.error&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private fun DrawScope.drawTimerCircle(&#10;    center: Offset,&#10;    radius: Float,&#10;    progress: Float,&#10;    color: Color&#10;) {&#10;    val strokeWidth = 20.dp.toPx()&#10;&#10;    // Draw background circle&#10;    drawCircle(&#10;        color = color.copy(alpha = 0.3f),&#10;        radius = radius,&#10;        center = center,&#10;        style = Stroke(width = strokeWidth)&#10;    )&#10;&#10;    // Draw progress arc&#10;    drawArc(&#10;        color = color,&#10;        startAngle = -90f,&#10;        sweepAngle = 360f * progress,&#10;        useCenter = false,&#10;        topLeft = Offset(center.x - radius, center.y - radius),&#10;        size = Size(radius * 2, radius * 2),&#10;        style = Stroke(width = strokeWidth, cap = StrokeCap.Round)&#10;    )&#10;}&#10;&#10;private fun DrawScope.drawPointer(&#10;    center: Offset,&#10;    radius: Float,&#10;    rotation: Float,&#10;    color: Color,&#10;    playerCount: Int&#10;) {&#10;    val pointerWidth = 360f / playerCount.toFloat()&#10;    val pointerLength = radius + 30.dp.toPx()&#10;    val pointerThickness = 15.dp.toPx()&#10;&#10;    // Calculate pointer end position&#10;    val angleRad = Math.toRadians((rotation - 90).toDouble())&#10;    val endX = center.x + cos(angleRad).toFloat() * pointerLength&#10;    val endY = center.y + sin(angleRad).toFloat() * pointerLength&#10;&#10;    // Draw pointer as a thick line&#10;    drawLine(&#10;        color = color,&#10;        start = center,&#10;        end = Offset(endX, endY),&#10;        strokeWidth = pointerThickness,&#10;        cap = StrokeCap.Round&#10;    )&#10;}&#10;&#10;private fun DrawScope.drawArrowPointer(&#10;    center: Offset,&#10;    radius: Float,&#10;    rotation: Float,&#10;    color: Color,&#10;    playerCount: Int&#10;) {&#10;    val angleWidth = 360f / playerCount.toFloat()&#10;    val outerRadius = radius + 35.dp.toPx()&#10;    val innerRadius = radius + 15.dp.toPx()&#10;&#10;    // Calculate start and end angles for the arc&#10;    val startAngle = rotation - angleWidth / 2f&#10;    val endAngle = rotation + angleWidth / 2f&#10;&#10;    // Draw the wide arc pointer&#10;    drawArc(&#10;        color = color,&#10;        startAngle = startAngle - 90f, // Offset by 90 degrees to start at top&#10;        sweepAngle = angleWidth,&#10;        useCenter = false,&#10;        topLeft = Offset(center.x - outerRadius, center.y - outerRadius),&#10;        size = Size(outerRadius * 2, outerRadius * 2),&#10;        style = Stroke(width = (outerRadius - innerRadius), cap = StrokeCap.Round)&#10;    )&#10;}&#10;&#10;private fun formatTime(seconds: Int): String {&#10;    val minutes = seconds / 60&#10;    val remainingSeconds = seconds % 60&#10;    return String.format(Locale.getDefault(), &quot;%d:%02d&quot;, minutes, remainingSeconds)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/ui/components/OptionsDialog.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/ui/components/OptionsDialog.kt" />
              <option name="originalContent" value="package com.example.boardgametimer.ui.components&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material.icons.filled.KeyboardArrowDown&#10;import androidx.compose.material.icons.filled.KeyboardArrowUp&#10;import androidx.compose.material.icons.filled.Remove&#10;import androidx.compose.material.icons.filled.SwapVert&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.KeyboardType&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.window.Dialog&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.SavedConfiguration&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun OptionsDialog(&#10;    gameConfiguration: GameConfiguration,&#10;    savedConfigurations: List&lt;SavedConfiguration&gt; = emptyList(),&#10;    onConfigurationChanged: (GameConfiguration) -&gt; Unit,&#10;    onSaveConfiguration: (String, GameConfiguration) -&gt; Unit = { _, _ -&gt; },&#10;    onLoadConfiguration: (SavedConfiguration) -&gt; Unit = {},&#10;    onDeleteConfiguration: (String) -&gt; Unit = {},&#10;    onDismiss: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    var tempConfig by remember { mutableStateOf(gameConfiguration) }&#10;    var playerNames by remember {&#10;        mutableStateOf(&#10;            List(tempConfig.numberOfPlayers) { index -&gt;&#10;                if (index &lt; tempConfig.playerNames.size) tempConfig.playerNames[index] else &quot;&quot;&#10;            }&#10;        )&#10;    }&#10;    var saveConfigName by remember { mutableStateOf(&quot;&quot;) }&#10;    var showSaveDialog by remember { mutableStateOf(false) }&#10;&#10;    Dialog(onDismissRequest = onDismiss) {&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .fillMaxHeight(0.9f)&#10;                .padding(4.dp), // Reduced padding from 16dp to 8dp for wider dialog&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 8.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(16.dp)&#10;            ) {&#10;                // Header&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Game Options&quot;,&#10;                        fontSize = 20.sp,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                    IconButton(onClick = onDismiss) {&#10;                        Icon(Icons.Default.Close, contentDescription = &quot;Close&quot;)&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                LazyColumn(&#10;                    modifier = Modifier.weight(1f),&#10;                    verticalArrangement = Arrangement.spacedBy(16.dp)&#10;                ) {&#10;                    // Saved Configurations&#10;                    if (savedConfigurations.isNotEmpty()) {&#10;                        item {&#10;                            Card(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;                            ) {&#10;                                Column(modifier = Modifier.padding(16.dp)) {&#10;                                    Text(&#10;                                        text = &quot;Saved Configurations&quot;,&#10;                                        fontWeight = FontWeight.Medium,&#10;                                        fontSize = 16.sp&#10;                                    )&#10;                                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                                    savedConfigurations.forEach { savedConfig -&gt;&#10;                                        Row(&#10;                                            modifier = Modifier&#10;                                                .fillMaxWidth()&#10;                                                .padding(vertical = 4.dp),&#10;                                            horizontalArrangement = Arrangement.SpaceBetween,&#10;                                            verticalAlignment = Alignment.CenterVertically&#10;                                        ) {&#10;                                            Column(modifier = Modifier.weight(1f)) {&#10;                                                Text(&#10;                                                    text = savedConfig.name,&#10;                                                    fontWeight = FontWeight.Medium&#10;                                                )&#10;                                                Text(&#10;                                                    text = &quot;${savedConfig.configuration.numberOfPlayers} players, ${formatDuration(savedConfig.configuration.turnDurationSeconds)}&quot;,&#10;                                                    fontSize = 12.sp,&#10;                                                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)&#10;                                                )&#10;                                            }&#10;                                            Row {&#10;                                                TextButton(&#10;                                                    onClick = {&#10;                                                        onLoadConfiguration(savedConfig)&#10;                                                        tempConfig = savedConfig.configuration&#10;                                                        playerNames = List(savedConfig.configuration.numberOfPlayers) { index -&gt;&#10;                                                            if (index &lt; savedConfig.configuration.playerNames.size) {&#10;                                                                savedConfig.configuration.playerNames[index]&#10;                                                            } else &quot;&quot;&#10;                                                        }&#10;                                                    }&#10;                                                ) {&#10;                                                    Text(&quot;Load&quot;)&#10;                                                }&#10;                                                IconButton(&#10;                                                    onClick = { onDeleteConfiguration(savedConfig.name) }&#10;                                                ) {&#10;                                                    Icon(&#10;                                                        Icons.Default.Delete,&#10;                                                        contentDescription = &quot;Delete&quot;,&#10;                                                        tint = MaterialTheme.colorScheme.error&#10;                                                    )&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                        HorizontalDivider()&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    item {&#10;                        // Number of Players&#10;                        Card(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;                        ) {&#10;                            Column(modifier = Modifier.padding(16.dp)) {&#10;                                Text(&#10;                                    text = &quot;Number of Players&quot;,&#10;                                    fontWeight = FontWeight.Medium,&#10;                                    fontSize = 16.sp&#10;                                )&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;                                Row(&#10;                                    verticalAlignment = Alignment.CenterVertically,&#10;                                    horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;                                ) {&#10;                                    IconButton(&#10;                                        onClick = {&#10;                                            if (tempConfig.numberOfPlayers &gt; 2) {&#10;                                                tempConfig = tempConfig.copy(numberOfPlayers = tempConfig.numberOfPlayers - 1)&#10;                                                playerNames = playerNames.dropLast(1)&#10;                                            }&#10;                                        }&#10;                                    ) {&#10;                                        Icon(Icons.Default.Remove, contentDescription = &quot;Decrease players&quot;)&#10;                                    }&#10;&#10;                                    Text(&#10;                                        text = tempConfig.numberOfPlayers.toString(),&#10;                                        fontSize = 18.sp,&#10;                                        fontWeight = FontWeight.Bold&#10;                                    )&#10;&#10;                                    IconButton(&#10;                                        onClick = {&#10;                                            if (tempConfig.numberOfPlayers &lt; 15) {&#10;                                                tempConfig = tempConfig.copy(numberOfPlayers = tempConfig.numberOfPlayers + 1)&#10;                                                playerNames = playerNames + &quot;&quot;&#10;                                            }&#10;                                        }&#10;                                    ) {&#10;                                        Icon(Icons.Default.Add, contentDescription = &quot;Increase players&quot;)&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    item {&#10;                        // Turn Phases Configuration (replaces Turn Duration)&#10;                        Card(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;                        ) {&#10;                            Column(modifier = Modifier.padding(16.dp)) {&#10;                                Row(&#10;                                    modifier = Modifier.fillMaxWidth(),&#10;                                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                                    verticalAlignment = Alignment.CenterVertically&#10;                                ) {&#10;                                    Text(&#10;                                        text = &quot;Round Configuration&quot;,&#10;                                        fontWeight = FontWeight.Medium,&#10;                                        fontSize = 16.sp&#10;                                    )&#10;&#10;                                    IconButton(&#10;                                        onClick = {&#10;                                            val newPhases = tempConfig.turnPhases + com.example.boardgametimer.model.TurnPhase(&quot;Phase ${tempConfig.turnPhases.size + 1}&quot;, 60)&#10;                                            tempConfig = tempConfig.copy(turnPhases = newPhases)&#10;                                        }&#10;                                    ) {&#10;                                        Icon(Icons.Default.Add, contentDescription = &quot;Add Phase&quot;)&#10;                                    }&#10;                                }&#10;&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                                // Display each phase&#10;                                tempConfig.turnPhases.forEachIndexed { index, phase -&gt;&#10;                                    Card(&#10;                                        modifier = Modifier&#10;                                            .fillMaxWidth()&#10;                                            .padding(vertical = 4.dp),&#10;                                        colors = CardDefaults.cardColors(&#10;                                            containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;                                        )&#10;                                    ) {&#10;                                        Column(modifier = Modifier.padding(12.dp)) {&#10;                                            Row(&#10;                                                modifier = Modifier.fillMaxWidth(),&#10;                                                horizontalArrangement = Arrangement.SpaceBetween,&#10;                                                verticalAlignment = Alignment.CenterVertically&#10;                                            ) {&#10;                                                Text(&#10;                                                    text = &quot;Phase ${index + 1}&quot;,&#10;                                                    fontWeight = FontWeight.Medium&#10;                                                )&#10;&#10;                                                if (tempConfig.turnPhases.size &gt; 1) {&#10;                                                    IconButton(&#10;                                                        onClick = {&#10;                                                            val newPhases = tempConfig.turnPhases.toMutableList()&#10;                                                            newPhases.removeAt(index)&#10;                                                            tempConfig = tempConfig.copy(turnPhases = newPhases)&#10;                                                        }&#10;                                                    ) {&#10;                                                        Icon(Icons.Default.Delete, contentDescription = &quot;Delete Phase&quot;)&#10;                                                    }&#10;                                                }&#10;                                            }&#10;&#10;                                            // Phase name input&#10;                                            OutlinedTextField(&#10;                                                value = phase.name,&#10;                                                onValueChange = { newName -&gt;&#10;                                                    val newPhases = tempConfig.turnPhases.toMutableList()&#10;                                                    newPhases[index] = phase.copy(name = newName)&#10;                                                    tempConfig = tempConfig.copy(turnPhases = newPhases)&#10;                                                },&#10;                                                label = { Text(&quot;Phase Name&quot;) },&#10;                                                modifier = Modifier.fillMaxWidth()&#10;                                            )&#10;&#10;                                            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                                            // Predefined time options for phase&#10;                                            Text(&#10;                                                text = &quot;Quick Select:&quot;,&#10;                                                fontSize = 14.sp,&#10;                                                fontWeight = FontWeight.Medium&#10;                                            )&#10;                                            Spacer(modifier = Modifier.height(4.dp))&#10;&#10;                                            val timeOptions = listOf(30, 60, 90, 120, 180, 300, 600) // seconds&#10;                                            val timeLabels = listOf(&quot;30s&quot;, &quot;1m&quot;, &quot;1.5m&quot;, &quot;2m&quot;, &quot;3m&quot;, &quot;5m&quot;, &quot;10m&quot;)&#10;&#10;                                            LazyRow(&#10;                                                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                                            ) {&#10;                                                items(timeOptions.size) { timeIndex -&gt;&#10;                                                    FilterChip(&#10;                                                        onClick = {&#10;                                                            val newPhases = tempConfig.turnPhases.toMutableList()&#10;                                                            newPhases[index] = phase.copy(durationSeconds = timeOptions[timeIndex])&#10;                                                            tempConfig = tempConfig.copy(turnPhases = newPhases)&#10;                                                        },&#10;                                                        label = { Text(timeLabels[timeIndex]) },&#10;                                                        selected = phase.durationSeconds == timeOptions[timeIndex]&#10;                                                    )&#10;                                                }&#10;                                            }&#10;&#10;                                            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                                            // Phase duration with original minus button and slightly wider plus button&#10;                                            Row(&#10;                                                modifier = Modifier.fillMaxWidth(),&#10;                                                verticalAlignment = Alignment.CenterVertically,&#10;                                                horizontalArrangement = Arrangement.SpaceBetween&#10;                                            ) {&#10;                                                Text(&#10;                                                    text = &quot;Duration:&quot;,&#10;                                                    fontSize = 14.sp,&#10;                                                    fontWeight = FontWeight.Medium&#10;                                                )&#10;&#10;                                                Row(&#10;                                                    verticalAlignment = Alignment.CenterVertically,&#10;                                                    horizontalArrangement = Arrangement.spacedBy(0.dp) // Further reduced gap&#10;                                                ) {&#10;                                                    // Original minus button (IconButton)&#10;                                                    IconButton(&#10;                                                        onClick = {&#10;                                                            if (phase.durationSeconds &gt; 10) {&#10;                                                                val newPhases = tempConfig.turnPhases.toMutableList()&#10;                                                                newPhases[index] = phase.copy(durationSeconds = phase.durationSeconds - 10)&#10;                                                                tempConfig = tempConfig.copy(turnPhases = newPhases)&#10;                                                            }&#10;                                                        }&#10;                                                    ) {&#10;                                                        Icon(Icons.Default.Remove, contentDescription = &quot;Decrease duration&quot;)&#10;                                                    }&#10;&#10;                                                    Text(&#10;                                                        text = &quot;${phase.durationSeconds / 60}:${String.format(&quot;%02d&quot;, phase.durationSeconds % 60)}&quot;,&#10;                                                        fontWeight = FontWeight.Bold,&#10;                                                        fontSize = 16.sp,&#10;                                                        modifier = Modifier.widthIn(min = 60.dp)&#10;                                                    )&#10;&#10;                                                    // Plus button with minimal extra padding&#10;                                                    Box(&#10;                                                        modifier = Modifier.padding(horizontal = 2.dp) // Reduced padding&#10;                                                    ) {&#10;                                                        IconButton(&#10;                                                            onClick = {&#10;                                                                if (phase.durationSeconds &lt; 600) {&#10;                                                                    val newPhases = tempConfig.turnPhases.toMutableList()&#10;                                                                    newPhases[index] = phase.copy(durationSeconds = phase.durationSeconds + 10)&#10;                                                                    tempConfig = tempConfig.copy(turnPhases = newPhases)&#10;                                                                }&#10;                                                            }&#10;                                                        ) {&#10;                                                            Icon(Icons.Default.Add, contentDescription = &quot;Increase duration&quot;)&#10;                                                        }&#10;                                                    }&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    item {&#10;                        // Player Names&#10;                        Card(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;                        ) {&#10;                            Column(modifier = Modifier.padding(16.dp)) {&#10;                                Row(&#10;                                    modifier = Modifier.fillMaxWidth(),&#10;                                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                                    verticalAlignment = Alignment.CenterVertically&#10;                                ) {&#10;                                    Text(&#10;                                        text = &quot;Player Names (Optional)&quot;,&#10;                                        fontWeight = FontWeight.Medium,&#10;                                        fontSize = 16.sp&#10;                                    )&#10;                                    // Flip/Reorder button&#10;                                    IconButton(&#10;                                        onClick = {&#10;                                            playerNames = playerNames.reversed()&#10;                                        }&#10;                                    ) {&#10;                                        Icon(&#10;                                            imageVector = Icons.Default.SwapVert,&#10;                                            contentDescription = &quot;Reverse player order&quot;&#10;                                        )&#10;                                    }&#10;                                }&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                                repeat(tempConfig.numberOfPlayers) { index -&gt;&#10;                                    Row(&#10;                                        modifier = Modifier.fillMaxWidth(),&#10;                                        verticalAlignment = Alignment.CenterVertically&#10;                                    ) {&#10;                                        // Move up button&#10;                                        IconButton(&#10;                                            onClick = {&#10;                                                if (index &gt; 0) {&#10;                                                    val newNames = playerNames.toMutableList()&#10;                                                    val temp = newNames[index]&#10;                                                    newNames[index] = newNames[index - 1]&#10;                                                    newNames[index - 1] = temp&#10;                                                    playerNames = newNames&#10;                                                }&#10;                                            },&#10;                                            enabled = index &gt; 0&#10;                                        ) {&#10;                                            Icon(&#10;                                                imageVector = Icons.Default.KeyboardArrowUp,&#10;                                                contentDescription = &quot;Move up&quot;&#10;                                            )&#10;                                        }&#10;&#10;                                        // Player name text field&#10;                                        OutlinedTextField(&#10;                                            value = if (index &lt; playerNames.size) playerNames[index] else &quot;&quot;,&#10;                                            onValueChange = { newName -&gt;&#10;                                                val updatedNames = playerNames.toMutableList()&#10;                                                while (updatedNames.size &lt;= index) {&#10;                                                    updatedNames.add(&quot;&quot;)&#10;                                                }&#10;                                                updatedNames[index] = newName&#10;                                                playerNames = updatedNames&#10;                                            },&#10;                                            label = { Text(&quot;Player ${index + 1}&quot;) },&#10;                                            modifier = Modifier&#10;                                                .weight(1f)&#10;                                                .padding(horizontal = 4.dp),&#10;                                            singleLine = true&#10;                                        )&#10;&#10;                                        // Move down button&#10;                                        IconButton(&#10;                                            onClick = {&#10;                                                if (index &lt; tempConfig.numberOfPlayers - 1) {&#10;                                                    val newNames = playerNames.toMutableList()&#10;                                                    val temp = newNames[index]&#10;                                                    newNames[index] = newNames[index + 1]&#10;                                                    newNames[index + 1] = temp&#10;                                                    playerNames = newNames&#10;                                                }&#10;                                            },&#10;                                            enabled = index &lt; tempConfig.numberOfPlayers - 1&#10;                                        ) {&#10;                                            Icon(&#10;                                                imageVector = Icons.Default.KeyboardArrowDown,&#10;                                                contentDescription = &quot;Move down&quot;&#10;                                            )&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    item {&#10;                        // Audio Alerts&#10;                        Card(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;                        ) {&#10;                            Column(modifier = Modifier.padding(16.dp)) {&#10;                                Text(&#10;                                    text = &quot;Audio Alerts&quot;,&#10;                                    fontWeight = FontWeight.Medium,&#10;                                    fontSize = 16.sp&#10;                                )&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                                CheckboxOption(&#10;                                    text = &quot;60 seconds remaining&quot;,&#10;                                    checked = tempConfig.audioAlert60s,&#10;                                    onCheckedChange = { tempConfig = tempConfig.copy(audioAlert60s = it) }&#10;                                )&#10;&#10;                                CheckboxOption(&#10;                                    text = &quot;30 seconds remaining&quot;,&#10;                                    checked = tempConfig.audioAlert30s,&#10;                                    onCheckedChange = { tempConfig = tempConfig.copy(audioAlert30s = it) }&#10;                                )&#10;&#10;                                CheckboxOption(&#10;                                    text = &quot;10 second countdown&quot;,&#10;                                    checked = tempConfig.audioAlert10sCountdown,&#10;                                    onCheckedChange = { tempConfig = tempConfig.copy(audioAlert10sCountdown = it) }&#10;                                )&#10;&#10;                                CheckboxOption(&#10;                                    text = &quot;Time out alert&quot;,&#10;                                    checked = tempConfig.audioAlertTimeOut,&#10;                                    onCheckedChange = { tempConfig = tempConfig.copy(audioAlertTimeOut = it) }&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    item {&#10;                        // Other Options&#10;                        Card(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;                        ) {&#10;                            Column(modifier = Modifier.padding(16.dp)) {&#10;                                Text(&#10;                                    text = &quot;Other Options&quot;,&#10;                                    fontWeight = FontWeight.Medium,&#10;                                    fontSize = 16.sp&#10;                                )&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                                CheckboxOption(&#10;                                    text = &quot;Vibrate on alerts&quot;,&#10;                                    checked = tempConfig.vibrateOnAlerts,&#10;                                    onCheckedChange = { tempConfig = tempConfig.copy(vibrateOnAlerts = it) }&#10;                                )&#10;&#10;                                CheckboxOption(&#10;                                    text = &quot;Keep counter alignment fixed&quot;,&#10;                                    checked = tempConfig.keepCounterAlignmentFixed,&#10;                                    onCheckedChange = { tempConfig = tempConfig.copy(keepCounterAlignmentFixed = it) }&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                // Action Buttons&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    // Save Configuration Button&#10;                    OutlinedButton(&#10;                        onClick = { showSaveDialog = true },&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;Save Config&quot;)&#10;                    }&#10;&#10;                    // Apply Button&#10;                    Button(&#10;                        onClick = {&#10;                            val finalConfig = tempConfig.copy(playerNames = playerNames.filter { it.isNotBlank() })&#10;                            onConfigurationChanged(finalConfig)&#10;                            onDismiss()&#10;                        },&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;Apply&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Save Configuration Dialog&#10;    if (showSaveDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showSaveDialog = false },&#10;            title = { Text(&quot;Save Configuration&quot;) },&#10;            text = {&#10;                OutlinedTextField(&#10;                    value = saveConfigName,&#10;                    onValueChange = { saveConfigName = it },&#10;                    label = { Text(&quot;Configuration Name&quot;) },&#10;                    singleLine = true&#10;                )&#10;            },&#10;            confirmButton = {&#10;                TextButton(&#10;                    onClick = {&#10;                        if (saveConfigName.isNotBlank()) {&#10;                            val finalConfig = tempConfig.copy(playerNames = playerNames.filter { it.isNotBlank() })&#10;                            onSaveConfiguration(saveConfigName, finalConfig)&#10;                            // Don't apply the configuration when saving - just save it&#10;                            showSaveDialog = false&#10;                            saveConfigName = &quot;&quot;&#10;                        }&#10;                    }&#10;                ) {&#10;                    Text(&quot;Save&quot;)&#10;                }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { showSaveDialog = false }) {&#10;                    Text(&quot;Cancel&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun CheckboxOption(&#10;    text: String,&#10;    checked: Boolean,&#10;    onCheckedChange: (Boolean) -&gt; Unit&#10;) {&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp),&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        Checkbox(&#10;            checked = checked,&#10;            onCheckedChange = onCheckedChange&#10;        )&#10;        Spacer(modifier = Modifier.width(8.dp))&#10;        Text(text = text)&#10;    }&#10;}&#10;&#10;private fun formatDuration(seconds: Int): String {&#10;    val minutes = seconds / 60&#10;    val remainingSeconds = seconds % 60&#10;    return if (minutes &gt; 0) {&#10;        &quot;${minutes}m ${remainingSeconds}s&quot;&#10;    } else {&#10;        &quot;${seconds}s&quot;&#10;    }&#10;}&#10;&#10;private fun parseDurationInput(input: String): Int {&#10;    // Remove all non-digit characters&#10;    val numericInput = input.filter { it.isDigit() }&#10;&#10;    return if (numericInput.isNotEmpty()) {&#10;        // Convert to seconds, assuming the input is in the format of &quot;XmYs&quot; or &quot;Xs&quot;&#10;        var totalSeconds = 0&#10;        var factor = 1&#10;        for (i in numericInput.length - 1 downTo 0) {&#10;            totalSeconds += (numericInput[i].digitToInt() * factor)&#10;            factor *= 10&#10;        }&#10;        totalSeconds&#10;    } else {&#10;        0&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.boardgametimer.ui.components&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material.icons.filled.KeyboardArrowDown&#10;import androidx.compose.material.icons.filled.KeyboardArrowUp&#10;import androidx.compose.material.icons.filled.Remove&#10;import androidx.compose.material.icons.filled.SwapVert&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.KeyboardType&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.window.Dialog&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.SavedConfiguration&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun OptionsDialog(&#10;    gameConfiguration: GameConfiguration,&#10;    savedConfigurations: List&lt;SavedConfiguration&gt; = emptyList(),&#10;    onConfigurationChanged: (GameConfiguration) -&gt; Unit,&#10;    onSaveConfiguration: (String, GameConfiguration) -&gt; Unit = { _, _ -&gt; },&#10;    onLoadConfiguration: (SavedConfiguration) -&gt; Unit = {},&#10;    onDeleteConfiguration: (String) -&gt; Unit = {},&#10;    onDismiss: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    var tempConfig by remember { mutableStateOf(gameConfiguration) }&#10;    var playerNames by remember {&#10;        mutableStateOf(&#10;            List(tempConfig.numberOfPlayers) { index -&gt;&#10;                if (index &lt; tempConfig.playerNames.size) tempConfig.playerNames[index] else &quot;&quot;&#10;            }&#10;        )&#10;    }&#10;    var saveConfigName by remember { mutableStateOf(&quot;&quot;) }&#10;    var showSaveDialog by remember { mutableStateOf(false) }&#10;&#10;    Dialog(onDismissRequest = onDismiss) {&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .fillMaxHeight(0.9f)&#10;                .padding(4.dp), // Reduced padding from 16dp to 8dp for wider dialog&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 8.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(16.dp)&#10;            ) {&#10;                // Header&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Game Options&quot;,&#10;                        fontSize = 20.sp,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                    IconButton(onClick = onDismiss) {&#10;                        Icon(Icons.Default.Close, contentDescription = &quot;Close&quot;)&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                LazyColumn(&#10;                    modifier = Modifier.weight(1f),&#10;                    verticalArrangement = Arrangement.spacedBy(16.dp)&#10;                ) {&#10;                    // Saved Configurations&#10;                    if (savedConfigurations.isNotEmpty()) {&#10;                        item {&#10;                            Card(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;                            ) {&#10;                                Column(modifier = Modifier.padding(16.dp)) {&#10;                                    Text(&#10;                                        text = &quot;Saved Configurations&quot;,&#10;                                        fontWeight = FontWeight.Medium,&#10;                                        fontSize = 16.sp&#10;                                    )&#10;                                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                                    savedConfigurations.forEach { savedConfig -&gt;&#10;                                        Row(&#10;                                            modifier = Modifier&#10;                                                .fillMaxWidth()&#10;                                                .padding(vertical = 4.dp),&#10;                                            horizontalArrangement = Arrangement.SpaceBetween,&#10;                                            verticalAlignment = Alignment.CenterVertically&#10;                                        ) {&#10;                                            Column(modifier = Modifier.weight(1f)) {&#10;                                                Text(&#10;                                                    text = savedConfig.name,&#10;                                                    fontWeight = FontWeight.Medium&#10;                                                )&#10;                                                Text(&#10;                                                    text = &quot;${savedConfig.configuration.numberOfPlayers} players, ${formatDuration(savedConfig.configuration.turnDurationSeconds)}&quot;,&#10;                                                    fontSize = 12.sp,&#10;                                                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)&#10;                                                )&#10;                                            }&#10;                                            Row {&#10;                                                TextButton(&#10;                                                    onClick = {&#10;                                                        onLoadConfiguration(savedConfig)&#10;                                                        tempConfig = savedConfig.configuration&#10;                                                        playerNames = List(savedConfig.configuration.numberOfPlayers) { index -&gt;&#10;                                                            if (index &lt; savedConfig.configuration.playerNames.size) {&#10;                                                                savedConfig.configuration.playerNames[index]&#10;                                                            } else &quot;&quot;&#10;                                                        }&#10;                                                    }&#10;                                                ) {&#10;                                                    Text(&quot;Load&quot;)&#10;                                                }&#10;                                                IconButton(&#10;                                                    onClick = { onDeleteConfiguration(savedConfig.name) }&#10;                                                ) {&#10;                                                    Icon(&#10;                                                        Icons.Default.Delete,&#10;                                                        contentDescription = &quot;Delete&quot;,&#10;                                                        tint = MaterialTheme.colorScheme.error&#10;                                                    )&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                        HorizontalDivider()&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    item {&#10;                        // Number of Players&#10;                        Card(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;                        ) {&#10;                            Column(modifier = Modifier.padding(16.dp)) {&#10;                                Text(&#10;                                    text = &quot;Number of Players&quot;,&#10;                                    fontWeight = FontWeight.Medium,&#10;                                    fontSize = 16.sp&#10;                                )&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;                                Row(&#10;                                    verticalAlignment = Alignment.CenterVertically,&#10;                                    horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;                                ) {&#10;                                    IconButton(&#10;                                        onClick = {&#10;                                            if (tempConfig.numberOfPlayers &gt; 2) {&#10;                                                tempConfig = tempConfig.copy(numberOfPlayers = tempConfig.numberOfPlayers - 1)&#10;                                                playerNames = playerNames.dropLast(1)&#10;                                            }&#10;                                        }&#10;                                    ) {&#10;                                        Icon(Icons.Default.Remove, contentDescription = &quot;Decrease players&quot;)&#10;                                    }&#10;&#10;                                    Text(&#10;                                        text = tempConfig.numberOfPlayers.toString(),&#10;                                        fontSize = 18.sp,&#10;                                        fontWeight = FontWeight.Bold&#10;                                    )&#10;&#10;                                    IconButton(&#10;                                        onClick = {&#10;                                            if (tempConfig.numberOfPlayers &lt; 15) {&#10;                                                tempConfig = tempConfig.copy(numberOfPlayers = tempConfig.numberOfPlayers + 1)&#10;                                                playerNames = playerNames + &quot;&quot;&#10;                                            }&#10;                                        }&#10;                                    ) {&#10;                                        Icon(Icons.Default.Add, contentDescription = &quot;Increase players&quot;)&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    item {&#10;                        // Turn Phases Configuration (replaces Turn Duration)&#10;                        Card(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;                        ) {&#10;                            Column(modifier = Modifier.padding(16.dp)) {&#10;                                Row(&#10;                                    modifier = Modifier.fillMaxWidth(),&#10;                                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                                    verticalAlignment = Alignment.CenterVertically&#10;                                ) {&#10;                                    Text(&#10;                                        text = &quot;Round Configuration&quot;,&#10;                                        fontWeight = FontWeight.Medium,&#10;                                        fontSize = 16.sp&#10;                                    )&#10;&#10;                                    IconButton(&#10;                                        onClick = {&#10;                                            val newPhases = tempConfig.turnPhases + com.example.boardgametimer.model.TurnPhase(&quot;Phase ${tempConfig.turnPhases.size + 1}&quot;, 60)&#10;                                            tempConfig = tempConfig.copy(turnPhases = newPhases)&#10;                                        }&#10;                                    ) {&#10;                                        Icon(Icons.Default.Add, contentDescription = &quot;Add Phase&quot;)&#10;                                    }&#10;                                }&#10;&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                                // Display each phase&#10;                                tempConfig.turnPhases.forEachIndexed { index, phase -&gt;&#10;                                    Card(&#10;                                        modifier = Modifier&#10;                                            .fillMaxWidth()&#10;                                            .padding(vertical = 4.dp),&#10;                                        colors = CardDefaults.cardColors(&#10;                                            containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;                                        )&#10;                                    ) {&#10;                                        Column(modifier = Modifier.padding(12.dp)) {&#10;                                            Row(&#10;                                                modifier = Modifier.fillMaxWidth(),&#10;                                                horizontalArrangement = Arrangement.SpaceBetween,&#10;                                                verticalAlignment = Alignment.CenterVertically&#10;                                            ) {&#10;                                                Text(&#10;                                                    text = &quot;Phase ${index + 1}&quot;,&#10;                                                    fontWeight = FontWeight.Medium&#10;                                                )&#10;&#10;                                                if (tempConfig.turnPhases.size &gt; 1) {&#10;                                                    IconButton(&#10;                                                        onClick = {&#10;                                                            val newPhases = tempConfig.turnPhases.toMutableList()&#10;                                                            newPhases.removeAt(index)&#10;                                                            tempConfig = tempConfig.copy(turnPhases = newPhases)&#10;                                                        }&#10;                                                    ) {&#10;                                                        Icon(Icons.Default.Delete, contentDescription = &quot;Delete Phase&quot;)&#10;                                                    }&#10;                                                }&#10;                                            }&#10;&#10;                                            // Phase name input&#10;                                            OutlinedTextField(&#10;                                                value = phase.name,&#10;                                                onValueChange = { newName -&gt;&#10;                                                    val newPhases = tempConfig.turnPhases.toMutableList()&#10;                                                    newPhases[index] = phase.copy(name = newName)&#10;                                                    tempConfig = tempConfig.copy(turnPhases = newPhases)&#10;                                                },&#10;                                                label = { Text(&quot;Phase Name&quot;) },&#10;                                                modifier = Modifier.fillMaxWidth()&#10;                                            )&#10;&#10;                                            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                                            // Predefined time options for phase&#10;                                            Text(&#10;                                                text = &quot;Quick Select:&quot;,&#10;                                                fontSize = 14.sp,&#10;                                                fontWeight = FontWeight.Medium&#10;                                            )&#10;                                            Spacer(modifier = Modifier.height(4.dp))&#10;&#10;                                            val timeOptions = listOf(30, 60, 90, 120, 180, 300, 600) // seconds&#10;                                            val timeLabels = listOf(&quot;30s&quot;, &quot;1m&quot;, &quot;1.5m&quot;, &quot;2m&quot;, &quot;3m&quot;, &quot;5m&quot;, &quot;10m&quot;)&#10;&#10;                                            LazyRow(&#10;                                                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                                            ) {&#10;                                                items(timeOptions.size) { timeIndex -&gt;&#10;                                                    FilterChip(&#10;                                                        onClick = {&#10;                                                            val newPhases = tempConfig.turnPhases.toMutableList()&#10;                                                            newPhases[index] = phase.copy(durationSeconds = timeOptions[timeIndex])&#10;                                                            tempConfig = tempConfig.copy(turnPhases = newPhases)&#10;                                                        },&#10;                                                        label = { Text(timeLabels[timeIndex]) },&#10;                                                        selected = phase.durationSeconds == timeOptions[timeIndex]&#10;                                                    )&#10;                                                }&#10;                                            }&#10;&#10;                                            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                                            // Phase duration with original minus button and slightly wider plus button&#10;                                            Row(&#10;                                                modifier = Modifier.fillMaxWidth(),&#10;                                                verticalAlignment = Alignment.CenterVertically,&#10;                                                horizontalArrangement = Arrangement.SpaceBetween&#10;                                            ) {&#10;                                                Text(&#10;                                                    text = &quot;Duration:&quot;,&#10;                                                    fontSize = 14.sp,&#10;                                                    fontWeight = FontWeight.Medium&#10;                                                )&#10;&#10;                                                Row(&#10;                                                    verticalAlignment = Alignment.CenterVertically,&#10;                                                    horizontalArrangement = Arrangement.spacedBy(0.dp) // No gap&#10;                                                ) {&#10;                                                    // Original minus button (IconButton)&#10;                                                    IconButton(&#10;                                                        onClick = {&#10;                                                            if (phase.durationSeconds &gt; 10) {&#10;                                                                val newPhases = tempConfig.turnPhases.toMutableList()&#10;                                                                newPhases[index] = phase.copy(durationSeconds = phase.durationSeconds - 10)&#10;                                                                tempConfig = tempConfig.copy(turnPhases = newPhases)&#10;                                                            }&#10;                                                        }&#10;                                                    ) {&#10;                                                        Icon(Icons.Default.Remove, contentDescription = &quot;Decrease duration&quot;)&#10;                                                    }&#10;&#10;                                                    Text(&#10;                                                        text = &quot;${phase.durationSeconds / 60}:${String.format(&quot;%02d&quot;, phase.durationSeconds % 60)}&quot;,&#10;                                                        fontWeight = FontWeight.Bold,&#10;                                                        fontSize = 16.sp,&#10;                                                        modifier = Modifier.widthIn(min = 60.dp)&#10;                                                    )&#10;&#10;                                                    // Plus button without any extra padding or Box wrapper&#10;                                                    IconButton(&#10;                                                        onClick = {&#10;                                                            if (phase.durationSeconds &lt; 600) {&#10;                                                                val newPhases = tempConfig.turnPhases.toMutableList()&#10;                                                                newPhases[index] = phase.copy(durationSeconds = phase.durationSeconds + 10)&#10;                                                                tempConfig = tempConfig.copy(turnPhases = newPhases)&#10;                                                            }&#10;                                                        }&#10;                                                    ) {&#10;                                                        Icon(Icons.Default.Add, contentDescription = &quot;Increase duration&quot;)&#10;                                                    }&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    item {&#10;                        // Player Names&#10;                        Card(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;                        ) {&#10;                            Column(modifier = Modifier.padding(16.dp)) {&#10;                                Row(&#10;                                    modifier = Modifier.fillMaxWidth(),&#10;                                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                                    verticalAlignment = Alignment.CenterVertically&#10;                                ) {&#10;                                    Text(&#10;                                        text = &quot;Player Names (Optional)&quot;,&#10;                                        fontWeight = FontWeight.Medium,&#10;                                        fontSize = 16.sp&#10;                                    )&#10;                                    // Flip/Reorder button&#10;                                    IconButton(&#10;                                        onClick = {&#10;                                            playerNames = playerNames.reversed()&#10;                                        }&#10;                                    ) {&#10;                                        Icon(&#10;                                            imageVector = Icons.Default.SwapVert,&#10;                                            contentDescription = &quot;Reverse player order&quot;&#10;                                        )&#10;                                    }&#10;                                }&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                                repeat(tempConfig.numberOfPlayers) { index -&gt;&#10;                                    Row(&#10;                                        modifier = Modifier.fillMaxWidth(),&#10;                                        verticalAlignment = Alignment.CenterVertically&#10;                                    ) {&#10;                                        // Move up button&#10;                                        IconButton(&#10;                                            onClick = {&#10;                                                if (index &gt; 0) {&#10;                                                    val newNames = playerNames.toMutableList()&#10;                                                    val temp = newNames[index]&#10;                                                    newNames[index] = newNames[index - 1]&#10;                                                    newNames[index - 1] = temp&#10;                                                    playerNames = newNames&#10;                                                }&#10;                                            },&#10;                                            enabled = index &gt; 0&#10;                                        ) {&#10;                                            Icon(&#10;                                                imageVector = Icons.Default.KeyboardArrowUp,&#10;                                                contentDescription = &quot;Move up&quot;&#10;                                            )&#10;                                        }&#10;&#10;                                        // Player name text field&#10;                                        OutlinedTextField(&#10;                                            value = if (index &lt; playerNames.size) playerNames[index] else &quot;&quot;,&#10;                                            onValueChange = { newName -&gt;&#10;                                                val updatedNames = playerNames.toMutableList()&#10;                                                while (updatedNames.size &lt;= index) {&#10;                                                    updatedNames.add(&quot;&quot;)&#10;                                                }&#10;                                                updatedNames[index] = newName&#10;                                                playerNames = updatedNames&#10;                                            },&#10;                                            label = { Text(&quot;Player ${index + 1}&quot;) },&#10;                                            modifier = Modifier&#10;                                                .weight(1f)&#10;                                                .padding(horizontal = 4.dp),&#10;                                            singleLine = true&#10;                                        )&#10;&#10;                                        // Move down button&#10;                                        IconButton(&#10;                                            onClick = {&#10;                                                if (index &lt; tempConfig.numberOfPlayers - 1) {&#10;                                                    val newNames = playerNames.toMutableList()&#10;                                                    val temp = newNames[index]&#10;                                                    newNames[index] = newNames[index + 1]&#10;                                                    newNames[index + 1] = temp&#10;                                                    playerNames = newNames&#10;                                                }&#10;                                            },&#10;                                            enabled = index &lt; tempConfig.numberOfPlayers - 1&#10;                                        ) {&#10;                                            Icon(&#10;                                                imageVector = Icons.Default.KeyboardArrowDown,&#10;                                                contentDescription = &quot;Move down&quot;&#10;                                            )&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    item {&#10;                        // Audio Alerts&#10;                        Card(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;                        ) {&#10;                            Column(modifier = Modifier.padding(16.dp)) {&#10;                                Text(&#10;                                    text = &quot;Audio Alerts&quot;,&#10;                                    fontWeight = FontWeight.Medium,&#10;                                    fontSize = 16.sp&#10;                                )&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                                CheckboxOption(&#10;                                    text = &quot;60 seconds remaining&quot;,&#10;                                    checked = tempConfig.audioAlert60s,&#10;                                    onCheckedChange = { tempConfig = tempConfig.copy(audioAlert60s = it) }&#10;                                )&#10;&#10;                                CheckboxOption(&#10;                                    text = &quot;30 seconds remaining&quot;,&#10;                                    checked = tempConfig.audioAlert30s,&#10;                                    onCheckedChange = { tempConfig = tempConfig.copy(audioAlert30s = it) }&#10;                                )&#10;&#10;                                CheckboxOption(&#10;                                    text = &quot;10 second countdown&quot;,&#10;                                    checked = tempConfig.audioAlert10sCountdown,&#10;                                    onCheckedChange = { tempConfig = tempConfig.copy(audioAlert10sCountdown = it) }&#10;                                )&#10;&#10;                                CheckboxOption(&#10;                                    text = &quot;Time out alert&quot;,&#10;                                    checked = tempConfig.audioAlertTimeOut,&#10;                                    onCheckedChange = { tempConfig = tempConfig.copy(audioAlertTimeOut = it) }&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    item {&#10;                        // Other Options&#10;                        Card(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;                        ) {&#10;                            Column(modifier = Modifier.padding(16.dp)) {&#10;                                Text(&#10;                                    text = &quot;Other Options&quot;,&#10;                                    fontWeight = FontWeight.Medium,&#10;                                    fontSize = 16.sp&#10;                                )&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                                CheckboxOption(&#10;                                    text = &quot;Vibrate on alerts&quot;,&#10;                                    checked = tempConfig.vibrateOnAlerts,&#10;                                    onCheckedChange = { tempConfig = tempConfig.copy(vibrateOnAlerts = it) }&#10;                                )&#10;&#10;                                CheckboxOption(&#10;                                    text = &quot;Keep counter alignment fixed&quot;,&#10;                                    checked = tempConfig.keepCounterAlignmentFixed,&#10;                                    onCheckedChange = { tempConfig = tempConfig.copy(keepCounterAlignmentFixed = it) }&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                // Action Buttons&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    // Save Configuration Button&#10;                    OutlinedButton(&#10;                        onClick = { showSaveDialog = true },&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;Save Config&quot;)&#10;                    }&#10;&#10;                    // Apply Button&#10;                    Button(&#10;                        onClick = {&#10;                            val finalConfig = tempConfig.copy(playerNames = playerNames.filter { it.isNotBlank() })&#10;                            onConfigurationChanged(finalConfig)&#10;                            onDismiss()&#10;                        },&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;Apply&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Save Configuration Dialog&#10;    if (showSaveDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showSaveDialog = false },&#10;            title = { Text(&quot;Save Configuration&quot;) },&#10;            text = {&#10;                OutlinedTextField(&#10;                    value = saveConfigName,&#10;                    onValueChange = { saveConfigName = it },&#10;                    label = { Text(&quot;Configuration Name&quot;) },&#10;                    singleLine = true&#10;                )&#10;            },&#10;            confirmButton = {&#10;                TextButton(&#10;                    onClick = {&#10;                        if (saveConfigName.isNotBlank()) {&#10;                            val finalConfig = tempConfig.copy(playerNames = playerNames.filter { it.isNotBlank() })&#10;                            onSaveConfiguration(saveConfigName, finalConfig)&#10;                            // Don't apply the configuration when saving - just save it&#10;                            showSaveDialog = false&#10;                            saveConfigName = &quot;&quot;&#10;                        }&#10;                    }&#10;                ) {&#10;                    Text(&quot;Save&quot;)&#10;                }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { showSaveDialog = false }) {&#10;                    Text(&quot;Cancel&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun CheckboxOption(&#10;    text: String,&#10;    checked: Boolean,&#10;    onCheckedChange: (Boolean) -&gt; Unit&#10;) {&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp),&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        Checkbox(&#10;            checked = checked,&#10;            onCheckedChange = onCheckedChange&#10;        )&#10;        Spacer(modifier = Modifier.width(8.dp))&#10;        Text(text = text)&#10;    }&#10;}&#10;&#10;private fun formatDuration(seconds: Int): String {&#10;    val minutes = seconds / 60&#10;    val remainingSeconds = seconds % 60&#10;    return if (minutes &gt; 0) {&#10;        &quot;${minutes}m ${remainingSeconds}s&quot;&#10;    } else {&#10;        &quot;${seconds}s&quot;&#10;    }&#10;}&#10;&#10;private fun parseDurationInput(input: String): Int {&#10;    // Remove all non-digit characters&#10;    val numericInput = input.filter { it.isDigit() }&#10;&#10;    return if (numericInput.isNotEmpty()) {&#10;        // Convert to seconds, assuming the input is in the format of &quot;XmYs&quot; or &quot;Xs&quot;&#10;        var totalSeconds = 0&#10;        var factor = 1&#10;        for (i in numericInput.length - 1 downTo 0) {&#10;            totalSeconds += (numericInput[i].digitToInt() * factor)&#10;            factor *= 10&#10;        }&#10;        totalSeconds&#10;    } else {&#10;        0&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/ui/components/TimeExpiredDialog.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/ui/components/TimeExpiredDialog.kt" />
              <option name="updatedContent" value="package com.example.boardgametimer.ui.components&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.window.Dialog&#10;import com.example.boardgametimer.model.GameConfiguration&#10;&#10;@Composable&#10;fun TimeExpiredDialog(&#10;    currentPlayerIndex: Int,&#10;    gameConfiguration: GameConfiguration,&#10;    onDismiss: () -&gt; Unit,&#10;    onNextPlayer: () -&gt; Unit&#10;) {&#10;    Dialog(onDismissRequest = onDismiss) {&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 8.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;⏰ TIME'S UP! ⏰&quot;,&#10;                    fontSize = 24.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = MaterialTheme.colorScheme.error,&#10;                    textAlign = TextAlign.Center&#10;                )&#10;                &#10;                Text(&#10;                    text = &quot;${gameConfiguration.getPlayerName(currentPlayerIndex)} ran out of time!&quot;,&#10;                    fontSize = 18.sp,&#10;                    textAlign = TextAlign.Center,&#10;                    modifier = Modifier.padding(vertical = 8.dp)&#10;                )&#10;                &#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    OutlinedButton(&#10;                        onClick = onDismiss,&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;Continue Turn&quot;)&#10;                    }&#10;                    &#10;                    Button(&#10;                        onClick = {&#10;                            onNextPlayer()&#10;                            onDismiss()&#10;                        },&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;Next Player&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModel.kt" />
              <option name="originalContent" value="package com.example.boardgametimer.viewmodel&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.media.AudioManager&#10;import android.media.ToneGenerator&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.speech.tts.TextToSpeech&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.GameState&#10;import com.example.boardgametimer.model.SavedConfiguration&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.util.Locale&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;&#10;class GameTimerViewModel : ViewModel() {&#10;&#10;    var gameState by mutableStateOf(GameState())&#10;        private set&#10;&#10;    var gameConfiguration by mutableStateOf(GameConfiguration())&#10;        private set&#10;&#10;    var showOptions by mutableStateOf(false)&#10;        private set&#10;&#10;    var showStats by mutableStateOf(false)&#10;        private set&#10;&#10;    var undoHistory by mutableStateOf&lt;GameState?&gt;(null)&#10;        private set&#10;&#10;    var savedConfigurations by mutableStateOf&lt;List&lt;SavedConfiguration&gt;&gt;(emptyList())&#10;        private set&#10;&#10;    private var timerJob: Job? = null&#10;    private var toneGenerator: ToneGenerator? = null&#10;    private var vibrator: Vibrator? = null&#10;    private var textToSpeech: TextToSpeech? = null&#10;    private var ttsReady = false&#10;    private var sharedPreferences: SharedPreferences? = null&#10;    private val gson = Gson()&#10;&#10;    fun initializeAudio(context: Context) {&#10;        toneGenerator = ToneGenerator(AudioManager.STREAM_NOTIFICATION, 100)&#10;&#10;        // Use modern vibrator API&#10;        vibrator = if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.S) {&#10;            val vibratorManager = context.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            vibratorManager.defaultVibrator&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;&#10;        textToSpeech = TextToSpeech(context) { status -&gt;&#10;            if (status == TextToSpeech.SUCCESS) {&#10;                textToSpeech?.language = Locale.getDefault()&#10;                ttsReady = true&#10;            }&#10;        }&#10;&#10;        // Initialize SharedPreferences for saving configurations&#10;        sharedPreferences = context.getSharedPreferences(&quot;BoardGameTimer&quot;, Context.MODE_PRIVATE)&#10;        loadSavedConfigurations()&#10;    }&#10;&#10;    fun startNewGame() {&#10;        val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;        gameState = GameState(&#10;            currentPlayerIndex = 0,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            isGameRunning = true,&#10;            isPaused = false, // Start ready to play, not paused&#10;            roundCount = 0,&#10;            playerTurnTimes = playerTurnTimes,&#10;            gameStartTime = System.currentTimeMillis(),&#10;            turnStartTime = System.currentTimeMillis()&#10;        )&#10;        startTimer() // Auto-start the timer for the first player&#10;    }&#10;&#10;    fun nextPlayer() {&#10;        if (!gameState.isGameRunning) return&#10;&#10;        // Play a beep sound when passing turn&#10;        playTurnPassBeep()&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        // Record the time taken for current player's turn&#10;        val timeTaken = gameConfiguration.turnDurationSeconds - gameState.timeRemainingSeconds&#10;        val currentPlayerTimes = gameState.playerTurnTimes[gameState.currentPlayerIndex].toMutableList()&#10;        currentPlayerTimes.add(timeTaken)&#10;&#10;        val updatedPlayerTurnTimes = gameState.playerTurnTimes.toMutableList()&#10;        updatedPlayerTurnTimes[gameState.currentPlayerIndex] = currentPlayerTimes&#10;&#10;        val nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameConfiguration.numberOfPlayers&#10;        val newRoundCount = if (nextPlayerIndex == 0) gameState.roundCount + 1 else gameState.roundCount&#10;&#10;        gameState = gameState.copy(&#10;            currentPlayerIndex = nextPlayerIndex,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            playerTurnTimes = updatedPlayerTurnTimes,&#10;            roundCount = newRoundCount,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = false // Don't pause after each player switch&#10;        )&#10;&#10;        // Auto-start timer for next player&#10;        startTimer()&#10;    }&#10;&#10;    fun undoLastAction() {&#10;        undoHistory?.let { previousState -&gt;&#10;            gameState = previousState&#10;            undoHistory = null&#10;            if (gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun pauseResumeGame() {&#10;        if (gameState.isGameRunning) {&#10;            gameState = gameState.copy(isPaused = !gameState.isPaused)&#10;            if (gameState.isPaused) {&#10;                timerJob?.cancel()&#10;            } else {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun endGame() {&#10;        timerJob?.cancel()&#10;        gameState = gameState.copy(isGameRunning = false, isPaused = false)&#10;        showStats = true&#10;    }&#10;&#10;    private fun startTimer() {&#10;        timerJob?.cancel()&#10;        timerJob = viewModelScope.launch {&#10;            var lastUpdateTime = System.currentTimeMillis()&#10;            var lastSecond = gameState.timeRemainingSeconds&#10;&#10;            while (gameState.timeRemainingMillis &gt; 0 &amp;&amp; gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                delay(16) // Update every 16ms for smooth animation (~60fps)&#10;&#10;                val currentTime = System.currentTimeMillis()&#10;                val deltaTime = currentTime - lastUpdateTime&#10;                lastUpdateTime = currentTime&#10;&#10;                val newTimeMillis = (gameState.timeRemainingMillis - deltaTime).coerceAtLeast(0L)&#10;                val newTimeSeconds = (newTimeMillis / 1000).toInt()&#10;&#10;                gameState = gameState.copy(&#10;                    timeRemainingMillis = newTimeMillis,&#10;                    timeRemainingSeconds = newTimeSeconds&#10;                )&#10;&#10;                // Handle audio alerts (only on second changes)&#10;                if (newTimeSeconds != lastSecond) {&#10;                    lastSecond = newTimeSeconds&#10;                    when (newTimeSeconds) {&#10;                        60 -&gt; if (gameConfiguration.audioAlert60s) playAlert()&#10;                        30 -&gt; if (gameConfiguration.audioAlert30s) playAlert()&#10;                        10, 9, 8, 7, 6, 5, 4, 3, 2, 1 -&gt; {&#10;                            if (gameConfiguration.audioAlert10sCountdown) {&#10;                                speakCountdown(newTimeSeconds)&#10;                            }&#10;                        }&#10;                        0 -&gt; {&#10;                            // Handle timeout with enhanced functionality&#10;                            handlePlayerTimeout()&#10;                            break&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handlePlayerTimeout() {&#10;        // Play timeout alert if enabled&#10;        if (gameConfiguration.audioAlertTimeOut) {&#10;            playAlert()&#10;        }&#10;&#10;        // Announce timeout with text-to-speech if enabled&#10;        if (gameConfiguration.audioAlertTimeOut &amp;&amp; ttsReady) {&#10;            val playerName = gameConfiguration.getPlayerName(gameState.currentPlayerIndex)&#10;            textToSpeech?.speak(&quot;$playerName ran out of time!&quot;, TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;&#10;        // Pause the game and show timeout dialog&#10;        gameState = gameState.copy(&#10;            isPaused = true,&#10;            showTimeExpiredDialog = true&#10;        )&#10;    }&#10;&#10;    fun dismissTimeExpiredDialog() {&#10;        gameState = gameState.copy(showTimeExpiredDialog = false)&#10;    }&#10;&#10;    fun continueAfterTimeout() {&#10;        // Reset timer to full duration and resume game&#10;        gameState = gameState.copy(&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            isPaused = false,&#10;            showTimeExpiredDialog = false&#10;        )&#10;        startTimer()&#10;    }&#10;&#10;    private fun playAlert() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_CDMA_ALERT_CALL_GUARD, 200)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun playTurnPassBeep() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_PROP_BEEP, 150)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun speakCountdown(seconds: Int) {&#10;        if (ttsReady) {&#10;            textToSpeech?.speak(seconds.toString(), TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    fun updateConfiguration(newConfig: GameConfiguration) {&#10;        gameConfiguration = newConfig&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(newConfig.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = newConfig.turnDurationSeconds,&#10;                timeRemainingMillis = newConfig.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun saveConfiguration(name: String) {&#10;        if (name.isBlank()) return&#10;&#10;        val newConfig = SavedConfiguration(name, gameConfiguration)&#10;        val updatedConfigs = savedConfigurations.toMutableList()&#10;&#10;        // Remove existing config with same name&#10;        updatedConfigs.removeAll { it.name == name }&#10;        updatedConfigs.add(newConfig)&#10;&#10;        savedConfigurations = updatedConfigs&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    fun loadConfiguration(savedConfig: SavedConfiguration) {&#10;        gameConfiguration = savedConfig.configuration&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;                timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun deleteConfiguration(configName: String) {&#10;        savedConfigurations = savedConfigurations.filter { it.name != configName }&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    private fun loadSavedConfigurations() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = prefs.getString(&quot;saved_configurations&quot;, &quot;[]&quot;)&#10;            val type = object : TypeToken&lt;List&lt;SavedConfiguration&gt;&gt;() {}.type&#10;            try {&#10;                savedConfigurations = gson.fromJson(json, type) ?: emptyList()&#10;            } catch (e: Exception) {&#10;                savedConfigurations = emptyList()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveToPersistentStorage() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = gson.toJson(savedConfigurations)&#10;            prefs.edit().putString(&quot;saved_configurations&quot;, json).apply()&#10;        }&#10;    }&#10;&#10;    fun showOptions() {&#10;        showOptions = true&#10;    }&#10;&#10;    fun hideOptions() {&#10;        showOptions = false&#10;    }&#10;&#10;    fun hideStats() {&#10;        showStats = false&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        toneGenerator?.release()&#10;        textToSpeech?.shutdown()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.boardgametimer.viewmodel&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.media.AudioManager&#10;import android.media.ToneGenerator&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.speech.tts.TextToSpeech&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.GameState&#10;import com.example.boardgametimer.model.SavedConfiguration&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.util.Locale&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;&#10;class GameTimerViewModel : ViewModel() {&#10;&#10;    var gameState by mutableStateOf(GameState())&#10;        private set&#10;&#10;    var gameConfiguration by mutableStateOf(GameConfiguration())&#10;        private set&#10;&#10;    var showOptions by mutableStateOf(false)&#10;        private set&#10;&#10;    var showStats by mutableStateOf(false)&#10;        private set&#10;&#10;    var undoHistory by mutableStateOf&lt;GameState?&gt;(null)&#10;        private set&#10;&#10;    var savedConfigurations by mutableStateOf&lt;List&lt;SavedConfiguration&gt;&gt;(emptyList())&#10;        private set&#10;&#10;    private var timerJob: Job? = null&#10;    private var toneGenerator: ToneGenerator? = null&#10;    private var vibrator: Vibrator? = null&#10;    private var textToSpeech: TextToSpeech? = null&#10;    private var ttsReady = false&#10;    private var sharedPreferences: SharedPreferences? = null&#10;    private val gson = Gson()&#10;&#10;    fun initializeAudio(context: Context) {&#10;        toneGenerator = ToneGenerator(AudioManager.STREAM_NOTIFICATION, 100)&#10;&#10;        // Use modern vibrator API&#10;        vibrator = if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.S) {&#10;            val vibratorManager = context.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            vibratorManager.defaultVibrator&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;&#10;        textToSpeech = TextToSpeech(context) { status -&gt;&#10;            if (status == TextToSpeech.SUCCESS) {&#10;                textToSpeech?.language = Locale.getDefault()&#10;                ttsReady = true&#10;            }&#10;        }&#10;&#10;        // Initialize SharedPreferences for saving configurations&#10;        sharedPreferences = context.getSharedPreferences(&quot;BoardGameTimer&quot;, Context.MODE_PRIVATE)&#10;        loadSavedConfigurations()&#10;    }&#10;&#10;    fun startNewGame() {&#10;        val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;        val firstPhaseDuration = gameConfiguration.getCurrentPhaseDuration(0)&#10;        gameState = GameState(&#10;            currentPlayerIndex = 0,&#10;            currentPhaseIndex = 0, // Start with first phase&#10;            timeRemainingSeconds = firstPhaseDuration,&#10;            timeRemainingMillis = firstPhaseDuration * 1000L,&#10;            isGameRunning = true,&#10;            isPaused = false, // Start ready to play, not paused&#10;            roundCount = 0,&#10;            playerTurnTimes = playerTurnTimes,&#10;            gameStartTime = System.currentTimeMillis(),&#10;            turnStartTime = System.currentTimeMillis()&#10;        )&#10;        startTimer() // Auto-start the timer for the first player&#10;    }&#10;&#10;    fun nextPlayer() {&#10;        if (!gameState.isGameRunning) return&#10;&#10;        // Check if we need to advance to next phase or next player&#10;        val nextPhaseIndex = gameState.currentPhaseIndex + 1&#10;        val totalPhases = gameConfiguration.getTotalPhases()&#10;&#10;        if (nextPhaseIndex &lt; totalPhases) {&#10;            // Move to next phase for same player&#10;            nextPhase()&#10;        } else {&#10;            // Move to next player (reset to first phase)&#10;            moveToNextPlayer()&#10;        }&#10;    }&#10;&#10;    private fun nextPhase() {&#10;        // Play a beep sound when passing to next phase&#10;        playTurnPassBeep()&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        val nextPhaseIndex = gameState.currentPhaseIndex + 1&#10;        val phaseDuration = gameConfiguration.getCurrentPhaseDuration(nextPhaseIndex)&#10;&#10;        gameState = gameState.copy(&#10;            currentPhaseIndex = nextPhaseIndex,&#10;            timeRemainingSeconds = phaseDuration,&#10;            timeRemainingMillis = phaseDuration * 1000L,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = false&#10;        )&#10;&#10;        // Auto-start timer for next phase&#10;        startTimer()&#10;    }&#10;&#10;    private fun moveToNextPlayer() {&#10;        // Play a beep sound when passing turn&#10;        playTurnPassBeep()&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        // Record the time taken for current player's turn (only record when completing all phases)&#10;        val timeTaken = gameConfiguration.getCurrentPhaseDuration(gameState.currentPhaseIndex) - gameState.timeRemainingSeconds&#10;        val currentPlayerTimes = gameState.playerTurnTimes[gameState.currentPlayerIndex].toMutableList()&#10;        currentPlayerTimes.add(timeTaken)&#10;&#10;        val updatedPlayerTurnTimes = gameState.playerTurnTimes.toMutableList()&#10;        updatedPlayerTurnTimes[gameState.currentPlayerIndex] = currentPlayerTimes&#10;&#10;        val nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameConfiguration.numberOfPlayers&#10;        val newRoundCount = if (nextPlayerIndex == 0) gameState.roundCount + 1 else gameState.roundCount&#10;        val firstPhaseDuration = gameConfiguration.getCurrentPhaseDuration(0)&#10;&#10;        gameState = gameState.copy(&#10;            currentPlayerIndex = nextPlayerIndex,&#10;            currentPhaseIndex = 0, // Reset to first phase for new player&#10;            timeRemainingSeconds = firstPhaseDuration,&#10;            timeRemainingMillis = firstPhaseDuration * 1000L,&#10;            playerTurnTimes = updatedPlayerTurnTimes,&#10;            roundCount = newRoundCount,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = false&#10;        )&#10;&#10;        // Auto-start timer for next player&#10;        startTimer()&#10;    }&#10;&#10;    fun undoLastAction() {&#10;        undoHistory?.let { previousState -&gt;&#10;            gameState = previousState&#10;            undoHistory = null&#10;            if (gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun pauseResumeGame() {&#10;        if (gameState.isGameRunning) {&#10;            gameState = gameState.copy(isPaused = !gameState.isPaused)&#10;            if (gameState.isPaused) {&#10;                timerJob?.cancel()&#10;            } else {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun endGame() {&#10;        timerJob?.cancel()&#10;        gameState = gameState.copy(isGameRunning = false, isPaused = false)&#10;        showStats = true&#10;    }&#10;&#10;    private fun startTimer() {&#10;        timerJob?.cancel()&#10;        timerJob = viewModelScope.launch {&#10;            var lastUpdateTime = System.currentTimeMillis()&#10;            var lastSecond = gameState.timeRemainingSeconds&#10;&#10;            while (gameState.timeRemainingMillis &gt; 0 &amp;&amp; gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                delay(16) // Update every 16ms for smooth animation (~60fps)&#10;&#10;                val currentTime = System.currentTimeMillis()&#10;                val deltaTime = currentTime - lastUpdateTime&#10;                lastUpdateTime = currentTime&#10;&#10;                val newTimeMillis = (gameState.timeRemainingMillis - deltaTime).coerceAtLeast(0L)&#10;                val newTimeSeconds = (newTimeMillis / 1000).toInt()&#10;&#10;                gameState = gameState.copy(&#10;                    timeRemainingMillis = newTimeMillis,&#10;                    timeRemainingSeconds = newTimeSeconds&#10;                )&#10;&#10;                // Handle audio alerts (only on second changes)&#10;                if (newTimeSeconds != lastSecond) {&#10;                    lastSecond = newTimeSeconds&#10;                    when (newTimeSeconds) {&#10;                        60 -&gt; if (gameConfiguration.audioAlert60s) playAlert()&#10;                        30 -&gt; if (gameConfiguration.audioAlert30s) playAlert()&#10;                        10, 9, 8, 7, 6, 5, 4, 3, 2, 1 -&gt; {&#10;                            if (gameConfiguration.audioAlert10sCountdown) {&#10;                                speakCountdown(newTimeSeconds)&#10;                            }&#10;                        }&#10;                        0 -&gt; {&#10;                            // Handle timeout with enhanced functionality&#10;                            handlePlayerTimeout()&#10;                            break&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handlePlayerTimeout() {&#10;        // Play timeout alert if enabled&#10;        if (gameConfiguration.audioAlertTimeOut) {&#10;            playAlert()&#10;        }&#10;&#10;        // Announce timeout with text-to-speech if enabled&#10;        if (gameConfiguration.audioAlertTimeOut &amp;&amp; ttsReady) {&#10;            val playerName = gameConfiguration.getPlayerName(gameState.currentPlayerIndex)&#10;            textToSpeech?.speak(&quot;$playerName ran out of time!&quot;, TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;&#10;        // Pause the game and show timeout dialog&#10;        gameState = gameState.copy(&#10;            isPaused = true,&#10;            showTimeExpiredDialog = true&#10;        )&#10;    }&#10;&#10;    fun dismissTimeExpiredDialog() {&#10;        gameState = gameState.copy(showTimeExpiredDialog = false)&#10;    }&#10;&#10;    fun continueAfterTimeout() {&#10;        // Reset timer to full duration and resume game&#10;        gameState = gameState.copy(&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            isPaused = false,&#10;            showTimeExpiredDialog = false&#10;        )&#10;        startTimer()&#10;    }&#10;&#10;    private fun playAlert() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_CDMA_ALERT_CALL_GUARD, 200)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun playTurnPassBeep() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_PROP_BEEP, 150)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun speakCountdown(seconds: Int) {&#10;        if (ttsReady) {&#10;            textToSpeech?.speak(seconds.toString(), TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    fun updateConfiguration(newConfig: GameConfiguration) {&#10;        gameConfiguration = newConfig&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(newConfig.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = newConfig.turnDurationSeconds,&#10;                timeRemainingMillis = newConfig.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun saveConfiguration(name: String) {&#10;        if (name.isBlank()) return&#10;&#10;        val newConfig = SavedConfiguration(name, gameConfiguration)&#10;        val updatedConfigs = savedConfigurations.toMutableList()&#10;&#10;        // Remove existing config with same name&#10;        updatedConfigs.removeAll { it.name == name }&#10;        updatedConfigs.add(newConfig)&#10;&#10;        savedConfigurations = updatedConfigs&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    fun loadConfiguration(savedConfig: SavedConfiguration) {&#10;        gameConfiguration = savedConfig.configuration&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;                timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun deleteConfiguration(configName: String) {&#10;        savedConfigurations = savedConfigurations.filter { it.name != configName }&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    private fun loadSavedConfigurations() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = prefs.getString(&quot;saved_configurations&quot;, &quot;[]&quot;)&#10;            val type = object : TypeToken&lt;List&lt;SavedConfiguration&gt;&gt;() {}.type&#10;            try {&#10;                savedConfigurations = gson.fromJson(json, type) ?: emptyList()&#10;            } catch (e: Exception) {&#10;                savedConfigurations = emptyList()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveToPersistentStorage() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = gson.toJson(savedConfigurations)&#10;            prefs.edit().putString(&quot;saved_configurations&quot;, json).apply()&#10;        }&#10;    }&#10;&#10;    fun showOptions() {&#10;        showOptions = true&#10;    }&#10;&#10;    fun hideOptions() {&#10;        showOptions = false&#10;    }&#10;&#10;    fun hideStats() {&#10;        showStats = false&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        toneGenerator?.release()&#10;        textToSpeech?.shutdown()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModelNew.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModelNew.kt" />
              <option name="updatedContent" value="package com.example.boardgametimer.viewmodel&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.media.AudioManager&#10;import android.media.ToneGenerator&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.speech.tts.TextToSpeech&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.GameState&#10;import com.example.boardgametimer.model.SavedConfiguration&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.util.Locale&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;&#10;class GameTimerViewModel : ViewModel() {&#10;&#10;    var gameState by mutableStateOf(GameState())&#10;        private set&#10;&#10;    var gameConfiguration by mutableStateOf(GameConfiguration())&#10;        private set&#10;&#10;    var showOptions by mutableStateOf(false)&#10;        private set&#10;&#10;    var showStats by mutableStateOf(false)&#10;        private set&#10;&#10;    var undoHistory by mutableStateOf&lt;GameState?&gt;(null)&#10;        private set&#10;&#10;    var savedConfigurations by mutableStateOf&lt;List&lt;SavedConfiguration&gt;&gt;(emptyList())&#10;        private set&#10;&#10;    private var timerJob: Job? = null&#10;    private var toneGenerator: ToneGenerator? = null&#10;    private var vibrator: Vibrator? = null&#10;    private var textToSpeech: TextToSpeech? = null&#10;    private var ttsReady = false&#10;    private var sharedPreferences: SharedPreferences? = null&#10;    private val gson = Gson()&#10;&#10;    fun initializeAudio(context: Context) {&#10;        toneGenerator = ToneGenerator(AudioManager.STREAM_NOTIFICATION, 100)&#10;&#10;        // Use modern vibrator API&#10;        vibrator = if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.S) {&#10;            val vibratorManager = context.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            vibratorManager.defaultVibrator&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;&#10;        textToSpeech = TextToSpeech(context) { status -&gt;&#10;            if (status == TextToSpeech.SUCCESS) {&#10;                textToSpeech?.language = Locale.getDefault()&#10;                ttsReady = true&#10;            }&#10;        }&#10;&#10;        // Initialize SharedPreferences for saving configurations&#10;        sharedPreferences = context.getSharedPreferences(&quot;BoardGameTimer&quot;, Context.MODE_PRIVATE)&#10;        loadSavedConfigurations()&#10;    }&#10;&#10;    fun startNewGame() {&#10;        val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;        gameState = GameState(&#10;            currentPlayerIndex = 0,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            isGameRunning = true,&#10;            isPaused = true, // Start paused&#10;            roundCount = 0,&#10;            playerTurnTimes = playerTurnTimes,&#10;            gameStartTime = System.currentTimeMillis(),&#10;            turnStartTime = System.currentTimeMillis()&#10;        )&#10;        // Don't start timer automatically - wait for user to resume&#10;    }&#10;&#10;    fun nextPlayer() {&#10;        if (!gameState.isGameRunning) return&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        // Record the time taken for current player's turn&#10;        val timeTaken = gameConfiguration.turnDurationSeconds - gameState.timeRemainingSeconds&#10;        val currentPlayerTimes = gameState.playerTurnTimes[gameState.currentPlayerIndex].toMutableList()&#10;        currentPlayerTimes.add(timeTaken)&#10;&#10;        val updatedPlayerTurnTimes = gameState.playerTurnTimes.toMutableList()&#10;        updatedPlayerTurnTimes[gameState.currentPlayerIndex] = currentPlayerTimes&#10;&#10;        val nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameConfiguration.numberOfPlayers&#10;        val newRoundCount = if (nextPlayerIndex == 0) gameState.roundCount + 1 else gameState.roundCount&#10;&#10;        gameState = gameState.copy(&#10;            currentPlayerIndex = nextPlayerIndex,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            playerTurnTimes = updatedPlayerTurnTimes,&#10;            roundCount = newRoundCount,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = true // Pause after each player switch&#10;        )&#10;&#10;        // Don't auto-start timer - let user resume manually&#10;    }&#10;&#10;    fun undoLastAction() {&#10;        undoHistory?.let { previousState -&gt;&#10;            gameState = previousState&#10;            undoHistory = null&#10;            if (gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun pauseResumeGame() {&#10;        if (gameState.isGameRunning) {&#10;            gameState = gameState.copy(isPaused = !gameState.isPaused)&#10;            if (gameState.isPaused) {&#10;                timerJob?.cancel()&#10;            } else {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun endGame() {&#10;        timerJob?.cancel()&#10;        gameState = gameState.copy(isGameRunning = false, isPaused = false)&#10;        showStats = true&#10;    }&#10;&#10;    private fun startTimer() {&#10;        timerJob?.cancel()&#10;        timerJob = viewModelScope.launch {&#10;            var lastUpdateTime = System.currentTimeMillis()&#10;            var lastSecond = gameState.timeRemainingSeconds&#10;            &#10;            while (gameState.timeRemainingMillis &gt; 0 &amp;&amp; gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                delay(16) // Update every 16ms for smooth animation (~60fps)&#10;                &#10;                val currentTime = System.currentTimeMillis()&#10;                val deltaTime = currentTime - lastUpdateTime&#10;                lastUpdateTime = currentTime&#10;                &#10;                val newTimeMillis = (gameState.timeRemainingMillis - deltaTime).coerceAtLeast(0L)&#10;                val newTimeSeconds = (newTimeMillis / 1000).toInt()&#10;                &#10;                gameState = gameState.copy(&#10;                    timeRemainingMillis = newTimeMillis,&#10;                    timeRemainingSeconds = newTimeSeconds&#10;                )&#10;&#10;                // Handle audio alerts (only on second changes)&#10;                if (newTimeSeconds != lastSecond) {&#10;                    lastSecond = newTimeSeconds&#10;                    when (newTimeSeconds) {&#10;                        60 -&gt; if (gameConfiguration.audioAlert60s) playAlert()&#10;                        30 -&gt; if (gameConfiguration.audioAlert30s) playAlert()&#10;                        10, 9, 8, 7, 6, 5, 4, 3, 2, 1 -&gt; {&#10;                            if (gameConfiguration.audioAlert10sCountdown) {&#10;                                speakCountdown(newTimeSeconds)&#10;                            }&#10;                        }&#10;                        0 -&gt; {&#10;                            if (gameConfiguration.audioAlertTimeOut) playAlert()&#10;                            break&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun playAlert() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_CDMA_ALERT_CALL_GUARD, 200)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun speakCountdown(seconds: Int) {&#10;        if (ttsReady) {&#10;            textToSpeech?.speak(seconds.toString(), TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    fun updateConfiguration(newConfig: GameConfiguration) {&#10;        gameConfiguration = newConfig&#10;        // Reset game state with new configuration&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(newConfig.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = newConfig.turnDurationSeconds,&#10;                timeRemainingMillis = newConfig.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = true&#10;            )&#10;        }&#10;    }&#10;&#10;    fun saveConfiguration(name: String) {&#10;        if (name.isBlank()) return&#10;        &#10;        val newConfig = SavedConfiguration(name, gameConfiguration)&#10;        val updatedConfigs = savedConfigurations.toMutableList()&#10;        &#10;        // Remove existing config with same name&#10;        updatedConfigs.removeAll { it.name == name }&#10;        updatedConfigs.add(newConfig)&#10;        &#10;        savedConfigurations = updatedConfigs&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    fun loadConfiguration(savedConfig: SavedConfiguration) {&#10;        gameConfiguration = savedConfig.configuration&#10;        // Reset game state with new configuration&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;                timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = true&#10;            )&#10;        }&#10;    }&#10;&#10;    fun deleteConfiguration(configName: String) {&#10;        savedConfigurations = savedConfigurations.filter { it.name != configName }&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    private fun loadSavedConfigurations() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = prefs.getString(&quot;saved_configurations&quot;, &quot;[]&quot;)&#10;            val type = object : TypeToken&lt;List&lt;SavedConfiguration&gt;&gt;() {}.type&#10;            try {&#10;                savedConfigurations = gson.fromJson(json, type) ?: emptyList()&#10;            } catch (e: Exception) {&#10;                savedConfigurations = emptyList()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveToPersistentStorage() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = gson.toJson(savedConfigurations)&#10;            prefs.edit().putString(&quot;saved_configurations&quot;, json).apply()&#10;        }&#10;    }&#10;&#10;    fun showOptions() {&#10;        showOptions = true&#10;    }&#10;&#10;    fun hideOptions() {&#10;        showOptions = false&#10;    }&#10;&#10;    fun hideStats() {&#10;        showStats = false&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        toneGenerator?.release()&#10;        textToSpeech?.shutdown()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModel_Fixed.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModel_Fixed.kt" />
              <option name="updatedContent" value="package com.example.boardgametimer.viewmodel&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.media.AudioManager&#10;import android.media.ToneGenerator&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.speech.tts.TextToSpeech&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.GameState&#10;import com.example.boardgametimer.model.SavedConfiguration&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.util.Locale&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;&#10;class GameTimerViewModel : ViewModel() {&#10;&#10;    var gameState by mutableStateOf(GameState())&#10;        private set&#10;&#10;    var gameConfiguration by mutableStateOf(GameConfiguration())&#10;        private set&#10;&#10;    var showOptions by mutableStateOf(false)&#10;        private set&#10;&#10;    var showStats by mutableStateOf(false)&#10;        private set&#10;&#10;    var undoHistory by mutableStateOf&lt;GameState?&gt;(null)&#10;        private set&#10;&#10;    var savedConfigurations by mutableStateOf&lt;List&lt;SavedConfiguration&gt;&gt;(emptyList())&#10;        private set&#10;&#10;    private var timerJob: Job? = null&#10;    private var toneGenerator: ToneGenerator? = null&#10;    private var vibrator: Vibrator? = null&#10;    private var textToSpeech: TextToSpeech? = null&#10;    private var ttsReady = false&#10;    private var sharedPreferences: SharedPreferences? = null&#10;    private val gson = Gson()&#10;&#10;    fun initializeAudio(context: Context) {&#10;        toneGenerator = ToneGenerator(AudioManager.STREAM_NOTIFICATION, 100)&#10;&#10;        // Use modern vibrator API&#10;        vibrator = if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.S) {&#10;            val vibratorManager = context.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            vibratorManager.defaultVibrator&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;&#10;        textToSpeech = TextToSpeech(context) { status -&gt;&#10;            if (status == TextToSpeech.SUCCESS) {&#10;                textToSpeech?.language = Locale.getDefault()&#10;                ttsReady = true&#10;            }&#10;        }&#10;&#10;        // Initialize SharedPreferences for saving configurations&#10;        sharedPreferences = context.getSharedPreferences(&quot;BoardGameTimer&quot;, Context.MODE_PRIVATE)&#10;        loadSavedConfigurations()&#10;    }&#10;&#10;    fun startNewGame() {&#10;        val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;        gameState = GameState(&#10;            currentPlayerIndex = 0,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            isGameRunning = true,&#10;            isPaused = false, // Start ready to play, not paused&#10;            roundCount = 0,&#10;            playerTurnTimes = playerTurnTimes,&#10;            gameStartTime = System.currentTimeMillis(),&#10;            turnStartTime = System.currentTimeMillis()&#10;        )&#10;        startTimer() // Auto-start the timer for the first player&#10;    }&#10;&#10;    fun nextPlayer() {&#10;        if (!gameState.isGameRunning) return&#10;&#10;        // Play a beep sound when passing turn&#10;        playTurnPassBeep()&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        // Record the time taken for current player's turn&#10;        val timeTaken = gameConfiguration.turnDurationSeconds - gameState.timeRemainingSeconds&#10;        val currentPlayerTimes = gameState.playerTurnTimes[gameState.currentPlayerIndex].toMutableList()&#10;        currentPlayerTimes.add(timeTaken)&#10;&#10;        val updatedPlayerTurnTimes = gameState.playerTurnTimes.toMutableList()&#10;        updatedPlayerTurnTimes[gameState.currentPlayerIndex] = currentPlayerTimes&#10;&#10;        val nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameConfiguration.numberOfPlayers&#10;        val newRoundCount = if (nextPlayerIndex == 0) gameState.roundCount + 1 else gameState.roundCount&#10;&#10;        gameState = gameState.copy(&#10;            currentPlayerIndex = nextPlayerIndex,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            playerTurnTimes = updatedPlayerTurnTimes,&#10;            roundCount = newRoundCount,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = false // Don't pause after each player switch&#10;        )&#10;&#10;        // Auto-start timer for next player&#10;        startTimer()&#10;    }&#10;&#10;    fun undoLastAction() {&#10;        undoHistory?.let { previousState -&gt;&#10;            gameState = previousState&#10;            undoHistory = null&#10;            if (gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun pauseResumeGame() {&#10;        if (gameState.isGameRunning) {&#10;            gameState = gameState.copy(isPaused = !gameState.isPaused)&#10;            if (gameState.isPaused) {&#10;                timerJob?.cancel()&#10;            } else {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun endGame() {&#10;        timerJob?.cancel()&#10;        gameState = gameState.copy(isGameRunning = false, isPaused = false)&#10;        showStats = true&#10;    }&#10;&#10;    private fun startTimer() {&#10;        timerJob?.cancel()&#10;        timerJob = viewModelScope.launch {&#10;            var lastUpdateTime = System.currentTimeMillis()&#10;            var lastSecond = gameState.timeRemainingSeconds&#10;&#10;            while (gameState.timeRemainingMillis &gt; 0 &amp;&amp; gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                delay(16) // Update every 16ms for smooth animation (~60fps)&#10;&#10;                val currentTime = System.currentTimeMillis()&#10;                val deltaTime = currentTime - lastUpdateTime&#10;                lastUpdateTime = currentTime&#10;&#10;                val newTimeMillis = (gameState.timeRemainingMillis - deltaTime).coerceAtLeast(0L)&#10;                val newTimeSeconds = (newTimeMillis / 1000).toInt()&#10;&#10;                gameState = gameState.copy(&#10;                    timeRemainingMillis = newTimeMillis,&#10;                    timeRemainingSeconds = newTimeSeconds&#10;                )&#10;&#10;                // Handle audio alerts (only on second changes)&#10;                if (newTimeSeconds != lastSecond) {&#10;                    lastSecond = newTimeSeconds&#10;                    when (newTimeSeconds) {&#10;                        60 -&gt; if (gameConfiguration.audioAlert60s) playAlert()&#10;                        30 -&gt; if (gameConfiguration.audioAlert30s) playAlert()&#10;                        10, 9, 8, 7, 6, 5, 4, 3, 2, 1 -&gt; {&#10;                            if (gameConfiguration.audioAlert10sCountdown) {&#10;                                speakCountdown(newTimeSeconds)&#10;                            }&#10;                        }&#10;                        0 -&gt; {&#10;                            if (gameConfiguration.audioAlertTimeOut) playAlert()&#10;                            break&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun playAlert() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_CDMA_ALERT_CALL_GUARD, 200)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun playTurnPassBeep() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_PROP_BEEP, 150)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun speakCountdown(seconds: Int) {&#10;        if (ttsReady) {&#10;            textToSpeech?.speak(seconds.toString(), TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    fun updateConfiguration(newConfig: GameConfiguration) {&#10;        gameConfiguration = newConfig&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(newConfig.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = newConfig.turnDurationSeconds,&#10;                timeRemainingMillis = newConfig.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun saveConfiguration(name: String) {&#10;        if (name.isBlank()) return&#10;&#10;        val newConfig = SavedConfiguration(name, gameConfiguration)&#10;        val updatedConfigs = savedConfigurations.toMutableList()&#10;&#10;        // Remove existing config with same name&#10;        updatedConfigs.removeAll { it.name == name }&#10;        updatedConfigs.add(newConfig)&#10;&#10;        savedConfigurations = updatedConfigs&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    fun loadConfiguration(savedConfig: SavedConfiguration) {&#10;        gameConfiguration = savedConfig.configuration&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;                timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun deleteConfiguration(configName: String) {&#10;        savedConfigurations = savedConfigurations.filter { it.name != configName }&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    private fun loadSavedConfigurations() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = prefs.getString(&quot;saved_configurations&quot;, &quot;[]&quot;)&#10;            val type = object : TypeToken&lt;List&lt;SavedConfiguration&gt;&gt;() {}.type&#10;            try {&#10;                savedConfigurations = gson.fromJson(json, type) ?: emptyList()&#10;            } catch (e: Exception) {&#10;                savedConfigurations = emptyList()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveToPersistentStorage() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = gson.toJson(savedConfigurations)&#10;            prefs.edit().putString(&quot;saved_configurations&quot;, json).apply()&#10;        }&#10;    }&#10;&#10;    fun showOptions() {&#10;        showOptions = true&#10;    }&#10;&#10;    fun hideOptions() {&#10;        showOptions = false&#10;    }&#10;&#10;    fun hideStats() {&#10;        showStats = false&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        toneGenerator?.release()&#10;        textToSpeech?.shutdown()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModel_updated.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModel_updated.kt" />
              <option name="updatedContent" value="package com.example.boardgametimer.viewmodel&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.media.AudioManager&#10;import android.media.ToneGenerator&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.speech.tts.TextToSpeech&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.GameState&#10;import com.example.boardgametimer.model.SavedConfiguration&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.util.Locale&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;&#10;class GameTimerViewModel : ViewModel() {&#10;&#10;    var gameState by mutableStateOf(GameState())&#10;        private set&#10;&#10;    var gameConfiguration by mutableStateOf(GameConfiguration())&#10;        private set&#10;&#10;    var showOptions by mutableStateOf(false)&#10;        private set&#10;&#10;    var showStats by mutableStateOf(false)&#10;        private set&#10;&#10;    var undoHistory by mutableStateOf&lt;GameState?&gt;(null)&#10;        private set&#10;&#10;    var savedConfigurations by mutableStateOf&lt;List&lt;SavedConfiguration&gt;&gt;(emptyList())&#10;        private set&#10;&#10;    private var timerJob: Job? = null&#10;    private var toneGenerator: ToneGenerator? = null&#10;    private var vibrator: Vibrator? = null&#10;    private var textToSpeech: TextToSpeech? = null&#10;    private var ttsReady = false&#10;    private var sharedPreferences: SharedPreferences? = null&#10;    private val gson = Gson()&#10;&#10;    fun initializeAudio(context: Context) {&#10;        toneGenerator = ToneGenerator(AudioManager.STREAM_NOTIFICATION, 100)&#10;&#10;        // Use modern vibrator API&#10;        vibrator = if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.S) {&#10;            val vibratorManager = context.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            vibratorManager.defaultVibrator&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;&#10;        textToSpeech = TextToSpeech(context) { status -&gt;&#10;            if (status == TextToSpeech.SUCCESS) {&#10;                textToSpeech?.language = Locale.getDefault()&#10;                ttsReady = true&#10;            }&#10;        }&#10;&#10;        // Initialize SharedPreferences for saving configurations&#10;        sharedPreferences = context.getSharedPreferences(&quot;BoardGameTimer&quot;, Context.MODE_PRIVATE)&#10;        loadSavedConfigurations()&#10;    }&#10;&#10;    fun startNewGame() {&#10;        val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;        gameState = GameState(&#10;            currentPlayerIndex = 0,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            isGameRunning = true,&#10;            isPaused = false, // Start ready to play, not paused&#10;            roundCount = 0,&#10;            playerTurnTimes = playerTurnTimes,&#10;            gameStartTime = System.currentTimeMillis(),&#10;            turnStartTime = System.currentTimeMillis()&#10;        )&#10;        startTimer() // Auto-start the timer for the first player&#10;    }&#10;&#10;    fun nextPlayer() {&#10;        if (!gameState.isGameRunning) return&#10;&#10;        // Play a beep sound when passing turn&#10;        playTurnPassBeep()&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        // Record the time taken for current player's turn&#10;        val timeTaken = gameConfiguration.turnDurationSeconds - gameState.timeRemainingSeconds&#10;        val currentPlayerTimes = gameState.playerTurnTimes[gameState.currentPlayerIndex].toMutableList()&#10;        currentPlayerTimes.add(timeTaken)&#10;&#10;        val updatedPlayerTurnTimes = gameState.playerTurnTimes.toMutableList()&#10;        updatedPlayerTurnTimes[gameState.currentPlayerIndex] = currentPlayerTimes&#10;&#10;        val nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameConfiguration.numberOfPlayers&#10;        val newRoundCount = if (nextPlayerIndex == 0) gameState.roundCount + 1 else gameState.roundCount&#10;&#10;        gameState = gameState.copy(&#10;            currentPlayerIndex = nextPlayerIndex,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            playerTurnTimes = updatedPlayerTurnTimes,&#10;            roundCount = newRoundCount,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = false // Don't pause after each player switch&#10;        )&#10;&#10;        // Auto-start timer for next player&#10;        startTimer()&#10;    }&#10;&#10;    fun undoLastAction() {&#10;        undoHistory?.let { previousState -&gt;&#10;            gameState = previousState&#10;            undoHistory = null&#10;            if (gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun pauseResumeGame() {&#10;        if (gameState.isGameRunning) {&#10;            gameState = gameState.copy(isPaused = !gameState.isPaused)&#10;            if (gameState.isPaused) {&#10;                timerJob?.cancel()&#10;            } else {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun endGame() {&#10;        timerJob?.cancel()&#10;        gameState = gameState.copy(isGameRunning = false, isPaused = false)&#10;        showStats = true&#10;    }&#10;&#10;    private fun startTimer() {&#10;        timerJob?.cancel()&#10;        timerJob = viewModelScope.launch {&#10;            var lastUpdateTime = System.currentTimeMillis()&#10;            var lastSecond = gameState.timeRemainingSeconds&#10;&#10;            while (gameState.timeRemainingMillis &gt; 0 &amp;&amp; gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                delay(16) // Update every 16ms for smooth animation (~60fps)&#10;&#10;                val currentTime = System.currentTimeMillis()&#10;                val deltaTime = currentTime - lastUpdateTime&#10;                lastUpdateTime = currentTime&#10;&#10;                val newTimeMillis = (gameState.timeRemainingMillis - deltaTime).coerceAtLeast(0L)&#10;                val newTimeSeconds = (newTimeMillis / 1000).toInt()&#10;&#10;                gameState = gameState.copy(&#10;                    timeRemainingMillis = newTimeMillis,&#10;                    timeRemainingSeconds = newTimeSeconds&#10;                )&#10;&#10;                // Handle audio alerts (only on second changes)&#10;                if (newTimeSeconds != lastSecond) {&#10;                    lastSecond = newTimeSeconds&#10;                    when (newTimeSeconds) {&#10;                        60 -&gt; if (gameConfiguration.audioAlert60s) playAlert()&#10;                        30 -&gt; if (gameConfiguration.audioAlert30s) playAlert()&#10;                        10, 9, 8, 7, 6, 5, 4, 3, 2, 1 -&gt; {&#10;                            if (gameConfiguration.audioAlert10sCountdown) {&#10;                                speakCountdown(newTimeSeconds)&#10;                            }&#10;                        }&#10;                        0 -&gt; {&#10;                            // Handle timeout with enhanced functionality&#10;                            handlePlayerTimeout()&#10;                            break&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handlePlayerTimeout() {&#10;        // Play timeout alert if enabled&#10;        if (gameConfiguration.audioAlertTimeOut) {&#10;            playAlert()&#10;        }&#10;        &#10;        // Announce timeout with text-to-speech if enabled&#10;        if (gameConfiguration.audioAlertTimeOut &amp;&amp; ttsReady) {&#10;            val playerName = gameConfiguration.getPlayerName(gameState.currentPlayerIndex)&#10;            textToSpeech?.speak(&quot;$playerName ran out of time!&quot;, TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;        &#10;        // Pause the game and show timeout dialog&#10;        gameState = gameState.copy(&#10;            isPaused = true,&#10;            showTimeExpiredDialog = true&#10;        )&#10;    }&#10;&#10;    fun dismissTimeExpiredDialog() {&#10;        gameState = gameState.copy(showTimeExpiredDialog = false)&#10;    }&#10;&#10;    fun continueAfterTimeout() {&#10;        // Reset timer to full duration and resume game&#10;        gameState = gameState.copy(&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            isPaused = false,&#10;            showTimeExpiredDialog = false&#10;        )&#10;        startTimer()&#10;    }&#10;&#10;    private fun playAlert() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_CDMA_ALERT_CALL_GUARD, 200)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun playTurnPassBeep() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_PROP_BEEP, 150)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun speakCountdown(seconds: Int) {&#10;        if (ttsReady) {&#10;            textToSpeech?.speak(seconds.toString(), TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    fun updateConfiguration(newConfig: GameConfiguration) {&#10;        gameConfiguration = newConfig&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(newConfig.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = newConfig.turnDurationSeconds,&#10;                timeRemainingMillis = newConfig.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun saveConfiguration(name: String) {&#10;        if (name.isBlank()) return&#10;&#10;        val newConfig = SavedConfiguration(name, gameConfiguration)&#10;        val updatedConfigs = savedConfigurations.toMutableList()&#10;&#10;        // Remove existing config with same name&#10;        updatedConfigs.removeAll { it.name == name }&#10;        updatedConfigs.add(newConfig)&#10;&#10;        savedConfigurations = updatedConfigs&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    fun loadConfiguration(savedConfig: SavedConfiguration) {&#10;        gameConfiguration = savedConfig.configuration&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;                timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun deleteConfiguration(configName: String) {&#10;        savedConfigurations = savedConfigurations.filter { it.name != configName }&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    private fun loadSavedConfigurations() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = prefs.getString(&quot;saved_configurations&quot;, &quot;[]&quot;)&#10;            val type = object : TypeToken&lt;List&lt;SavedConfiguration&gt;&gt;() {}.type&#10;            try {&#10;                savedConfigurations = gson.fromJson(json, type) ?: emptyList()&#10;            } catch (e: Exception) {&#10;                savedConfigurations = emptyList()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveToPersistentStorage() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = gson.toJson(savedConfigurations)&#10;            prefs.edit().putString(&quot;saved_configurations&quot;, json).apply()&#10;        }&#10;    }&#10;&#10;    fun showOptions() {&#10;        showOptions = true&#10;    }&#10;&#10;    fun hideOptions() {&#10;        showOptions = false&#10;    }&#10;&#10;    fun hideStats() {&#10;        showStats = false&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        toneGenerator?.release()&#10;        textToSpeech?.shutdown()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>