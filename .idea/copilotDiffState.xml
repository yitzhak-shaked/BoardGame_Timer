<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.BoardGameTimer&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.OptionsActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:label=&quot;Game Options&quot;&#10;            android:theme=&quot;@style/Theme.BoardGameTimer&quot; /&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.BoardGameTimer&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:screenOrientation=&quot;portrait&quot;&#10;            android:theme=&quot;@style/Theme.BoardGameTimer&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.OptionsActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:label=&quot;Game Options&quot;&#10;            android:screenOrientation=&quot;portrait&quot;&#10;            android:theme=&quot;@style/Theme.BoardGameTimer&quot; /&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/OptionsActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/OptionsActivity.kt" />
              <option name="originalContent" value="package com.example.boardgametimer&#10;&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material.icons.filled.KeyboardArrowDown&#10;import androidx.compose.material.icons.filled.KeyboardArrowUp&#10;import androidx.compose.material.icons.filled.Remove&#10;import androidx.compose.material.icons.filled.SwapVert&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.SavedConfiguration&#10;import com.example.boardgametimer.model.TurnPhase&#10;import com.example.boardgametimer.model.PhaseType&#10;import com.example.boardgametimer.model.DiceType&#10;import com.example.boardgametimer.ui.theme.BoardGameTimerTheme&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;import java.util.Locale&#10;import androidx.core.content.edit&#10;&#10;class OptionsActivity : ComponentActivity() {&#10;    private val gson = Gson()&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Get the current configuration from the intent&#10;        val configJson = intent.getStringExtra(&quot;gameConfiguration&quot;)&#10;        val currentConfig = if (configJson != null) {&#10;            gson.fromJson(configJson, GameConfiguration::class.java)&#10;        } else {&#10;            GameConfiguration()&#10;        }&#10;&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            BoardGameTimerTheme {&#10;                Surface(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    color = MaterialTheme.colorScheme.background&#10;                ) {&#10;                    OptionsScreen(&#10;                        initialConfiguration = currentConfig,&#10;                        onSave = { config -&gt;&#10;                            val resultIntent = Intent().apply {&#10;                                putExtra(&quot;gameConfiguration&quot;, gson.toJson(config))&#10;                            }&#10;                            setResult(RESULT_OK, resultIntent)&#10;                            finish()&#10;                        },&#10;                        onCancel = {&#10;                            setResult(RESULT_CANCELED)&#10;                            finish()&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun OptionsScreen(&#10;    initialConfiguration: GameConfiguration,&#10;    onSave: (GameConfiguration) -&gt; Unit,&#10;    onCancel: () -&gt; Unit&#10;) {&#10;    var tempConfig by remember { mutableStateOf(initialConfiguration) }&#10;    var playerNames by remember {&#10;        mutableStateOf(&#10;            List(tempConfig.numberOfPlayers) { index -&gt;&#10;                if (index &lt; tempConfig.playerNames.size) tempConfig.playerNames[index] else &quot;&quot;&#10;            }&#10;        )&#10;    }&#10;    var saveConfigName by remember { mutableStateOf(&quot;&quot;) }&#10;    var showSaveDialog by remember { mutableStateOf(false) }&#10;&#10;    // Load saved configurations (memoized to prevent recreation)&#10;    val context = LocalContext.current&#10;    val gson = remember { Gson() }&#10;    val prefs = remember { context.getSharedPreferences(&quot;BoardGameTimer&quot;, Context.MODE_PRIVATE) }&#10;&#10;    var savedConfigurations by remember {&#10;        mutableStateOf&lt;List&lt;SavedConfiguration&gt;&gt;(&#10;            try {&#10;                val json = prefs.getString(&quot;saved_configurations&quot;, &quot;[]&quot;)&#10;                gson.fromJson&lt;List&lt;SavedConfiguration&gt;&gt;(json, object : TypeToken&lt;List&lt;SavedConfiguration&gt;&gt;() {}.type) ?: emptyList&lt;SavedConfiguration&gt;()&#10;            } catch (_: Exception) {&#10;                emptyList&lt;SavedConfiguration&gt;()&#10;            }&#10;        )&#10;    }&#10;&#10;    // Memoize callbacks to prevent unnecessary recompositions&#10;    val saveConfigsToPrefs = remember {&#10;        { configs: List&lt;SavedConfiguration&gt; -&gt;&#10;            val json = gson.toJson(configs)&#10;            prefs.edit { putString(&quot;saved_configurations&quot;, json) }&#10;            savedConfigurations = configs&#10;        }&#10;    }&#10;&#10;    val onPlayerCountChange = remember {&#10;        { newCount: Int -&gt;&#10;            tempConfig = tempConfig.copy(numberOfPlayers = newCount)&#10;            playerNames = when {&#10;                newCount &gt; playerNames.size -&gt; playerNames + List(newCount - playerNames.size) { &quot;&quot; }&#10;                newCount &lt; playerNames.size -&gt; playerNames.take(newCount)&#10;                else -&gt; playerNames&#10;            }&#10;        }&#10;    }&#10;&#10;    val onPhasesChange = remember {&#10;        { newPhases: List&lt;TurnPhase&gt; -&gt;&#10;            tempConfig = tempConfig.copy(turnPhases = newPhases)&#10;        }&#10;    }&#10;&#10;    val onConfigChange = remember {&#10;        { newConfig: GameConfiguration -&gt;&#10;            tempConfig = newConfig&#10;        }&#10;    }&#10;&#10;    val onPlayerNamesChange = remember {&#10;        { newNames: List&lt;String&gt; -&gt;&#10;            playerNames = newNames&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Game Options&quot;) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onCancel) {&#10;                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = &quot;Back&quot;)&#10;                    }&#10;                },&#10;                actions = {&#10;                    // Add Save Config button to the top bar&#10;                    TextButton(onClick = { showSaveDialog = true }) {&#10;                        Text(&quot;SAVE CONFIG&quot;)&#10;                    }&#10;                    TextButton(&#10;                        onClick = {&#10;                            val finalConfig = tempConfig.copy(playerNames = playerNames.filter { it.isNotBlank() })&#10;                            onSave(finalConfig)&#10;                        }&#10;                    ) {&#10;                        Text(&quot;SAVE&quot;, fontWeight = FontWeight.Bold)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .padding(horizontal = 16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(12.dp),&#10;            contentPadding = PaddingValues(vertical = 8.dp)&#10;        ) {&#10;            // Saved Configurations - Only show if not empty&#10;            if (savedConfigurations.isNotEmpty()) {&#10;                item(&#10;                    key = &quot;saved_configs&quot;,&#10;                    contentType = &quot;saved_configs_card&quot;&#10;                ) {&#10;                    SavedConfigurationsCard(&#10;                        savedConfigurations = savedConfigurations,&#10;                        onLoadConfiguration = remember {&#10;                            { savedConfig: SavedConfiguration -&gt;&#10;                                tempConfig = savedConfig.configuration&#10;                                playerNames = List(savedConfig.configuration.numberOfPlayers) { index -&gt;&#10;                                    if (index &lt; savedConfig.configuration.playerNames.size) {&#10;                                        savedConfig.configuration.playerNames[index]&#10;                                    } else &quot;&quot;&#10;                                }&#10;                            }&#10;                        },&#10;                        onDeleteConfiguration = remember {&#10;                            { configName: String -&gt;&#10;                                val updatedConfigs = savedConfigurations.filter { it.name != configName }&#10;                                saveConfigsToPrefs(updatedConfigs)&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Number of Players&#10;            item(&#10;                key = &quot;player_count&quot;,&#10;                contentType = &quot;player_count_card&quot;&#10;            ) {&#10;                PlayerCountCard(&#10;                    numberOfPlayers = tempConfig.numberOfPlayers,&#10;                    onPlayerCountChange = onPlayerCountChange&#10;                )&#10;            }&#10;&#10;            // Round Configuration&#10;            item(&#10;                key = &quot;round_config&quot;,&#10;                contentType = &quot;round_config_card&quot;&#10;            ) {&#10;                RoundConfigurationCard(&#10;                    turnPhases = tempConfig.turnPhases,&#10;                    onPhasesChange = onPhasesChange&#10;                )&#10;            }&#10;&#10;            // Player Names&#10;            item(&#10;                key = &quot;player_names&quot;,&#10;                contentType = &quot;player_names_card&quot;&#10;            ) {&#10;                PlayerNamesCard(&#10;                    numberOfPlayers = tempConfig.numberOfPlayers,&#10;                    playerNames = playerNames,&#10;                    onPlayerNamesChange = onPlayerNamesChange&#10;                )&#10;            }&#10;&#10;            // Audio Alerts&#10;            item(&#10;                key = &quot;audio_alerts&quot;,&#10;                contentType = &quot;audio_alerts_card&quot;&#10;            ) {&#10;                AudioAlertsCard(&#10;                    config = tempConfig,&#10;                    onConfigChange = onConfigChange&#10;                )&#10;            }&#10;&#10;            // Other Options&#10;            item(&#10;                key = &quot;other_options&quot;,&#10;                contentType = &quot;other_options_card&quot;&#10;            ) {&#10;                OtherOptionsCard(&#10;                    config = tempConfig,&#10;                    onConfigChange = onConfigChange&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    // Save Configuration Dialog&#10;    if (showSaveDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showSaveDialog = false },&#10;            title = { Text(&quot;Save Configuration&quot;) },&#10;            text = {&#10;                OutlinedTextField(&#10;                    value = saveConfigName,&#10;                    onValueChange = { saveConfigName = it },&#10;                    label = { Text(&quot;Configuration Name&quot;) },&#10;                    singleLine = true&#10;                )&#10;            },&#10;            confirmButton = {&#10;                TextButton(&#10;                    onClick = {&#10;                        if (saveConfigName.isNotBlank()) {&#10;                            val finalConfig = tempConfig.copy(playerNames = playerNames.filter { it.isNotBlank() })&#10;                            val newSavedConfig = SavedConfiguration(saveConfigName, finalConfig)&#10;                            val updatedConfigs = savedConfigurations.toMutableList().apply {&#10;                                removeAll { it.name == saveConfigName }&#10;                                add(newSavedConfig)&#10;                            }&#10;                            saveConfigsToPrefs(updatedConfigs)&#10;                            showSaveDialog = false&#10;                            saveConfigName = &quot;&quot;&#10;                        }&#10;                    }&#10;                ) {&#10;                    Text(&quot;Save&quot;)&#10;                }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { showSaveDialog = false }) {&#10;                    Text(&quot;Cancel&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;// Separate composables for each card to improve performance&#10;@Composable&#10;private fun SavedConfigurationsCard(&#10;    savedConfigurations: List&lt;SavedConfiguration&gt;,&#10;    onLoadConfiguration: (SavedConfiguration) -&gt; Unit,&#10;    onDeleteConfiguration: (String) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Text(&#10;                text = &quot;Saved Configurations&quot;,&#10;                fontWeight = FontWeight.Medium,&#10;                fontSize = 18.sp&#10;            )&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            savedConfigurations.forEach { savedConfig -&gt;&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(vertical = 4.dp),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Column(modifier = Modifier.weight(1f)) {&#10;                        Text(&#10;                            text = savedConfig.name,&#10;                            fontWeight = FontWeight.Medium&#10;                        )&#10;                        Text(&#10;                            text = &quot;${savedConfig.configuration.numberOfPlayers} players, ${savedConfig.configuration.turnPhases.size} phases&quot;,&#10;                            fontSize = 12.sp,&#10;                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)&#10;                        )&#10;                    }&#10;                    Row {&#10;                        TextButton(onClick = { onLoadConfiguration(savedConfig) }) {&#10;                            Text(&quot;Load&quot;)&#10;                        }&#10;                        IconButton(onClick = { onDeleteConfiguration(savedConfig.name) }) {&#10;                            Icon(&#10;                                Icons.Default.Delete,&#10;                                contentDescription = &quot;Delete&quot;,&#10;                                tint = MaterialTheme.colorScheme.error&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                if (savedConfig != savedConfigurations.last()) {&#10;                    HorizontalDivider()&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun PlayerCountCard(&#10;    numberOfPlayers: Int,&#10;    onPlayerCountChange: (Int) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Text(&#10;                text = &quot;Number of Players&quot;,&#10;                fontWeight = FontWeight.Medium,&#10;                fontSize = 18.sp&#10;            )&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                horizontalArrangement = Arrangement.Center&#10;            ) {&#10;                IconButton(&#10;                    onClick = {&#10;                        if (numberOfPlayers &gt; 1) {&#10;                            onPlayerCountChange(numberOfPlayers - 1)&#10;                        }&#10;                    }&#10;                ) {&#10;                    Icon(Icons.Default.Remove, contentDescription = &quot;Decrease players&quot;)&#10;                }&#10;&#10;                Text(&#10;                    text = numberOfPlayers.toString(),&#10;                    fontSize = 24.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    modifier = Modifier.padding(horizontal = 32.dp)&#10;                )&#10;&#10;                IconButton(&#10;                    onClick = {&#10;                        if (numberOfPlayers &lt; 15) {&#10;                            onPlayerCountChange(numberOfPlayers + 1)&#10;                        }&#10;                    }&#10;                ) {&#10;                    Icon(Icons.Default.Add, contentDescription = &quot;Increase players&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun RoundConfigurationCard(&#10;    turnPhases: List&lt;TurnPhase&gt;,&#10;    onPhasesChange: (List&lt;TurnPhase&gt;) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;Round Configuration&quot;,&#10;                    fontWeight = FontWeight.Medium,&#10;                    fontSize = 18.sp&#10;                )&#10;&#10;                IconButton(&#10;                    onClick = {&#10;                        val newPhases = turnPhases + TurnPhase(&quot;Phase ${turnPhases.size + 1}&quot;, 60)&#10;                        onPhasesChange(newPhases)&#10;                    }&#10;                ) {&#10;                    Icon(Icons.Default.Add, contentDescription = &quot;Add Phase&quot;)&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // Use key for each phase to improve performance&#10;            turnPhases.forEachIndexed { index, phase -&gt;&#10;                key(index) {&#10;                    PhaseConfigCard(&#10;                        phase = phase,&#10;                        phaseIndex = index,&#10;                        canDelete = turnPhases.size &gt; 1,&#10;                        canMoveUp = index &gt; 0,&#10;                        canMoveDown = index &lt; turnPhases.size - 1,&#10;                        onPhaseChange = { newPhase -&gt;&#10;                            val newPhases = turnPhases.toMutableList()&#10;                            newPhases[index] = newPhase&#10;                            onPhasesChange(newPhases)&#10;                        },&#10;                        onDeletePhase = {&#10;                            val newPhases = turnPhases.toMutableList()&#10;                            newPhases.removeAt(index)&#10;                            onPhasesChange(newPhases)&#10;                        },&#10;                        onMovePhaseUp = {&#10;                            if (index &gt; 0) {&#10;                                val newPhases = turnPhases.toMutableList()&#10;                                val temp = newPhases[index]&#10;                                newPhases[index] = newPhases[index - 1]&#10;                                newPhases[index - 1] = temp&#10;                                onPhasesChange(newPhases)&#10;                            }&#10;                        },&#10;                        onMovePhaseDown = {&#10;                            if (index &lt; turnPhases.size - 1) {&#10;                                val newPhases = turnPhases.toMutableList()&#10;                                val temp = newPhases[index]&#10;                                newPhases[index] = newPhases[index + 1]&#10;                                newPhases[index + 1] = temp&#10;                                onPhasesChange(newPhases)&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun PhaseConfigCard(&#10;    phase: TurnPhase,&#10;    phaseIndex: Int,&#10;    canDelete: Boolean,&#10;    canMoveUp: Boolean,&#10;    canMoveDown: Boolean,&#10;    onPhaseChange: (TurnPhase) -&gt; Unit,&#10;    onDeletePhase: () -&gt; Unit,&#10;    onMovePhaseUp: () -&gt; Unit,&#10;    onMovePhaseDown: () -&gt; Unit&#10;) {&#10;    // Memoize expensive computations&#10;    val timeOptions = remember { listOf(0, 10, 15, 30, 45, 60, 90, 120, 180, 240, 300, 450, 600, 900, 1200) }&#10;    val timeLabels = remember { listOf(&quot;Wait&quot;, &quot;10s&quot;, &quot;15s&quot;, &quot;30s&quot;, &quot;45s&quot;, &quot;1m&quot;, &quot;1.5m&quot;, &quot;2m&quot;, &quot;3m&quot;, &quot;4m&quot;, &quot;5m&quot;, &quot;7.5m&quot;, &quot;10m&quot;, &quot;15m&quot;, &quot;20m&quot;) }&#10;    val formattedTime = remember(phase.durationSeconds) {&#10;        if (phase.durationSeconds == 0) &quot;Wait for press&quot;&#10;        else &quot;${phase.durationSeconds / 60}:${String.format(Locale.getDefault(), &quot;%02d&quot;, phase.durationSeconds % 60)}&quot;&#10;    }&#10;&#10;    // Memoize callbacks&#10;    val onNameChange = remember {&#10;        { newName: String -&gt;&#10;            onPhaseChange(phase.copy(name = newName))&#10;        }&#10;    }&#10;&#10;    val onDurationDecrease = remember {&#10;        {&#10;            if (phase.durationSeconds &gt; 0) {&#10;                val newDuration = if (phase.durationSeconds &lt;= 10) 0 else phase.durationSeconds - 10&#10;                onPhaseChange(phase.copy(durationSeconds = newDuration))&#10;            }&#10;        }&#10;    }&#10;&#10;    val onDurationIncrease = remember {&#10;        {&#10;            if (phase.durationSeconds &lt; 600) {&#10;                val newDuration = if (phase.durationSeconds == 0) 10 else phase.durationSeconds + 10&#10;                onPhaseChange(phase.copy(durationSeconds = newDuration))&#10;            }&#10;        }&#10;    }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;        )&#10;    ) {&#10;        Column(modifier = Modifier.padding(12.dp)) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Phase ${phaseIndex + 1}&quot;,&#10;                        fontWeight = FontWeight.Medium,&#10;                        fontSize = 16.sp&#10;                    )&#10;&#10;                    // Phase reordering buttons&#10;                    Row {&#10;                        IconButton(&#10;                            onClick = onMovePhaseUp,&#10;                            enabled = canMoveUp&#10;                        ) {&#10;                            Icon(&#10;                                Icons.Default.KeyboardArrowUp,&#10;                                contentDescription = &quot;Move phase up&quot;,&#10;                                tint = if (canMoveUp) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.onSurface.copy(alpha = 0.38f)&#10;                            )&#10;                        }&#10;&#10;                        IconButton(&#10;                            onClick = onMovePhaseDown,&#10;                            enabled = canMoveDown&#10;                        ) {&#10;                            Icon(&#10;                                Icons.Default.KeyboardArrowDown,&#10;                                contentDescription = &quot;Move phase down&quot;,&#10;                                tint = if (canMoveDown) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.onSurface.copy(alpha = 0.38f)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                if (canDelete) {&#10;                    IconButton(onClick = onDeletePhase) {&#10;                        Icon(Icons.Default.Delete, contentDescription = &quot;Delete Phase&quot;)&#10;                    }&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Phase name input&#10;            OutlinedTextField(&#10;                value = phase.name,&#10;                onValueChange = onNameChange,&#10;                label = { Text(&quot;Phase Name&quot;) },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                singleLine = true&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // Phase Type Selection&#10;            Text(&#10;                text = &quot;Phase Type:&quot;,&#10;                fontSize = 14.sp,&#10;                fontWeight = FontWeight.Medium&#10;            )&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                FilterChip(&#10;                    onClick = { onPhaseChange(phase.copy(phaseType = PhaseType.NORMAL)) },&#10;                    label = { Text(&quot;Normal&quot;) },&#10;                    selected = phase.phaseType == PhaseType.NORMAL,&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;                FilterChip(&#10;                    onClick = { onPhaseChange(phase.copy(phaseType = PhaseType.DICE_THROW)) },&#10;                    label = { Text(&quot;Dice Throw&quot;) },&#10;                    selected = phase.phaseType == PhaseType.DICE_THROW,&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;            }&#10;&#10;            // Dice Configuration (only show for dice throw phases)&#10;            if (phase.phaseType == PhaseType.DICE_THROW) {&#10;                Spacer(modifier = Modifier.height(12.dp))&#10;&#10;                Text(&#10;                    text = &quot;Dice Configuration:&quot;,&#10;                    fontSize = 14.sp,&#10;                    fontWeight = FontWeight.Medium&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                // Dice Count&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.SpaceBetween&#10;                ) {&#10;                    Text(text = &quot;Number of Dice:&quot;)&#10;&#10;                    Row(verticalAlignment = Alignment.CenterVertically) {&#10;                        IconButton(&#10;                            onClick = {&#10;                                if (phase.diceCount &gt; 1) {&#10;                                    onPhaseChange(phase.copy(diceCount = phase.diceCount - 1))&#10;                                }&#10;                            },&#10;                            enabled = phase.diceCount &gt; 1&#10;                        ) {&#10;                            Icon(Icons.Default.Remove, contentDescription = &quot;Decrease dice count&quot;)&#10;                        }&#10;&#10;                        Text(&#10;                            text = &quot;${phase.diceCount}&quot;,&#10;                            fontWeight = FontWeight.Bold,&#10;                            modifier = Modifier.widthIn(min = 40.dp),&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;&#10;                        IconButton(&#10;                            onClick = {&#10;                                if (phase.diceCount &lt; 10) {&#10;                                    onPhaseChange(phase.copy(diceCount = phase.diceCount + 1))&#10;                                }&#10;                            },&#10;                            enabled = phase.diceCount &lt; 10&#10;                        ) {&#10;                            Icon(Icons.Default.Add, contentDescription = &quot;Increase dice count&quot;)&#10;                        }&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                // Dice Type Selection&#10;                Text(text = &quot;Dice Type:&quot;)&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;&#10;                LazyRow(&#10;                    horizontalArrangement = Arrangement.spacedBy(6.dp)&#10;                ) {&#10;                    items(DiceType.values()) { diceType -&gt;&#10;                        FilterChip(&#10;                            onClick = { onPhaseChange(phase.copy(diceType = diceType)) },&#10;                            label = { Text(diceType.displayName) },&#10;                            selected = phase.diceType == diceType&#10;                        )&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                // Wait for Press Option&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.SpaceBetween&#10;                ) {&#10;                    Text(text = &quot;Wait for press to throw dice:&quot;)&#10;                    Switch(&#10;                        checked = phase.waitForPress,&#10;                        onCheckedChange = { onPhaseChange(phase.copy(waitForPress = it)) }&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            Text(&#10;                text = &quot;Quick Select:&quot;,&#10;                fontSize = 14.sp,&#10;                fontWeight = FontWeight.Medium&#10;            )&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Replace LazyRow with FlowRow for better performance&#10;            QuickSelectChips(&#10;                timeOptions = timeOptions,&#10;                timeLabels = timeLabels,&#10;                currentDuration = phase.durationSeconds,&#10;                onDurationSelect = { duration -&gt;&#10;                    onPhaseChange(phase.copy(durationSeconds = duration))&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // Duration controls&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                horizontalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                Text(&#10;                    text = &quot;Duration:&quot;,&#10;                    fontSize = 16.sp,&#10;                    fontWeight = FontWeight.Medium&#10;                )&#10;&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.spacedBy(4.dp)&#10;                ) {&#10;                    IconButton(onClick = onDurationDecrease) {&#10;                        Icon(Icons.Default.Remove, contentDescription = &quot;Decrease duration&quot;)&#10;                    }&#10;&#10;                    Text(&#10;                        text = formattedTime,&#10;                        fontWeight = FontWeight.Bold,&#10;                        fontSize = 18.sp,&#10;                        modifier = Modifier.widthIn(min = 80.dp),&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;&#10;                    IconButton(onClick = onDurationIncrease) {&#10;                        Icon(Icons.Default.Add, contentDescription = &quot;Increase duration&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun QuickSelectChips(&#10;    timeOptions: List&lt;Int&gt;,&#10;    timeLabels: List&lt;String&gt;,&#10;    currentDuration: Int,&#10;    onDurationSelect: (Int) -&gt; Unit&#10;) {&#10;    // Use horizontally scrollable LazyRow for better UX with many options&#10;    LazyRow(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        horizontalArrangement = Arrangement.spacedBy(6.dp),&#10;        contentPadding = PaddingValues(horizontal = 4.dp)&#10;    ) {&#10;        items(timeOptions.size) { index -&gt;&#10;            FilterChip(&#10;                onClick = { onDurationSelect(timeOptions[index]) },&#10;                label = { Text(timeLabels[index]) },&#10;                selected = currentDuration == timeOptions[index]&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun PlayerNamesCard(&#10;    numberOfPlayers: Int,&#10;    playerNames: List&lt;String&gt;,&#10;    onPlayerNamesChange: (List&lt;String&gt;) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;Player Names (Optional)&quot;,&#10;                    fontWeight = FontWeight.Medium,&#10;                    fontSize = 18.sp&#10;                )&#10;                IconButton(&#10;                    onClick = {&#10;                        onPlayerNamesChange(playerNames.reversed())&#10;                    }&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.SwapVert,&#10;                        contentDescription = &quot;Reverse player order&quot;&#10;                    )&#10;                }&#10;            }&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            repeat(numberOfPlayers) { index -&gt;&#10;                key(index) {&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(vertical = 2.dp), // Reduced padding&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        // Move up button&#10;                        IconButton(&#10;                            onClick = {&#10;                                if (index &gt; 0) {&#10;                                    val newNames = playerNames.toMutableList()&#10;                                    val temp = newNames[index]&#10;                                    newNames[index] = newNames[index - 1]&#10;                                    newNames[index - 1] = temp&#10;                                    onPlayerNamesChange(newNames)&#10;                                }&#10;                            },&#10;                            enabled = index &gt; 0&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.KeyboardArrowUp,&#10;                                contentDescription = &quot;Move up&quot;&#10;                            )&#10;                        }&#10;&#10;                        // Player name text field&#10;                        OutlinedTextField(&#10;                            value = if (index &lt; playerNames.size) playerNames[index] else &quot;&quot;,&#10;                            onValueChange = { newName -&gt;&#10;                                val updatedNames = playerNames.toMutableList()&#10;                                while (updatedNames.size &lt;= index) {&#10;                                    updatedNames.add(&quot;&quot;)&#10;                                }&#10;                                updatedNames[index] = newName&#10;                                onPlayerNamesChange(updatedNames)&#10;                            },&#10;                            label = { Text(&quot;Player ${index + 1}&quot;) },&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .padding(horizontal = 8.dp),&#10;                            singleLine = true&#10;                        )&#10;&#10;                        // Move down button&#10;                        IconButton(&#10;                            onClick = {&#10;                                if (index &lt; numberOfPlayers - 1) {&#10;                                    val newNames = playerNames.toMutableList()&#10;                                    val temp = newNames[index]&#10;                                    newNames[index] = newNames[index + 1]&#10;                                    newNames[index + 1] = temp&#10;                                    onPlayerNamesChange(newNames)&#10;                                }&#10;                            },&#10;                            enabled = index &lt; numberOfPlayers - 1&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.KeyboardArrowDown,&#10;                                contentDescription = &quot;Move down&quot;&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun AudioAlertsCard(&#10;    config: GameConfiguration,&#10;    onConfigChange: (GameConfiguration) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Text(&#10;                text = &quot;Audio Alerts&quot;,&#10;                fontWeight = FontWeight.Medium,&#10;                fontSize = 18.sp&#10;            )&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            OptionsCheckboxOption(&#10;                text = &quot;60 seconds remaining&quot;,&#10;                checked = config.audioAlert60s,&#10;                onCheckedChange = { onConfigChange(config.copy(audioAlert60s = it)) }&#10;            )&#10;&#10;            OptionsCheckboxOption(&#10;                text = &quot;30 seconds remaining&quot;,&#10;                checked = config.audioAlert30s,&#10;                onCheckedChange = { onConfigChange(config.copy(audioAlert30s = it)) }&#10;            )&#10;&#10;            OptionsCheckboxOption(&#10;                text = &quot;10 second countdown&quot;,&#10;                checked = config.audioAlert10sCountdown,&#10;                onCheckedChange = { onConfigChange(config.copy(audioAlert10sCountdown = it)) }&#10;            )&#10;&#10;            OptionsCheckboxOption(&#10;                text = &quot;Time out alert&quot;,&#10;                checked = config.audioAlertTimeOut,&#10;                onCheckedChange = { onConfigChange(config.copy(audioAlertTimeOut = it)) }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun OtherOptionsCard(&#10;    config: GameConfiguration,&#10;    onConfigChange: (GameConfiguration) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Text(&#10;                text = &quot;Other Options&quot;,&#10;                fontWeight = FontWeight.Medium,&#10;                fontSize = 18.sp&#10;            )&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            OptionsCheckboxOption(&#10;                text = &quot;Vibrate on alerts&quot;,&#10;                checked = config.vibrateOnAlerts,&#10;                onCheckedChange = { onConfigChange(config.copy(vibrateOnAlerts = it)) }&#10;            )&#10;&#10;            OptionsCheckboxOption(&#10;                text = &quot;Keep counter alignment fixed&quot;,&#10;                checked = config.keepCounterAlignmentFixed,&#10;                onCheckedChange = { onConfigChange(config.copy(keepCounterAlignmentFixed = it)) }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun OptionsCheckboxOption(&#10;    text: String,&#10;    checked: Boolean,&#10;    onCheckedChange: (Boolean) -&gt; Unit&#10;) {&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 6.dp),&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        Checkbox(&#10;            checked = checked,&#10;            onCheckedChange = onCheckedChange&#10;        )&#10;        Spacer(modifier = Modifier.width(12.dp))&#10;        Text(&#10;            text = text,&#10;            fontSize = 16.sp&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.boardgametimer&#10;&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material.icons.filled.KeyboardArrowDown&#10;import androidx.compose.material.icons.filled.KeyboardArrowUp&#10;import androidx.compose.material.icons.filled.Remove&#10;import androidx.compose.material.icons.filled.SwapVert&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.SavedConfiguration&#10;import com.example.boardgametimer.model.TurnPhase&#10;import com.example.boardgametimer.model.PhaseType&#10;import com.example.boardgametimer.model.DiceType&#10;import com.example.boardgametimer.ui.theme.BoardGameTimerTheme&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;import java.util.Locale&#10;import androidx.core.content.edit&#10;&#10;class OptionsActivity : ComponentActivity() {&#10;    private val gson = Gson()&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Get the current configuration from the intent&#10;        val configJson = intent.getStringExtra(&quot;gameConfiguration&quot;)&#10;        val currentConfig = if (configJson != null) {&#10;            gson.fromJson(configJson, GameConfiguration::class.java)&#10;        } else {&#10;            GameConfiguration()&#10;        }&#10;&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            BoardGameTimerTheme {&#10;                Surface(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    color = MaterialTheme.colorScheme.background&#10;                ) {&#10;                    OptionsScreen(&#10;                        initialConfiguration = currentConfig,&#10;                        onSave = { config -&gt;&#10;                            val resultIntent = Intent().apply {&#10;                                putExtra(&quot;gameConfiguration&quot;, gson.toJson(config))&#10;                            }&#10;                            setResult(RESULT_OK, resultIntent)&#10;                            finish()&#10;                        },&#10;                        onCancel = {&#10;                            setResult(RESULT_CANCELED)&#10;                            finish()&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun OptionsScreen(&#10;    initialConfiguration: GameConfiguration,&#10;    onSave: (GameConfiguration) -&gt; Unit,&#10;    onCancel: () -&gt; Unit&#10;) {&#10;    var tempConfig by remember { mutableStateOf(initialConfiguration) }&#10;    var playerNames by remember {&#10;        mutableStateOf(&#10;            List(tempConfig.numberOfPlayers) { index -&gt;&#10;                if (index &lt; tempConfig.playerNames.size) tempConfig.playerNames[index] else &quot;&quot;&#10;            }&#10;        )&#10;    }&#10;    var saveConfigName by remember { mutableStateOf(&quot;&quot;) }&#10;    var showSaveDialog by remember { mutableStateOf(false) }&#10;&#10;    // Load saved configurations (memoized to prevent recreation)&#10;    val context = LocalContext.current&#10;    val gson = remember { Gson() }&#10;    val prefs = remember { context.getSharedPreferences(&quot;BoardGameTimer&quot;, Context.MODE_PRIVATE) }&#10;&#10;    var savedConfigurations by remember {&#10;        mutableStateOf&lt;List&lt;SavedConfiguration&gt;&gt;(&#10;            try {&#10;                val json = prefs.getString(&quot;saved_configurations&quot;, &quot;[]&quot;)&#10;                gson.fromJson&lt;List&lt;SavedConfiguration&gt;&gt;(json, object : TypeToken&lt;List&lt;SavedConfiguration&gt;&gt;() {}.type) ?: emptyList&lt;SavedConfiguration&gt;()&#10;            } catch (_: Exception) {&#10;                emptyList&lt;SavedConfiguration&gt;()&#10;            }&#10;        )&#10;    }&#10;&#10;    // Memoize callbacks to prevent unnecessary recompositions&#10;    val saveConfigsToPrefs = remember {&#10;        { configs: List&lt;SavedConfiguration&gt; -&gt;&#10;            val json = gson.toJson(configs)&#10;            prefs.edit { putString(&quot;saved_configurations&quot;, json) }&#10;            savedConfigurations = configs&#10;        }&#10;    }&#10;&#10;    val onPlayerCountChange = remember {&#10;        { newCount: Int -&gt;&#10;            tempConfig = tempConfig.copy(numberOfPlayers = newCount)&#10;            playerNames = when {&#10;                newCount &gt; playerNames.size -&gt; playerNames + List(newCount - playerNames.size) { &quot;&quot; }&#10;                newCount &lt; playerNames.size -&gt; playerNames.take(newCount)&#10;                else -&gt; playerNames&#10;            }&#10;        }&#10;    }&#10;&#10;    val onPhasesChange = remember {&#10;        { newPhases: List&lt;TurnPhase&gt; -&gt;&#10;            tempConfig = tempConfig.copy(turnPhases = newPhases)&#10;        }&#10;    }&#10;&#10;    val onConfigChange = remember {&#10;        { newConfig: GameConfiguration -&gt;&#10;            tempConfig = newConfig&#10;        }&#10;    }&#10;&#10;    val onPlayerNamesChange = remember {&#10;        { newNames: List&lt;String&gt; -&gt;&#10;            playerNames = newNames&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Game Options&quot;) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onCancel) {&#10;                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = &quot;Back&quot;)&#10;                    }&#10;                },&#10;                actions = {&#10;                    // Add Save Config button to the top bar&#10;                    TextButton(onClick = { showSaveDialog = true }) {&#10;                        Text(&quot;SAVE CONFIG&quot;)&#10;                    }&#10;                    TextButton(&#10;                        onClick = {&#10;                            val finalConfig = tempConfig.copy(playerNames = playerNames.filter { it.isNotBlank() })&#10;                            onSave(finalConfig)&#10;                        }&#10;                    ) {&#10;                        Text(&quot;SAVE&quot;, fontWeight = FontWeight.Bold)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .padding(horizontal = 16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(12.dp),&#10;            contentPadding = PaddingValues(vertical = 8.dp)&#10;        ) {&#10;            // Saved Configurations - Only show if not empty&#10;            if (savedConfigurations.isNotEmpty()) {&#10;                item(&#10;                    key = &quot;saved_configs&quot;,&#10;                    contentType = &quot;saved_configs_card&quot;&#10;                ) {&#10;                    SavedConfigurationsCard(&#10;                        savedConfigurations = savedConfigurations,&#10;                        onLoadConfiguration = remember {&#10;                            { savedConfig: SavedConfiguration -&gt;&#10;                                tempConfig = savedConfig.configuration&#10;                                playerNames = List(savedConfig.configuration.numberOfPlayers) { index -&gt;&#10;                                    if (index &lt; savedConfig.configuration.playerNames.size) {&#10;                                        savedConfig.configuration.playerNames[index]&#10;                                    } else &quot;&quot;&#10;                                }&#10;                            }&#10;                        },&#10;                        onDeleteConfiguration = remember {&#10;                            { configName: String -&gt;&#10;                                val updatedConfigs = savedConfigurations.filter { it.name != configName }&#10;                                saveConfigsToPrefs(updatedConfigs)&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Number of Players&#10;            item(&#10;                key = &quot;player_count&quot;,&#10;                contentType = &quot;player_count_card&quot;&#10;            ) {&#10;                PlayerCountCard(&#10;                    numberOfPlayers = tempConfig.numberOfPlayers,&#10;                    onPlayerCountChange = onPlayerCountChange&#10;                )&#10;            }&#10;&#10;            // Round Configuration&#10;            item(&#10;                key = &quot;round_config&quot;,&#10;                contentType = &quot;round_config_card&quot;&#10;            ) {&#10;                RoundConfigurationCard(&#10;                    turnPhases = tempConfig.turnPhases,&#10;                    onPhasesChange = onPhasesChange&#10;                )&#10;            }&#10;&#10;            // Player Names&#10;            item(&#10;                key = &quot;player_names&quot;,&#10;                contentType = &quot;player_names_card&quot;&#10;            ) {&#10;                PlayerNamesCard(&#10;                    numberOfPlayers = tempConfig.numberOfPlayers,&#10;                    playerNames = playerNames,&#10;                    onPlayerNamesChange = onPlayerNamesChange&#10;                )&#10;            }&#10;&#10;            // Audio Alerts&#10;            item(&#10;                key = &quot;audio_alerts&quot;,&#10;                contentType = &quot;audio_alerts_card&quot;&#10;            ) {&#10;                AudioAlertsCard(&#10;                    config = tempConfig,&#10;                    onConfigChange = onConfigChange&#10;                )&#10;            }&#10;&#10;            // Other Options&#10;            item(&#10;                key = &quot;other_options&quot;,&#10;                contentType = &quot;other_options_card&quot;&#10;            ) {&#10;                OtherOptionsCard(&#10;                    config = tempConfig,&#10;                    onConfigChange = onConfigChange&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    // Save Configuration Dialog&#10;    if (showSaveDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showSaveDialog = false },&#10;            title = { Text(&quot;Save Configuration&quot;) },&#10;            text = {&#10;                OutlinedTextField(&#10;                    value = saveConfigName,&#10;                    onValueChange = { saveConfigName = it },&#10;                    label = { Text(&quot;Configuration Name&quot;) },&#10;                    singleLine = true&#10;                )&#10;            },&#10;            confirmButton = {&#10;                TextButton(&#10;                    onClick = {&#10;                        if (saveConfigName.isNotBlank()) {&#10;                            val finalConfig = tempConfig.copy(playerNames = playerNames.filter { it.isNotBlank() })&#10;                            val newSavedConfig = SavedConfiguration(saveConfigName, finalConfig)&#10;                            val updatedConfigs = savedConfigurations.toMutableList().apply {&#10;                                removeAll { it.name == saveConfigName }&#10;                                add(newSavedConfig)&#10;                            }&#10;                            saveConfigsToPrefs(updatedConfigs)&#10;                            showSaveDialog = false&#10;                            saveConfigName = &quot;&quot;&#10;                        }&#10;                    }&#10;                ) {&#10;                    Text(&quot;Save&quot;)&#10;                }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { showSaveDialog = false }) {&#10;                    Text(&quot;Cancel&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;// Separate composables for each card to improve performance&#10;@Composable&#10;private fun SavedConfigurationsCard(&#10;    savedConfigurations: List&lt;SavedConfiguration&gt;,&#10;    onLoadConfiguration: (SavedConfiguration) -&gt; Unit,&#10;    onDeleteConfiguration: (String) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Text(&#10;                text = &quot;Saved Configurations&quot;,&#10;                fontWeight = FontWeight.Medium,&#10;                fontSize = 18.sp&#10;            )&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            savedConfigurations.forEach { savedConfig -&gt;&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(vertical = 4.dp),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Column(modifier = Modifier.weight(1f)) {&#10;                        Text(&#10;                            text = savedConfig.name,&#10;                            fontWeight = FontWeight.Medium&#10;                        )&#10;                        Text(&#10;                            text = &quot;${savedConfig.configuration.numberOfPlayers} players, ${savedConfig.configuration.turnPhases.size} phases&quot;,&#10;                            fontSize = 12.sp,&#10;                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)&#10;                        )&#10;                    }&#10;                    Row {&#10;                        TextButton(onClick = { onLoadConfiguration(savedConfig) }) {&#10;                            Text(&quot;Load&quot;)&#10;                        }&#10;                        IconButton(onClick = { onDeleteConfiguration(savedConfig.name) }) {&#10;                            Icon(&#10;                                Icons.Default.Delete,&#10;                                contentDescription = &quot;Delete&quot;,&#10;                                tint = MaterialTheme.colorScheme.error&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                if (savedConfig != savedConfigurations.last()) {&#10;                    HorizontalDivider()&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun PlayerCountCard(&#10;    numberOfPlayers: Int,&#10;    onPlayerCountChange: (Int) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Text(&#10;                text = &quot;Number of Players&quot;,&#10;                fontWeight = FontWeight.Medium,&#10;                fontSize = 18.sp&#10;            )&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                horizontalArrangement = Arrangement.Center&#10;            ) {&#10;                IconButton(&#10;                    onClick = {&#10;                        if (numberOfPlayers &gt; 1) {&#10;                            onPlayerCountChange(numberOfPlayers - 1)&#10;                        }&#10;                    }&#10;                ) {&#10;                    Icon(Icons.Default.Remove, contentDescription = &quot;Decrease players&quot;)&#10;                }&#10;&#10;                Text(&#10;                    text = numberOfPlayers.toString(),&#10;                    fontSize = 24.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    modifier = Modifier.padding(horizontal = 32.dp)&#10;                )&#10;&#10;                IconButton(&#10;                    onClick = {&#10;                        if (numberOfPlayers &lt; 15) {&#10;                            onPlayerCountChange(numberOfPlayers + 1)&#10;                        }&#10;                    }&#10;                ) {&#10;                    Icon(Icons.Default.Add, contentDescription = &quot;Increase players&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun RoundConfigurationCard(&#10;    turnPhases: List&lt;TurnPhase&gt;,&#10;    onPhasesChange: (List&lt;TurnPhase&gt;) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;Round Configuration&quot;,&#10;                    fontWeight = FontWeight.Medium,&#10;                    fontSize = 18.sp&#10;                )&#10;&#10;                IconButton(&#10;                    onClick = {&#10;                        val newPhases = turnPhases + TurnPhase(&quot;Phase ${turnPhases.size + 1}&quot;, 60)&#10;                        onPhasesChange(newPhases)&#10;                    }&#10;                ) {&#10;                    Icon(Icons.Default.Add, contentDescription = &quot;Add Phase&quot;)&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // Use stable phase ID as key to prevent recomposition issues&#10;            turnPhases.forEachIndexed { index, phase -&gt;&#10;                key(phase.id) {&#10;                    PhaseConfigCard(&#10;                        phase = phase,&#10;                        phaseIndex = index,&#10;                        canDelete = turnPhases.size &gt; 1,&#10;                        canMoveUp = index &gt; 0,&#10;                        canMoveDown = index &lt; turnPhases.size - 1,&#10;                        onPhaseChange = { newPhase -&gt;&#10;                            val newPhases = turnPhases.toMutableList()&#10;                            newPhases[index] = newPhase&#10;                            onPhasesChange(newPhases)&#10;                        },&#10;                        onDeletePhase = {&#10;                            val newPhases = turnPhases.toMutableList()&#10;                            newPhases.removeAt(index)&#10;                            onPhasesChange(newPhases)&#10;                        },&#10;                        onMovePhaseUp = {&#10;                            if (index &gt; 0) {&#10;                                val newPhases = turnPhases.toMutableList()&#10;                                val temp = newPhases[index]&#10;                                newPhases[index] = newPhases[index - 1]&#10;                                newPhases[index - 1] = temp&#10;                                onPhasesChange(newPhases)&#10;                            }&#10;                        },&#10;                        onMovePhaseDown = {&#10;                            if (index &lt; turnPhases.size - 1) {&#10;                                val newPhases = turnPhases.toMutableList()&#10;                                val temp = newPhases[index]&#10;                                newPhases[index] = newPhases[index + 1]&#10;                                newPhases[index + 1] = temp&#10;                                onPhasesChange(newPhases)&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun PhaseConfigCard(&#10;    phase: TurnPhase,&#10;    phaseIndex: Int,&#10;    canDelete: Boolean,&#10;    canMoveUp: Boolean,&#10;    canMoveDown: Boolean,&#10;    onPhaseChange: (TurnPhase) -&gt; Unit,&#10;    onDeletePhase: () -&gt; Unit,&#10;    onMovePhaseUp: () -&gt; Unit,&#10;    onMovePhaseDown: () -&gt; Unit&#10;) {&#10;    // Memoize expensive computations&#10;    val timeOptions = remember { listOf(0, 10, 15, 30, 45, 60, 90, 120, 180, 240, 300, 450, 600, 900, 1200) }&#10;    val timeLabels = remember { listOf(&quot;Wait&quot;, &quot;10s&quot;, &quot;15s&quot;, &quot;30s&quot;, &quot;45s&quot;, &quot;1m&quot;, &quot;1.5m&quot;, &quot;2m&quot;, &quot;3m&quot;, &quot;4m&quot;, &quot;5m&quot;, &quot;7.5m&quot;, &quot;10m&quot;, &quot;15m&quot;, &quot;20m&quot;) }&#10;    val formattedTime = remember(phase.durationSeconds) {&#10;        if (phase.durationSeconds == 0) &quot;Wait for press&quot;&#10;        else &quot;${phase.durationSeconds / 60}:${String.format(Locale.getDefault(), &quot;%02d&quot;, phase.durationSeconds % 60)}&quot;&#10;    }&#10;&#10;    // Memoize callbacks with proper dependencies&#10;    val onNameChange = remember(phase) {&#10;        { newName: String -&gt;&#10;            onPhaseChange(phase.copy(name = newName))&#10;        }&#10;    }&#10;&#10;    val onDurationDecrease = remember(phase) {&#10;        {&#10;            if (phase.durationSeconds &gt; 0) {&#10;                val newDuration = if (phase.durationSeconds &lt;= 10) 0 else phase.durationSeconds - 10&#10;                onPhaseChange(phase.copy(durationSeconds = newDuration))&#10;            }&#10;        }&#10;    }&#10;&#10;    val onDurationIncrease = remember(phase) {&#10;        {&#10;            if (phase.durationSeconds &lt; 600) {&#10;                val newDuration = if (phase.durationSeconds == 0) 10 else phase.durationSeconds + 10&#10;                onPhaseChange(phase.copy(durationSeconds = newDuration))&#10;            }&#10;        }&#10;    }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;        )&#10;    ) {&#10;        Column(modifier = Modifier.padding(12.dp)) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Phase ${phaseIndex + 1}&quot;,&#10;                        fontWeight = FontWeight.Medium,&#10;                        fontSize = 16.sp&#10;                    )&#10;&#10;                    // Phase reordering buttons&#10;                    Row {&#10;                        IconButton(&#10;                            onClick = onMovePhaseUp,&#10;                            enabled = canMoveUp&#10;                        ) {&#10;                            Icon(&#10;                                Icons.Default.KeyboardArrowUp,&#10;                                contentDescription = &quot;Move phase up&quot;,&#10;                                tint = if (canMoveUp) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.onSurface.copy(alpha = 0.38f)&#10;                            )&#10;                        }&#10;&#10;                        IconButton(&#10;                            onClick = onMovePhaseDown,&#10;                            enabled = canMoveDown&#10;                        ) {&#10;                            Icon(&#10;                                Icons.Default.KeyboardArrowDown,&#10;                                contentDescription = &quot;Move phase down&quot;,&#10;                                tint = if (canMoveDown) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.onSurface.copy(alpha = 0.38f)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                if (canDelete) {&#10;                    IconButton(onClick = onDeletePhase) {&#10;                        Icon(Icons.Default.Delete, contentDescription = &quot;Delete Phase&quot;)&#10;                    }&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Phase name input&#10;            OutlinedTextField(&#10;                value = phase.name,&#10;                onValueChange = onNameChange,&#10;                label = { Text(&quot;Phase Name&quot;) },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                singleLine = true&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // Phase Type Selection&#10;            Text(&#10;                text = &quot;Phase Type:&quot;,&#10;                fontSize = 14.sp,&#10;                fontWeight = FontWeight.Medium&#10;            )&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                FilterChip(&#10;                    onClick = { onPhaseChange(phase.copy(phaseType = PhaseType.NORMAL)) },&#10;                    label = { Text(&quot;Normal&quot;) },&#10;                    selected = phase.phaseType == PhaseType.NORMAL,&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;                FilterChip(&#10;                    onClick = { onPhaseChange(phase.copy(phaseType = PhaseType.DICE_THROW)) },&#10;                    label = { Text(&quot;Dice Throw&quot;) },&#10;                    selected = phase.phaseType == PhaseType.DICE_THROW,&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;            }&#10;&#10;            // Dice Configuration (only show for dice throw phases)&#10;            if (phase.phaseType == PhaseType.DICE_THROW) {&#10;                Spacer(modifier = Modifier.height(12.dp))&#10;&#10;                Text(&#10;                    text = &quot;Dice Configuration:&quot;,&#10;                    fontSize = 14.sp,&#10;                    fontWeight = FontWeight.Medium&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                // Dice Count&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.SpaceBetween&#10;                ) {&#10;                    Text(text = &quot;Number of Dice:&quot;)&#10;&#10;                    Row(verticalAlignment = Alignment.CenterVertically) {&#10;                        IconButton(&#10;                            onClick = {&#10;                                if (phase.diceCount &gt; 1) {&#10;                                    onPhaseChange(phase.copy(diceCount = phase.diceCount - 1))&#10;                                }&#10;                            },&#10;                            enabled = phase.diceCount &gt; 1&#10;                        ) {&#10;                            Icon(Icons.Default.Remove, contentDescription = &quot;Decrease dice count&quot;)&#10;                        }&#10;&#10;                        Text(&#10;                            text = &quot;${phase.diceCount}&quot;,&#10;                            fontWeight = FontWeight.Bold,&#10;                            modifier = Modifier.widthIn(min = 40.dp),&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;&#10;                        IconButton(&#10;                            onClick = {&#10;                                if (phase.diceCount &lt; 10) {&#10;                                    onPhaseChange(phase.copy(diceCount = phase.diceCount + 1))&#10;                                }&#10;                            },&#10;                            enabled = phase.diceCount &lt; 10&#10;                        ) {&#10;                            Icon(Icons.Default.Add, contentDescription = &quot;Increase dice count&quot;)&#10;                        }&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                // Dice Type Selection&#10;                Text(text = &quot;Dice Type:&quot;)&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;&#10;                LazyRow(&#10;                    horizontalArrangement = Arrangement.spacedBy(6.dp)&#10;                ) {&#10;                    items(DiceType.values()) { diceType -&gt;&#10;                        FilterChip(&#10;                            onClick = { onPhaseChange(phase.copy(diceType = diceType)) },&#10;                            label = { Text(diceType.displayName) },&#10;                            selected = phase.diceType == diceType&#10;                        )&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                // Wait for Press Option&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.SpaceBetween&#10;                ) {&#10;                    Text(text = &quot;Wait for press to throw dice:&quot;)&#10;                    Switch(&#10;                        checked = phase.waitForPress,&#10;                        onCheckedChange = { onPhaseChange(phase.copy(waitForPress = it)) }&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            Text(&#10;                text = &quot;Quick Select:&quot;,&#10;                fontSize = 14.sp,&#10;                fontWeight = FontWeight.Medium&#10;            )&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Replace LazyRow with FlowRow for better performance&#10;            QuickSelectChips(&#10;                timeOptions = timeOptions,&#10;                timeLabels = timeLabels,&#10;                currentDuration = phase.durationSeconds,&#10;                onDurationSelect = { duration -&gt;&#10;                    onPhaseChange(phase.copy(durationSeconds = duration))&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // Duration controls&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                horizontalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                Text(&#10;                    text = &quot;Duration:&quot;,&#10;                    fontSize = 16.sp,&#10;                    fontWeight = FontWeight.Medium&#10;                )&#10;&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.spacedBy(4.dp)&#10;                ) {&#10;                    IconButton(onClick = onDurationDecrease) {&#10;                        Icon(Icons.Default.Remove, contentDescription = &quot;Decrease duration&quot;)&#10;                    }&#10;&#10;                    Text(&#10;                        text = formattedTime,&#10;                        fontWeight = FontWeight.Bold,&#10;                        fontSize = 18.sp,&#10;                        modifier = Modifier.widthIn(min = 80.dp),&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;&#10;                    IconButton(onClick = onDurationIncrease) {&#10;                        Icon(Icons.Default.Add, contentDescription = &quot;Increase duration&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun QuickSelectChips(&#10;    timeOptions: List&lt;Int&gt;,&#10;    timeLabels: List&lt;String&gt;,&#10;    currentDuration: Int,&#10;    onDurationSelect: (Int) -&gt; Unit&#10;) {&#10;    // Use horizontally scrollable LazyRow for better UX with many options&#10;    LazyRow(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        horizontalArrangement = Arrangement.spacedBy(6.dp),&#10;        contentPadding = PaddingValues(horizontal = 4.dp)&#10;    ) {&#10;        items(timeOptions.size) { index -&gt;&#10;            FilterChip(&#10;                onClick = { onDurationSelect(timeOptions[index]) },&#10;                label = { Text(timeLabels[index]) },&#10;                selected = currentDuration == timeOptions[index]&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun PlayerNamesCard(&#10;    numberOfPlayers: Int,&#10;    playerNames: List&lt;String&gt;,&#10;    onPlayerNamesChange: (List&lt;String&gt;) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;Player Names (Optional)&quot;,&#10;                    fontWeight = FontWeight.Medium,&#10;                    fontSize = 18.sp&#10;                )&#10;                IconButton(&#10;                    onClick = {&#10;                        onPlayerNamesChange(playerNames.reversed())&#10;                    }&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.SwapVert,&#10;                        contentDescription = &quot;Reverse player order&quot;&#10;                    )&#10;                }&#10;            }&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            repeat(numberOfPlayers) { index -&gt;&#10;                key(index) {&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(vertical = 2.dp), // Reduced padding&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        // Move up button&#10;                        IconButton(&#10;                            onClick = {&#10;                                if (index &gt; 0) {&#10;                                    val newNames = playerNames.toMutableList()&#10;                                    val temp = newNames[index]&#10;                                    newNames[index] = newNames[index - 1]&#10;                                    newNames[index - 1] = temp&#10;                                    onPlayerNamesChange(newNames)&#10;                                }&#10;                            },&#10;                            enabled = index &gt; 0&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.KeyboardArrowUp,&#10;                                contentDescription = &quot;Move up&quot;&#10;                            )&#10;                        }&#10;&#10;                        // Player name text field&#10;                        OutlinedTextField(&#10;                            value = if (index &lt; playerNames.size) playerNames[index] else &quot;&quot;,&#10;                            onValueChange = { newName -&gt;&#10;                                val updatedNames = playerNames.toMutableList()&#10;                                while (updatedNames.size &lt;= index) {&#10;                                    updatedNames.add(&quot;&quot;)&#10;                                }&#10;                                updatedNames[index] = newName&#10;                                onPlayerNamesChange(updatedNames)&#10;                            },&#10;                            label = { Text(&quot;Player ${index + 1}&quot;) },&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .padding(horizontal = 8.dp),&#10;                            singleLine = true&#10;                        )&#10;&#10;                        // Move down button&#10;                        IconButton(&#10;                            onClick = {&#10;                                if (index &lt; numberOfPlayers - 1) {&#10;                                    val newNames = playerNames.toMutableList()&#10;                                    val temp = newNames[index]&#10;                                    newNames[index] = newNames[index + 1]&#10;                                    newNames[index + 1] = temp&#10;                                    onPlayerNamesChange(newNames)&#10;                                }&#10;                            },&#10;                            enabled = index &lt; numberOfPlayers - 1&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.KeyboardArrowDown,&#10;                                contentDescription = &quot;Move down&quot;&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun AudioAlertsCard(&#10;    config: GameConfiguration,&#10;    onConfigChange: (GameConfiguration) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Text(&#10;                text = &quot;Audio Alerts&quot;,&#10;                fontWeight = FontWeight.Medium,&#10;                fontSize = 18.sp&#10;            )&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            OptionsCheckboxOption(&#10;                text = &quot;60 seconds remaining&quot;,&#10;                checked = config.audioAlert60s,&#10;                onCheckedChange = { onConfigChange(config.copy(audioAlert60s = it)) }&#10;            )&#10;&#10;            OptionsCheckboxOption(&#10;                text = &quot;30 seconds remaining&quot;,&#10;                checked = config.audioAlert30s,&#10;                onCheckedChange = { onConfigChange(config.copy(audioAlert30s = it)) }&#10;            )&#10;&#10;            OptionsCheckboxOption(&#10;                text = &quot;10 second countdown&quot;,&#10;                checked = config.audioAlert10sCountdown,&#10;                onCheckedChange = { onConfigChange(config.copy(audioAlert10sCountdown = it)) }&#10;            )&#10;&#10;            OptionsCheckboxOption(&#10;                text = &quot;Time out alert&quot;,&#10;                checked = config.audioAlertTimeOut,&#10;                onCheckedChange = { onConfigChange(config.copy(audioAlertTimeOut = it)) }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun OtherOptionsCard(&#10;    config: GameConfiguration,&#10;    onConfigChange: (GameConfiguration) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Text(&#10;                text = &quot;Other Options&quot;,&#10;                fontWeight = FontWeight.Medium,&#10;                fontSize = 18.sp&#10;            )&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            OptionsCheckboxOption(&#10;                text = &quot;Vibrate on alerts&quot;,&#10;                checked = config.vibrateOnAlerts,&#10;                onCheckedChange = { onConfigChange(config.copy(vibrateOnAlerts = it)) }&#10;            )&#10;&#10;            OptionsCheckboxOption(&#10;                text = &quot;Keep counter alignment fixed&quot;,&#10;                checked = config.keepCounterAlignmentFixed,&#10;                onCheckedChange = { onConfigChange(config.copy(keepCounterAlignmentFixed = it)) }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun OptionsCheckboxOption(&#10;    text: String,&#10;    checked: Boolean,&#10;    onCheckedChange: (Boolean) -&gt; Unit&#10;) {&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 6.dp),&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        Checkbox(&#10;            checked = checked,&#10;            onCheckedChange = onCheckedChange&#10;        )&#10;        Spacer(modifier = Modifier.width(12.dp))&#10;        Text(&#10;            text = text,&#10;            fontSize = 16.sp&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/model/GameConfiguration.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/model/GameConfiguration.kt" />
              <option name="originalContent" value="package com.example.boardgametimer.model&#10;&#10;enum class PhaseType {&#10;    NORMAL,&#10;    DICE_THROW&#10;}&#10;&#10;enum class DiceType(val sides: Int, val displayName: String) {&#10;    D2(2, &quot;d2&quot;),&#10;    D4(4, &quot;d4&quot;),&#10;    D6(6, &quot;d6&quot;),&#10;    D8(8, &quot;d8&quot;),&#10;    D10(10, &quot;d10&quot;),&#10;    D20(20, &quot;d20&quot;),&#10;    D100(100, &quot;d100&quot;)&#10;}&#10;&#10;data class TurnPhase(&#10;    val name: String,&#10;    val durationSeconds: Int,&#10;    val phaseType: PhaseType = PhaseType.NORMAL,&#10;    val diceCount: Int = 1,&#10;    val diceType: DiceType = DiceType.D6,&#10;    val waitForPress: Boolean = false&#10;)&#10;&#10;data class GameConfiguration(&#10;    val numberOfPlayers: Int = 4,&#10;    val turnPhases: List&lt;TurnPhase&gt; = listOf(TurnPhase(&quot;Main Turn&quot;, 120)), // Default single phase&#10;    val turnDurationSeconds: Int = 120, // Keep for backward compatibility&#10;    val playerNames: List&lt;String&gt; = emptyList(),&#10;    val audioAlert60s: Boolean = false,&#10;    val audioAlert30s: Boolean = false,&#10;    val audioAlert10sCountdown: Boolean = true, // Enable by default&#10;    val audioAlertTimeOut: Boolean = true, // Enable timeout alert by default&#10;    val vibrateOnAlerts: Boolean = true, // Enable by default&#10;    val keepCounterAlignmentFixed: Boolean = false,&#10;    val selectedSoundIndex: Int = 0 // Index for predefined sounds&#10;) {&#10;    fun getPlayerName(index: Int): String {&#10;        return if (index &lt; playerNames.size &amp;&amp; playerNames[index].isNotBlank()) {&#10;            playerNames[index]&#10;        } else {&#10;            &quot;Player ${index + 1}&quot;&#10;        }&#10;    }&#10;&#10;    fun getCurrentPhaseDuration(phaseIndex: Int): Int {&#10;        return if (phaseIndex &lt; turnPhases.size) {&#10;            turnPhases[phaseIndex].durationSeconds&#10;        } else {&#10;            turnDurationSeconds // Fallback to legacy duration&#10;        }&#10;    }&#10;&#10;    fun getCurrentPhaseName(phaseIndex: Int): String {&#10;        return if (phaseIndex &lt; turnPhases.size) {&#10;            turnPhases[phaseIndex].name&#10;        } else {&#10;            &quot;Phase ${phaseIndex + 1}&quot;&#10;        }&#10;    }&#10;&#10;    fun getTotalPhases(): Int = turnPhases.size&#10;}&#10;&#10;data class SavedConfiguration(&#10;    val name: String,&#10;    val configuration: GameConfiguration&#10;)&#10;" />
              <option name="updatedContent" value="package com.example.boardgametimer.model&#10;&#10;import java.util.UUID&#10;import com.google.gson.annotations.SerializedName&#10;&#10;enum class PhaseType {&#10;    NORMAL,&#10;    DICE_THROW&#10;}&#10;&#10;enum class DiceType(val sides: Int, val displayName: String) {&#10;    D2(2, &quot;d2&quot;),&#10;    D4(4, &quot;d4&quot;),&#10;    D6(6, &quot;d6&quot;),&#10;    D8(8, &quot;d8&quot;),&#10;    D10(10, &quot;d10&quot;),&#10;    D20(20, &quot;d20&quot;),&#10;    D100(100, &quot;d100&quot;)&#10;}&#10;&#10;data class TurnPhase(&#10;    val name: String,&#10;    val durationSeconds: Int,&#10;    val phaseType: PhaseType = PhaseType.NORMAL,&#10;    val diceCount: Int = 1,&#10;    val diceType: DiceType = DiceType.D6,&#10;    val waitForPress: Boolean = false,&#10;    val id: String = UUID.randomUUID().toString()&#10;) {&#10;    // Ensure backward compatibility - if id is empty or null, generate a new one&#10;    fun withValidId(): TurnPhase {&#10;        return if (id.isBlank()) {&#10;            copy(id = UUID.randomUUID().toString())&#10;        } else {&#10;            this&#10;        }&#10;    }&#10;}&#10;&#10;data class GameConfiguration(&#10;    val numberOfPlayers: Int = 4,&#10;    val turnPhases: List&lt;TurnPhase&gt; = listOf(TurnPhase(&quot;Main Turn&quot;, 120)), // Default single phase&#10;    val turnDurationSeconds: Int = 120, // Keep for backward compatibility&#10;    val playerNames: List&lt;String&gt; = emptyList(),&#10;    val audioAlert60s: Boolean = false,&#10;    val audioAlert30s: Boolean = false,&#10;    val audioAlert10sCountdown: Boolean = true, // Enable by default&#10;    val audioAlertTimeOut: Boolean = true, // Enable timeout alert by default&#10;    val vibrateOnAlerts: Boolean = true, // Enable by default&#10;    val keepCounterAlignmentFixed: Boolean = false,&#10;    val selectedSoundIndex: Int = 0 // Index for predefined sounds&#10;) {&#10;    fun getPlayerName(index: Int): String {&#10;        return if (index &lt; playerNames.size &amp;&amp; playerNames[index].isNotBlank()) {&#10;            playerNames[index]&#10;        } else {&#10;            &quot;Player ${index + 1}&quot;&#10;        }&#10;    }&#10;&#10;    fun getCurrentPhaseDuration(phaseIndex: Int): Int {&#10;        return if (phaseIndex &lt; turnPhases.size) {&#10;            turnPhases[phaseIndex].durationSeconds&#10;        } else {&#10;            turnDurationSeconds // Fallback to legacy duration&#10;        }&#10;    }&#10;&#10;    fun getCurrentPhaseName(phaseIndex: Int): String {&#10;        return if (phaseIndex &lt; turnPhases.size) {&#10;            turnPhases[phaseIndex].name&#10;        } else {&#10;            &quot;Phase ${phaseIndex + 1}&quot;&#10;        }&#10;    }&#10;&#10;    fun getTotalPhases(): Int = turnPhases.size&#10;}&#10;&#10;data class SavedConfiguration(&#10;    val name: String,&#10;    val configuration: GameConfiguration&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModel.kt" />
              <option name="originalContent" value="package com.example.boardgametimer.viewmodel&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.media.AudioManager&#10;import android.media.ToneGenerator&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.speech.tts.TextToSpeech&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.GameState&#10;import com.example.boardgametimer.model.SavedConfiguration&#10;import com.example.boardgametimer.model.DicePhaseState&#10;import com.example.boardgametimer.model.PhaseType&#10;import com.example.boardgametimer.model.TurnPhase&#10;import com.example.boardgametimer.model.DiceResult&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.util.Locale&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;&#10;class GameTimerViewModel : ViewModel() {&#10;&#10;    var gameState by mutableStateOf(GameState())&#10;        private set&#10;&#10;    var gameConfiguration by mutableStateOf(GameConfiguration())&#10;        private set&#10;&#10;    var showOptions by mutableStateOf(false)&#10;        private set&#10;&#10;    var showStats by mutableStateOf(false)&#10;        private set&#10;&#10;    var undoHistory by mutableStateOf&lt;GameState?&gt;(null)&#10;        private set&#10;&#10;    var savedConfigurations by mutableStateOf&lt;List&lt;SavedConfiguration&gt;&gt;(emptyList())&#10;        private set&#10;&#10;    private var timerJob: Job? = null&#10;    private var toneGenerator: ToneGenerator? = null&#10;    private var vibrator: Vibrator? = null&#10;    private var textToSpeech: TextToSpeech? = null&#10;    private var ttsReady = false&#10;    private var sharedPreferences: SharedPreferences? = null&#10;    private val gson = Gson()&#10;&#10;    fun initializeAudio(context: Context) {&#10;        toneGenerator = ToneGenerator(AudioManager.STREAM_NOTIFICATION, 100)&#10;&#10;        // Use modern vibrator API&#10;        vibrator = if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.S) {&#10;            val vibratorManager = context.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            vibratorManager.defaultVibrator&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;&#10;        textToSpeech = TextToSpeech(context) { status -&gt;&#10;            if (status == TextToSpeech.SUCCESS) {&#10;                textToSpeech?.language = Locale.getDefault()&#10;                ttsReady = true&#10;            }&#10;        }&#10;&#10;        // Initialize SharedPreferences for saving configurations&#10;        sharedPreferences = context.getSharedPreferences(&quot;BoardGameTimer&quot;, Context.MODE_PRIVATE)&#10;        loadSavedConfigurations()&#10;        loadLastUsedConfiguration()&#10;    }&#10;&#10;    private fun loadLastUsedConfiguration() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = prefs.getString(&quot;last_used_configuration&quot;, null)&#10;            if (json != null) {&#10;                try {&#10;                    val lastConfig = gson.fromJson(json, GameConfiguration::class.java)&#10;                    gameConfiguration = lastConfig&#10;                    // Always update game state with the loaded configuration when app starts&#10;                    if (!gameState.isGameRunning) {&#10;                        val playerTurnTimes = List(lastConfig.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;                        val firstPhaseDuration = lastConfig.getCurrentPhaseDuration(0)&#10;                        gameState = GameState(&#10;                            currentPlayerIndex = 0,&#10;                            currentPhaseIndex = 0,&#10;                            timeRemainingSeconds = firstPhaseDuration,&#10;                            timeRemainingMillis = firstPhaseDuration * 1000L,&#10;                            playerTurnTimes = playerTurnTimes,&#10;                            isPaused = true, // Start paused by default&#10;                            isGameRunning = false&#10;                        )&#10;                    }&#10;                } catch (e: Exception) {&#10;                    // If loading fails, keep the default configuration&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveCurrentConfigurationAsDefault() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = gson.toJson(gameConfiguration)&#10;            prefs.edit().putString(&quot;last_used_configuration&quot;, json).apply()&#10;        }&#10;    }&#10;&#10;    fun startNewGame() {&#10;        val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;        val firstPhaseDuration = gameConfiguration.getCurrentPhaseDuration(0)&#10;        gameState = GameState(&#10;            currentPlayerIndex = 0,&#10;            currentPhaseIndex = 0, // Start with first phase&#10;            timeRemainingSeconds = firstPhaseDuration,&#10;            timeRemainingMillis = firstPhaseDuration * 1000L,&#10;            isGameRunning = true,&#10;            isPaused = false, // Start ready to play, not paused&#10;            roundCount = 0,&#10;            playerTurnTimes = playerTurnTimes,&#10;            gameStartTime = System.currentTimeMillis(),&#10;            turnStartTime = System.currentTimeMillis()&#10;        )&#10;        startTimer() // Auto-start the timer for the first player&#10;    }&#10;&#10;    fun nextPlayer() {&#10;        if (!gameState.isGameRunning) return&#10;&#10;        // Check if we need to advance to next phase or next player&#10;        val nextPhaseIndex = gameState.currentPhaseIndex + 1&#10;        val totalPhases = gameConfiguration.getTotalPhases()&#10;&#10;        if (nextPhaseIndex &lt; totalPhases) {&#10;            // Move to next phase for same player&#10;            nextPhase()&#10;        } else {&#10;            // Move to next player (reset to first phase)&#10;            moveToNextPlayer()&#10;        }&#10;    }&#10;&#10;    private fun nextPhase() {&#10;        // Play a beep sound when passing to next phase&#10;        playTurnPassBeep()&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        val nextPhaseIndex = gameState.currentPhaseIndex + 1&#10;        val phaseDuration = gameConfiguration.getCurrentPhaseDuration(nextPhaseIndex)&#10;        val nextPhase = gameConfiguration.turnPhases[nextPhaseIndex]&#10;&#10;        gameState = gameState.copy(&#10;            currentPhaseIndex = nextPhaseIndex,&#10;            timeRemainingSeconds = phaseDuration,&#10;            timeRemainingMillis = phaseDuration * 1000L,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = false,&#10;            // Reset dice state for new phase&#10;            dicePhaseState = DicePhaseState.WAITING_TO_THROW,&#10;            diceResult = null,&#10;            isDiceAnimating = false&#10;        )&#10;&#10;        // Auto-start timer for next phase (unless it's a dice phase waiting for throw)&#10;        if (nextPhase.phaseType != PhaseType.DICE_THROW || !shouldWaitForDiceThrow()) {&#10;            startTimer()&#10;        }&#10;    }&#10;&#10;    private fun moveToNextPlayer() {&#10;        // Play a beep sound when passing turn&#10;        playTurnPassBeep()&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        // Record the time taken for current player's turn (only record when completing all phases)&#10;        val timeTaken = gameConfiguration.getCurrentPhaseDuration(gameState.currentPhaseIndex) - gameState.timeRemainingSeconds&#10;        val currentPlayerTimes = gameState.playerTurnTimes[gameState.currentPlayerIndex].toMutableList()&#10;        currentPlayerTimes.add(timeTaken)&#10;&#10;        val updatedPlayerTurnTimes = gameState.playerTurnTimes.toMutableList()&#10;        updatedPlayerTurnTimes[gameState.currentPlayerIndex] = currentPlayerTimes&#10;&#10;        val nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameConfiguration.numberOfPlayers&#10;        val newRoundCount = if (nextPlayerIndex == 0) gameState.roundCount + 1 else gameState.roundCount&#10;        val firstPhaseDuration = gameConfiguration.getCurrentPhaseDuration(0)&#10;        val firstPhase = gameConfiguration.turnPhases[0]&#10;&#10;        gameState = gameState.copy(&#10;            currentPlayerIndex = nextPlayerIndex,&#10;            currentPhaseIndex = 0, // Reset to first phase for new player&#10;            timeRemainingSeconds = firstPhaseDuration,&#10;            timeRemainingMillis = firstPhaseDuration * 1000L,&#10;            playerTurnTimes = updatedPlayerTurnTimes,&#10;            roundCount = newRoundCount,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = false,&#10;            // Reset dice state for new player&#10;            dicePhaseState = DicePhaseState.WAITING_TO_THROW,&#10;            diceResult = null,&#10;            isDiceAnimating = false&#10;        )&#10;&#10;        // Auto-start timer for next player (unless first phase is a dice phase waiting for throw)&#10;        if (firstPhase.phaseType != PhaseType.DICE_THROW || !shouldWaitForDiceThrow()) {&#10;            startTimer()&#10;        }&#10;    }&#10;&#10;    fun undoLastAction() {&#10;        undoHistory?.let { previousState -&gt;&#10;            gameState = previousState&#10;            undoHistory = null&#10;            if (gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun pauseResumeGame() {&#10;        if (gameState.isGameRunning) {&#10;            gameState = gameState.copy(isPaused = !gameState.isPaused)&#10;            if (gameState.isPaused) {&#10;                timerJob?.cancel()&#10;            } else {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun endGame() {&#10;        timerJob?.cancel()&#10;        gameState = gameState.copy(isGameRunning = false, isPaused = false)&#10;        showStats = true&#10;    }&#10;&#10;    private fun startTimer() {&#10;        timerJob?.cancel()&#10;        timerJob = viewModelScope.launch {&#10;            var lastUpdateTime = System.currentTimeMillis()&#10;            var lastSecond = gameState.timeRemainingSeconds&#10;&#10;            while (gameState.timeRemainingMillis &gt; 0 &amp;&amp; gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                delay(16) // Update every 16ms for smooth animation (~60fps)&#10;&#10;                val currentTime = System.currentTimeMillis()&#10;                val deltaTime = currentTime - lastUpdateTime&#10;                lastUpdateTime = currentTime&#10;&#10;                val newTimeMillis = (gameState.timeRemainingMillis - deltaTime).coerceAtLeast(0L)&#10;                val newTimeSeconds = (newTimeMillis / 1000).toInt()&#10;&#10;                gameState = gameState.copy(&#10;                    timeRemainingMillis = newTimeMillis,&#10;                    timeRemainingSeconds = newTimeSeconds&#10;                )&#10;&#10;                // Handle audio alerts (only on second changes)&#10;                if (newTimeSeconds != lastSecond) {&#10;                    lastSecond = newTimeSeconds&#10;                    when (newTimeSeconds) {&#10;                        60 -&gt; if (gameConfiguration.audioAlert60s) playAlert()&#10;                        30 -&gt; if (gameConfiguration.audioAlert30s) playAlert()&#10;                        10, 9, 8, 7, 6, 5, 4, 3, 2, 1 -&gt; {&#10;                            if (gameConfiguration.audioAlert10sCountdown) {&#10;                                speakCountdown(newTimeSeconds)&#10;                            }&#10;                        }&#10;                        0 -&gt; {&#10;                            // Handle timeout with enhanced functionality&#10;                            handlePlayerTimeout()&#10;                            break&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handlePlayerTimeout() {&#10;        // Play timeout alert if enabled&#10;        if (gameConfiguration.audioAlertTimeOut) {&#10;            playAlert()&#10;        }&#10;&#10;        // Announce timeout with text-to-speech if enabled&#10;        if (gameConfiguration.audioAlertTimeOut &amp;&amp; ttsReady) {&#10;            val playerName = gameConfiguration.getPlayerName(gameState.currentPlayerIndex)&#10;            textToSpeech?.speak(&quot;$playerName ran out of time!&quot;, TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;&#10;        // Pause the game and show timeout dialog&#10;        gameState = gameState.copy(&#10;            isPaused = true,&#10;            showTimeExpiredDialog = true&#10;        )&#10;    }&#10;&#10;    fun dismissTimeExpiredDialog() {&#10;        gameState = gameState.copy(showTimeExpiredDialog = false)&#10;    }&#10;&#10;    fun continueAfterTimeout() {&#10;        // Reset timer to full duration and resume game&#10;        gameState = gameState.copy(&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            isPaused = false,&#10;            showTimeExpiredDialog = false&#10;        )&#10;        startTimer()&#10;    }&#10;&#10;    private fun playAlert() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_CDMA_ALERT_CALL_GUARD, 200)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun playTurnPassBeep() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_PROP_BEEP, 150)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun speakCountdown(seconds: Int) {&#10;        if (ttsReady) {&#10;            textToSpeech?.speak(seconds.toString(), TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    fun updateConfiguration(newConfig: GameConfiguration) {&#10;        gameConfiguration = newConfig&#10;        // Automatically save this configuration as the default for future app startups&#10;        saveCurrentConfigurationAsDefault()&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(newConfig.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = newConfig.turnDurationSeconds,&#10;                timeRemainingMillis = newConfig.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun saveConfiguration(name: String) {&#10;        if (name.isBlank()) return&#10;&#10;        val newConfig = SavedConfiguration(name, gameConfiguration)&#10;        val updatedConfigs = savedConfigurations.toMutableList()&#10;&#10;        // Remove existing config with same name&#10;        updatedConfigs.removeAll { it.name == name }&#10;        updatedConfigs.add(newConfig)&#10;&#10;        savedConfigurations = updatedConfigs&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    fun loadConfiguration(savedConfig: SavedConfiguration) {&#10;        gameConfiguration = savedConfig.configuration&#10;        // Automatically save this loaded configuration as the default for future app startups&#10;        saveCurrentConfigurationAsDefault()&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;                timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun deleteConfiguration(configName: String) {&#10;        savedConfigurations = savedConfigurations.filter { it.name != configName }&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    private fun loadSavedConfigurations() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = prefs.getString(&quot;saved_configurations&quot;, &quot;[]&quot;)&#10;            val type = object : TypeToken&lt;List&lt;SavedConfiguration&gt;&gt;() {}.type&#10;            try {&#10;                savedConfigurations = gson.fromJson(json, type) ?: emptyList()&#10;            } catch (e: Exception) {&#10;                savedConfigurations = emptyList()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveToPersistentStorage() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = gson.toJson(savedConfigurations)&#10;            prefs.edit().putString(&quot;saved_configurations&quot;, json).apply()&#10;        }&#10;    }&#10;&#10;    fun showOptions() {&#10;        showOptions = true&#10;    }&#10;&#10;    fun hideOptions() {&#10;        showOptions = false&#10;    }&#10;&#10;    fun hideStats() {&#10;        showStats = false&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        toneGenerator?.release()&#10;        textToSpeech?.shutdown()&#10;    }&#10;&#10;    fun throwDice() {&#10;        val currentPhase = gameConfiguration.turnPhases[gameState.currentPhaseIndex]&#10;        if (currentPhase.phaseType != PhaseType.DICE_THROW) return&#10;&#10;        // Prevent throwing dice if game is not running&#10;        if (!gameState.isGameRunning) return&#10;&#10;        // Prevent throwing dice if already thrown in this phase&#10;        if (gameState.dicePhaseState != DicePhaseState.WAITING_TO_THROW) return&#10;&#10;        // Stop the countdown timer immediately when dice are thrown&#10;        timerJob?.cancel()&#10;&#10;        // Start dice animation and pause the game&#10;        gameState = gameState.copy(&#10;            isDiceAnimating = true,&#10;            dicePhaseState = DicePhaseState.THROWING,&#10;            isPaused = true // Pause the game to stop the countdown&#10;        )&#10;&#10;        // Simulate dice animation with out-of-sync changes for multiple dice&#10;        viewModelScope.launch {&#10;            val animationDuration = 3000L // Fixed at 3 seconds&#10;            val startTime = System.currentTimeMillis()&#10;&#10;            // Initialize with random values immediately to replace &quot;Tap to throw&quot;&#10;            var previousValues = (1..currentPhase.diceCount).map { (1..currentPhase.diceType.sides).random() }&#10;            val lastChangeTime = mutableListOf&lt;Long&gt;()&#10;            repeat(currentPhase.diceCount) { lastChangeTime.add(0L) }&#10;&#10;            // Set initial values immediately&#10;            gameState = gameState.copy(&#10;                diceResult = DiceResult(previousValues, previousValues.sum())&#10;            )&#10;&#10;            while (System.currentTimeMillis() - startTime &lt; animationDuration) {&#10;                val currentTime = System.currentTimeMillis() - startTime&#10;                val progress = currentTime.toFloat() / animationDuration.toFloat()&#10;&#10;                // Create deceleration curve - starts fast, gets slower&#10;                val decelerationFactor = 1.0f - (progress * progress) // Quadratic deceleration&#10;                val adjustedBaseInterval = (120L + (300L * progress)).toLong() // 120ms to 420ms (more controlled)&#10;&#10;                // Check each die individually and update immediately when it's time to change&#10;                for (index in 0 until currentPhase.diceCount) {&#10;                    val dieInterval = (adjustedBaseInterval + (index * 80L * decelerationFactor)).toLong()&#10;&#10;                    // Check if enough time has passed since this die's last change&#10;                    if (currentTime - lastChangeTime[index] &gt;= dieInterval) {&#10;                        // Time to change this die's value - update immediately&#10;                        lastChangeTime[index] = currentTime&#10;                        val newValue = (1..currentPhase.diceType.sides).random()&#10;&#10;                        // Update only this die's value immediately for perfect sync&#10;                        val updatedValues = previousValues.toMutableList()&#10;                        updatedValues[index] = newValue&#10;                        previousValues = updatedValues&#10;&#10;                        // Update state immediately when value changes&#10;                        gameState = gameState.copy(&#10;                            diceResult = DiceResult(previousValues, previousValues.sum())&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Fixed frame rate&#10;                delay(50L)&#10;            }&#10;&#10;            // Generate final result&#10;            val finalValues = (1..currentPhase.diceCount).map {&#10;                (1..currentPhase.diceType.sides).random()&#10;            }&#10;            gameState = gameState.copy(&#10;                isDiceAnimating = false,&#10;                diceResult = DiceResult(finalValues, finalValues.sum()),&#10;                dicePhaseState = DicePhaseState.SHOWING_RESULT&#10;            )&#10;&#10;            // Play dice sound effect&#10;            playDiceSound()&#10;&#10;            // Handle timer based on phase configuration&#10;            if (currentPhase.waitForPress) {&#10;                // If wait for press is enabled, just pause and wait for manual progression&#10;                gameState = gameState.copy(isPaused = true)&#10;            } else if (currentPhase.durationSeconds &gt; 0) {&#10;                // Start the timer with the configured duration&#10;                gameState = gameState.copy(&#10;                    timeRemainingSeconds = currentPhase.durationSeconds,&#10;                    timeRemainingMillis = currentPhase.durationSeconds * 1000L,&#10;                    isPaused = false&#10;                )&#10;                startTimer()&#10;            } else {&#10;                // Duration is 0, automatically proceed to next phase/player&#10;                delay(1000) // Show result for 1 second&#10;                nextPlayer()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun playDiceSound() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_PROP_BEEP, 200)&#10;    }&#10;&#10;    fun getCurrentPhase(): TurnPhase {&#10;        return gameConfiguration.turnPhases[gameState.currentPhaseIndex]&#10;    }&#10;&#10;    fun isDicePhase(): Boolean {&#10;        return getCurrentPhase().phaseType == PhaseType.DICE_THROW&#10;    }&#10;&#10;    fun shouldWaitForDiceThrow(): Boolean {&#10;        val currentPhase = getCurrentPhase()&#10;        return currentPhase.phaseType == PhaseType.DICE_THROW &amp;&amp;&#10;               gameState.dicePhaseState == DicePhaseState.WAITING_TO_THROW&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.boardgametimer.viewmodel&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.media.AudioManager&#10;import android.media.ToneGenerator&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.speech.tts.TextToSpeech&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.GameState&#10;import com.example.boardgametimer.model.SavedConfiguration&#10;import com.example.boardgametimer.model.DicePhaseState&#10;import com.example.boardgametimer.model.PhaseType&#10;import com.example.boardgametimer.model.TurnPhase&#10;import com.example.boardgametimer.model.DiceResult&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.util.Locale&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;&#10;class GameTimerViewModel : ViewModel() {&#10;&#10;    var gameState by mutableStateOf(GameState())&#10;        private set&#10;&#10;    var gameConfiguration by mutableStateOf(GameConfiguration())&#10;        private set&#10;&#10;    var showOptions by mutableStateOf(false)&#10;        private set&#10;&#10;    var showStats by mutableStateOf(false)&#10;        private set&#10;&#10;    var undoHistory by mutableStateOf&lt;GameState?&gt;(null)&#10;        private set&#10;&#10;    var savedConfigurations by mutableStateOf&lt;List&lt;SavedConfiguration&gt;&gt;(emptyList())&#10;        private set&#10;&#10;    private var timerJob: Job? = null&#10;    private var toneGenerator: ToneGenerator? = null&#10;    private var vibrator: Vibrator? = null&#10;    private var textToSpeech: TextToSpeech? = null&#10;    private var ttsReady = false&#10;    private var sharedPreferences: SharedPreferences? = null&#10;    private val gson = Gson()&#10;&#10;    fun initializeAudio(context: Context) {&#10;        toneGenerator = ToneGenerator(AudioManager.STREAM_NOTIFICATION, 100)&#10;&#10;        // Use modern vibrator API&#10;        vibrator = if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.S) {&#10;            val vibratorManager = context.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            vibratorManager.defaultVibrator&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;&#10;        textToSpeech = TextToSpeech(context) { status -&gt;&#10;            if (status == TextToSpeech.SUCCESS) {&#10;                textToSpeech?.language = Locale.getDefault()&#10;                ttsReady = true&#10;            }&#10;        }&#10;&#10;        // Initialize SharedPreferences for saving configurations&#10;        sharedPreferences = context.getSharedPreferences(&quot;BoardGameTimer&quot;, Context.MODE_PRIVATE)&#10;        loadSavedConfigurations()&#10;        loadLastUsedConfiguration()&#10;    }&#10;&#10;    private fun loadLastUsedConfiguration() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = prefs.getString(&quot;last_used_configuration&quot;, null)&#10;            if (json != null) {&#10;                try {&#10;                    val lastConfig = gson.fromJson(json, GameConfiguration::class.java)&#10;                    // Ensure all phases have valid IDs for backward compatibility&#10;                    val configWithValidIds = lastConfig.copy(&#10;                        turnPhases = lastConfig.turnPhases.map { it.withValidId() }&#10;                    )&#10;                    gameConfiguration = configWithValidIds&#10;                    // Always update game state with the loaded configuration when app starts&#10;                    if (!gameState.isGameRunning) {&#10;                        val playerTurnTimes = List(configWithValidIds.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;                        val firstPhaseDuration = configWithValidIds.getCurrentPhaseDuration(0)&#10;                        gameState = GameState(&#10;                            currentPlayerIndex = 0,&#10;                            currentPhaseIndex = 0,&#10;                            timeRemainingSeconds = firstPhaseDuration,&#10;                            timeRemainingMillis = firstPhaseDuration * 1000L,&#10;                            playerTurnTimes = playerTurnTimes,&#10;                            isPaused = true, // Start paused by default&#10;                            isGameRunning = false&#10;                        )&#10;                    }&#10;                } catch (e: Exception) {&#10;                    // If loading fails, keep the default configuration&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveCurrentConfigurationAsDefault() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = gson.toJson(gameConfiguration)&#10;            prefs.edit().putString(&quot;last_used_configuration&quot;, json).apply()&#10;        }&#10;    }&#10;&#10;    fun startNewGame() {&#10;        val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;        val firstPhaseDuration = gameConfiguration.getCurrentPhaseDuration(0)&#10;        gameState = GameState(&#10;            currentPlayerIndex = 0,&#10;            currentPhaseIndex = 0, // Start with first phase&#10;            timeRemainingSeconds = firstPhaseDuration,&#10;            timeRemainingMillis = firstPhaseDuration * 1000L,&#10;            isGameRunning = true,&#10;            isPaused = false, // Start ready to play, not paused&#10;            roundCount = 0,&#10;            playerTurnTimes = playerTurnTimes,&#10;            gameStartTime = System.currentTimeMillis(),&#10;            turnStartTime = System.currentTimeMillis()&#10;        )&#10;        startTimer() // Auto-start the timer for the first player&#10;    }&#10;&#10;    fun nextPlayer() {&#10;        if (!gameState.isGameRunning) return&#10;&#10;        // Check if we need to advance to next phase or next player&#10;        val nextPhaseIndex = gameState.currentPhaseIndex + 1&#10;        val totalPhases = gameConfiguration.getTotalPhases()&#10;&#10;        if (nextPhaseIndex &lt; totalPhases) {&#10;            // Move to next phase for same player&#10;            nextPhase()&#10;        } else {&#10;            // Move to next player (reset to first phase)&#10;            moveToNextPlayer()&#10;        }&#10;    }&#10;&#10;    private fun nextPhase() {&#10;        // Play a beep sound when passing to next phase&#10;        playTurnPassBeep()&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        val nextPhaseIndex = gameState.currentPhaseIndex + 1&#10;        val phaseDuration = gameConfiguration.getCurrentPhaseDuration(nextPhaseIndex)&#10;        val nextPhase = gameConfiguration.turnPhases[nextPhaseIndex]&#10;&#10;        gameState = gameState.copy(&#10;            currentPhaseIndex = nextPhaseIndex,&#10;            timeRemainingSeconds = phaseDuration,&#10;            timeRemainingMillis = phaseDuration * 1000L,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = false,&#10;            // Reset dice state for new phase&#10;            dicePhaseState = DicePhaseState.WAITING_TO_THROW,&#10;            diceResult = null,&#10;            isDiceAnimating = false&#10;        )&#10;&#10;        // Auto-start timer for next phase (unless it's a dice phase waiting for throw)&#10;        if (nextPhase.phaseType != PhaseType.DICE_THROW || !shouldWaitForDiceThrow()) {&#10;            startTimer()&#10;        }&#10;    }&#10;&#10;    private fun moveToNextPlayer() {&#10;        // Play a beep sound when passing turn&#10;        playTurnPassBeep()&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        // Record the time taken for current player's turn (only record when completing all phases)&#10;        val timeTaken = gameConfiguration.getCurrentPhaseDuration(gameState.currentPhaseIndex) - gameState.timeRemainingSeconds&#10;        val currentPlayerTimes = gameState.playerTurnTimes[gameState.currentPlayerIndex].toMutableList()&#10;        currentPlayerTimes.add(timeTaken)&#10;&#10;        val updatedPlayerTurnTimes = gameState.playerTurnTimes.toMutableList()&#10;        updatedPlayerTurnTimes[gameState.currentPlayerIndex] = currentPlayerTimes&#10;&#10;        val nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameConfiguration.numberOfPlayers&#10;        val newRoundCount = if (nextPlayerIndex == 0) gameState.roundCount + 1 else gameState.roundCount&#10;        val firstPhaseDuration = gameConfiguration.getCurrentPhaseDuration(0)&#10;        val firstPhase = gameConfiguration.turnPhases[0]&#10;&#10;        gameState = gameState.copy(&#10;            currentPlayerIndex = nextPlayerIndex,&#10;            currentPhaseIndex = 0, // Reset to first phase for new player&#10;            timeRemainingSeconds = firstPhaseDuration,&#10;            timeRemainingMillis = firstPhaseDuration * 1000L,&#10;            playerTurnTimes = updatedPlayerTurnTimes,&#10;            roundCount = newRoundCount,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = false,&#10;            // Reset dice state for new player&#10;            dicePhaseState = DicePhaseState.WAITING_TO_THROW,&#10;            diceResult = null,&#10;            isDiceAnimating = false&#10;        )&#10;&#10;        // Auto-start timer for next player (unless first phase is a dice phase waiting for throw)&#10;        if (firstPhase.phaseType != PhaseType.DICE_THROW || !shouldWaitForDiceThrow()) {&#10;            startTimer()&#10;        }&#10;    }&#10;&#10;    fun undoLastAction() {&#10;        undoHistory?.let { previousState -&gt;&#10;            gameState = previousState&#10;            undoHistory = null&#10;            if (gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun pauseResumeGame() {&#10;        if (gameState.isGameRunning) {&#10;            gameState = gameState.copy(isPaused = !gameState.isPaused)&#10;            if (gameState.isPaused) {&#10;                timerJob?.cancel()&#10;            } else {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun endGame() {&#10;        timerJob?.cancel()&#10;        gameState = gameState.copy(isGameRunning = false, isPaused = false)&#10;        showStats = true&#10;    }&#10;&#10;    private fun startTimer() {&#10;        timerJob?.cancel()&#10;        timerJob = viewModelScope.launch {&#10;            var lastUpdateTime = System.currentTimeMillis()&#10;            var lastSecond = gameState.timeRemainingSeconds&#10;&#10;            while (gameState.timeRemainingMillis &gt; 0 &amp;&amp; gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                delay(16) // Update every 16ms for smooth animation (~60fps)&#10;&#10;                val currentTime = System.currentTimeMillis()&#10;                val deltaTime = currentTime - lastUpdateTime&#10;                lastUpdateTime = currentTime&#10;&#10;                val newTimeMillis = (gameState.timeRemainingMillis - deltaTime).coerceAtLeast(0L)&#10;                val newTimeSeconds = (newTimeMillis / 1000).toInt()&#10;&#10;                gameState = gameState.copy(&#10;                    timeRemainingMillis = newTimeMillis,&#10;                    timeRemainingSeconds = newTimeSeconds&#10;                )&#10;&#10;                // Handle audio alerts (only on second changes)&#10;                if (newTimeSeconds != lastSecond) {&#10;                    lastSecond = newTimeSeconds&#10;                    when (newTimeSeconds) {&#10;                        60 -&gt; if (gameConfiguration.audioAlert60s) playAlert()&#10;                        30 -&gt; if (gameConfiguration.audioAlert30s) playAlert()&#10;                        10, 9, 8, 7, 6, 5, 4, 3, 2, 1 -&gt; {&#10;                            if (gameConfiguration.audioAlert10sCountdown) {&#10;                                speakCountdown(newTimeSeconds)&#10;                            }&#10;                        }&#10;                        0 -&gt; {&#10;                            // Handle timeout with enhanced functionality&#10;                            handlePlayerTimeout()&#10;                            break&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handlePlayerTimeout() {&#10;        // Play timeout alert if enabled&#10;        if (gameConfiguration.audioAlertTimeOut) {&#10;            playAlert()&#10;        }&#10;&#10;        // Announce timeout with text-to-speech if enabled&#10;        if (gameConfiguration.audioAlertTimeOut &amp;&amp; ttsReady) {&#10;            val playerName = gameConfiguration.getPlayerName(gameState.currentPlayerIndex)&#10;            textToSpeech?.speak(&quot;$playerName ran out of time!&quot;, TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;&#10;        // Pause the game and show timeout dialog&#10;        gameState = gameState.copy(&#10;            isPaused = true,&#10;            showTimeExpiredDialog = true&#10;        )&#10;    }&#10;&#10;    fun dismissTimeExpiredDialog() {&#10;        gameState = gameState.copy(showTimeExpiredDialog = false)&#10;    }&#10;&#10;    fun continueAfterTimeout() {&#10;        // Reset timer to full duration and resume game&#10;        gameState = gameState.copy(&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            isPaused = false,&#10;            showTimeExpiredDialog = false&#10;        )&#10;        startTimer()&#10;    }&#10;&#10;    private fun playAlert() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_CDMA_ALERT_CALL_GUARD, 200)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun playTurnPassBeep() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_PROP_BEEP, 150)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun speakCountdown(seconds: Int) {&#10;        if (ttsReady) {&#10;            textToSpeech?.speak(seconds.toString(), TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    fun updateConfiguration(newConfig: GameConfiguration) {&#10;        gameConfiguration = newConfig&#10;        // Automatically save this configuration as the default for future app startups&#10;        saveCurrentConfigurationAsDefault()&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(newConfig.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = newConfig.turnDurationSeconds,&#10;                timeRemainingMillis = newConfig.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun saveConfiguration(name: String) {&#10;        if (name.isBlank()) return&#10;&#10;        val newConfig = SavedConfiguration(name, gameConfiguration)&#10;        val updatedConfigs = savedConfigurations.toMutableList()&#10;&#10;        // Remove existing config with same name&#10;        updatedConfigs.removeAll { it.name == name }&#10;        updatedConfigs.add(newConfig)&#10;&#10;        savedConfigurations = updatedConfigs&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    fun loadConfiguration(savedConfig: SavedConfiguration) {&#10;        gameConfiguration = savedConfig.configuration&#10;        // Automatically save this loaded configuration as the default for future app startups&#10;        saveCurrentConfigurationAsDefault()&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;                timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun deleteConfiguration(configName: String) {&#10;        savedConfigurations = savedConfigurations.filter { it.name != configName }&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    private fun loadSavedConfigurations() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = prefs.getString(&quot;saved_configurations&quot;, &quot;[]&quot;)&#10;            val type = object : TypeToken&lt;List&lt;SavedConfiguration&gt;&gt;() {}.type&#10;            try {&#10;                val loadedConfigurations = gson.fromJson&lt;List&lt;SavedConfiguration&gt;&gt;(json, type) ?: emptyList()&#10;                // Ensure all configurations have valid IDs for backward compatibility&#10;                savedConfigurations = loadedConfigurations.map { savedConfig -&gt;&#10;                    savedConfig.copy(&#10;                        configuration = savedConfig.configuration.copy(&#10;                            turnPhases = savedConfig.configuration.turnPhases.map { it.withValidId() }&#10;                        )&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                savedConfigurations = emptyList()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveToPersistentStorage() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = gson.toJson(savedConfigurations)&#10;            prefs.edit().putString(&quot;saved_configurations&quot;, json).apply()&#10;        }&#10;    }&#10;&#10;    fun showOptions() {&#10;        showOptions = true&#10;    }&#10;&#10;    fun hideOptions() {&#10;        showOptions = false&#10;    }&#10;&#10;    fun hideStats() {&#10;        showStats = false&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        toneGenerator?.release()&#10;        textToSpeech?.shutdown()&#10;    }&#10;&#10;    fun throwDice() {&#10;        val currentPhase = gameConfiguration.turnPhases[gameState.currentPhaseIndex]&#10;        if (currentPhase.phaseType != PhaseType.DICE_THROW) return&#10;&#10;        // Prevent throwing dice if game is not running&#10;        if (!gameState.isGameRunning) return&#10;&#10;        // Prevent throwing dice if already thrown in this phase&#10;        if (gameState.dicePhaseState != DicePhaseState.WAITING_TO_THROW) return&#10;&#10;        // Stop the countdown timer immediately when dice are thrown&#10;        timerJob?.cancel()&#10;&#10;        // Start dice animation and pause the game&#10;        gameState = gameState.copy(&#10;            isDiceAnimating = true,&#10;            dicePhaseState = DicePhaseState.THROWING,&#10;            isPaused = true // Pause the game to stop the countdown&#10;        )&#10;&#10;        // Simulate dice animation with out-of-sync changes for multiple dice&#10;        viewModelScope.launch {&#10;            val animationDuration = 3000L // Fixed at 3 seconds&#10;            val startTime = System.currentTimeMillis()&#10;&#10;            // Initialize with random values immediately to replace &quot;Tap to throw&quot;&#10;            var previousValues = (1..currentPhase.diceCount).map { (1..currentPhase.diceType.sides).random() }&#10;            val lastChangeTime = mutableListOf&lt;Long&gt;()&#10;            repeat(currentPhase.diceCount) { lastChangeTime.add(0L) }&#10;&#10;            // Set initial values immediately&#10;            gameState = gameState.copy(&#10;                diceResult = DiceResult(previousValues, previousValues.sum())&#10;            )&#10;&#10;            while (System.currentTimeMillis() - startTime &lt; animationDuration) {&#10;                val currentTime = System.currentTimeMillis() - startTime&#10;                val progress = currentTime.toFloat() / animationDuration.toFloat()&#10;&#10;                // Create deceleration curve - starts fast, gets slower&#10;                val decelerationFactor = 1.0f - (progress * progress) // Quadratic deceleration&#10;                val adjustedBaseInterval = (120L + (300L * progress)).toLong() // 120ms to 420ms (more controlled)&#10;&#10;                // Check each die individually and update immediately when it's time to change&#10;                for (index in 0 until currentPhase.diceCount) {&#10;                    val dieInterval = (adjustedBaseInterval + (index * 80L * decelerationFactor)).toLong()&#10;&#10;                    // Check if enough time has passed since this die's last change&#10;                    if (currentTime - lastChangeTime[index] &gt;= dieInterval) {&#10;                        // Time to change this die's value - update immediately&#10;                        lastChangeTime[index] = currentTime&#10;                        val newValue = (1..currentPhase.diceType.sides).random()&#10;&#10;                        // Update only this die's value immediately for perfect sync&#10;                        val updatedValues = previousValues.toMutableList()&#10;                        updatedValues[index] = newValue&#10;                        previousValues = updatedValues&#10;&#10;                        // Update state immediately when value changes&#10;                        gameState = gameState.copy(&#10;                            diceResult = DiceResult(previousValues, previousValues.sum())&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Fixed frame rate&#10;                delay(50L)&#10;            }&#10;&#10;            // Generate final result&#10;            val finalValues = (1..currentPhase.diceCount).map {&#10;                (1..currentPhase.diceType.sides).random()&#10;            }&#10;            gameState = gameState.copy(&#10;                isDiceAnimating = false,&#10;                diceResult = DiceResult(finalValues, finalValues.sum()),&#10;                dicePhaseState = DicePhaseState.SHOWING_RESULT&#10;            )&#10;&#10;            // Play dice sound effect&#10;            playDiceSound()&#10;&#10;            // Handle timer based on phase configuration&#10;            if (currentPhase.waitForPress) {&#10;                // If wait for press is enabled, just pause and wait for manual progression&#10;                gameState = gameState.copy(isPaused = true)&#10;            } else if (currentPhase.durationSeconds &gt; 0) {&#10;                // Start the timer with the configured duration&#10;                gameState = gameState.copy(&#10;                    timeRemainingSeconds = currentPhase.durationSeconds,&#10;                    timeRemainingMillis = currentPhase.durationSeconds * 1000L,&#10;                    isPaused = false&#10;                )&#10;                startTimer()&#10;            } else {&#10;                // Duration is 0, automatically proceed to next phase/player&#10;                delay(1000) // Show result for 1 second&#10;                nextPlayer()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun playDiceSound() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_PROP_BEEP, 200)&#10;    }&#10;&#10;    fun getCurrentPhase(): TurnPhase {&#10;        return gameConfiguration.turnPhases[gameState.currentPhaseIndex]&#10;    }&#10;&#10;    fun isDicePhase(): Boolean {&#10;        return getCurrentPhase().phaseType == PhaseType.DICE_THROW&#10;    }&#10;&#10;    fun shouldWaitForDiceThrow(): Boolean {&#10;        val currentPhase = getCurrentPhase()&#10;        return currentPhase.phaseType == PhaseType.DICE_THROW &amp;&amp;&#10;               gameState.dicePhaseState == DicePhaseState.WAITING_TO_THROW&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModelNew.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModelNew.kt" />
              <option name="updatedContent" value="package com.example.boardgametimer.viewmodel&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.media.AudioManager&#10;import android.media.ToneGenerator&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.speech.tts.TextToSpeech&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.GameState&#10;import com.example.boardgametimer.model.SavedConfiguration&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.util.Locale&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;&#10;class GameTimerViewModel : ViewModel() {&#10;&#10;    var gameState by mutableStateOf(GameState())&#10;        private set&#10;&#10;    var gameConfiguration by mutableStateOf(GameConfiguration())&#10;        private set&#10;&#10;    var showOptions by mutableStateOf(false)&#10;        private set&#10;&#10;    var showStats by mutableStateOf(false)&#10;        private set&#10;&#10;    var undoHistory by mutableStateOf&lt;GameState?&gt;(null)&#10;        private set&#10;&#10;    var savedConfigurations by mutableStateOf&lt;List&lt;SavedConfiguration&gt;&gt;(emptyList())&#10;        private set&#10;&#10;    private var timerJob: Job? = null&#10;    private var toneGenerator: ToneGenerator? = null&#10;    private var vibrator: Vibrator? = null&#10;    private var textToSpeech: TextToSpeech? = null&#10;    private var ttsReady = false&#10;    private var sharedPreferences: SharedPreferences? = null&#10;    private val gson = Gson()&#10;&#10;    fun initializeAudio(context: Context) {&#10;        toneGenerator = ToneGenerator(AudioManager.STREAM_NOTIFICATION, 100)&#10;&#10;        // Use modern vibrator API&#10;        vibrator = if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.S) {&#10;            val vibratorManager = context.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            vibratorManager.defaultVibrator&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;&#10;        textToSpeech = TextToSpeech(context) { status -&gt;&#10;            if (status == TextToSpeech.SUCCESS) {&#10;                textToSpeech?.language = Locale.getDefault()&#10;                ttsReady = true&#10;            }&#10;        }&#10;&#10;        // Initialize SharedPreferences for saving configurations&#10;        sharedPreferences = context.getSharedPreferences(&quot;BoardGameTimer&quot;, Context.MODE_PRIVATE)&#10;        loadSavedConfigurations()&#10;    }&#10;&#10;    fun startNewGame() {&#10;        val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;        gameState = GameState(&#10;            currentPlayerIndex = 0,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            isGameRunning = true,&#10;            isPaused = true, // Start paused&#10;            roundCount = 0,&#10;            playerTurnTimes = playerTurnTimes,&#10;            gameStartTime = System.currentTimeMillis(),&#10;            turnStartTime = System.currentTimeMillis()&#10;        )&#10;        // Don't start timer automatically - wait for user to resume&#10;    }&#10;&#10;    fun nextPlayer() {&#10;        if (!gameState.isGameRunning) return&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        // Record the time taken for current player's turn&#10;        val timeTaken = gameConfiguration.turnDurationSeconds - gameState.timeRemainingSeconds&#10;        val currentPlayerTimes = gameState.playerTurnTimes[gameState.currentPlayerIndex].toMutableList()&#10;        currentPlayerTimes.add(timeTaken)&#10;&#10;        val updatedPlayerTurnTimes = gameState.playerTurnTimes.toMutableList()&#10;        updatedPlayerTurnTimes[gameState.currentPlayerIndex] = currentPlayerTimes&#10;&#10;        val nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameConfiguration.numberOfPlayers&#10;        val newRoundCount = if (nextPlayerIndex == 0) gameState.roundCount + 1 else gameState.roundCount&#10;&#10;        gameState = gameState.copy(&#10;            currentPlayerIndex = nextPlayerIndex,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            playerTurnTimes = updatedPlayerTurnTimes,&#10;            roundCount = newRoundCount,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = true // Pause after each player switch&#10;        )&#10;&#10;        // Don't auto-start timer - let user resume manually&#10;    }&#10;&#10;    fun undoLastAction() {&#10;        undoHistory?.let { previousState -&gt;&#10;            gameState = previousState&#10;            undoHistory = null&#10;            if (gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun pauseResumeGame() {&#10;        if (gameState.isGameRunning) {&#10;            gameState = gameState.copy(isPaused = !gameState.isPaused)&#10;            if (gameState.isPaused) {&#10;                timerJob?.cancel()&#10;            } else {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun endGame() {&#10;        timerJob?.cancel()&#10;        gameState = gameState.copy(isGameRunning = false, isPaused = false)&#10;        showStats = true&#10;    }&#10;&#10;    private fun startTimer() {&#10;        timerJob?.cancel()&#10;        timerJob = viewModelScope.launch {&#10;            var lastUpdateTime = System.currentTimeMillis()&#10;            var lastSecond = gameState.timeRemainingSeconds&#10;            &#10;            while (gameState.timeRemainingMillis &gt; 0 &amp;&amp; gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                delay(16) // Update every 16ms for smooth animation (~60fps)&#10;                &#10;                val currentTime = System.currentTimeMillis()&#10;                val deltaTime = currentTime - lastUpdateTime&#10;                lastUpdateTime = currentTime&#10;                &#10;                val newTimeMillis = (gameState.timeRemainingMillis - deltaTime).coerceAtLeast(0L)&#10;                val newTimeSeconds = (newTimeMillis / 1000).toInt()&#10;                &#10;                gameState = gameState.copy(&#10;                    timeRemainingMillis = newTimeMillis,&#10;                    timeRemainingSeconds = newTimeSeconds&#10;                )&#10;&#10;                // Handle audio alerts (only on second changes)&#10;                if (newTimeSeconds != lastSecond) {&#10;                    lastSecond = newTimeSeconds&#10;                    when (newTimeSeconds) {&#10;                        60 -&gt; if (gameConfiguration.audioAlert60s) playAlert()&#10;                        30 -&gt; if (gameConfiguration.audioAlert30s) playAlert()&#10;                        10, 9, 8, 7, 6, 5, 4, 3, 2, 1 -&gt; {&#10;                            if (gameConfiguration.audioAlert10sCountdown) {&#10;                                speakCountdown(newTimeSeconds)&#10;                            }&#10;                        }&#10;                        0 -&gt; {&#10;                            if (gameConfiguration.audioAlertTimeOut) playAlert()&#10;                            break&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun playAlert() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_CDMA_ALERT_CALL_GUARD, 200)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun speakCountdown(seconds: Int) {&#10;        if (ttsReady) {&#10;            textToSpeech?.speak(seconds.toString(), TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    fun updateConfiguration(newConfig: GameConfiguration) {&#10;        gameConfiguration = newConfig&#10;        // Reset game state with new configuration&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(newConfig.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = newConfig.turnDurationSeconds,&#10;                timeRemainingMillis = newConfig.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = true&#10;            )&#10;        }&#10;    }&#10;&#10;    fun saveConfiguration(name: String) {&#10;        if (name.isBlank()) return&#10;        &#10;        val newConfig = SavedConfiguration(name, gameConfiguration)&#10;        val updatedConfigs = savedConfigurations.toMutableList()&#10;        &#10;        // Remove existing config with same name&#10;        updatedConfigs.removeAll { it.name == name }&#10;        updatedConfigs.add(newConfig)&#10;        &#10;        savedConfigurations = updatedConfigs&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    fun loadConfiguration(savedConfig: SavedConfiguration) {&#10;        gameConfiguration = savedConfig.configuration&#10;        // Reset game state with new configuration&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;                timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = true&#10;            )&#10;        }&#10;    }&#10;&#10;    fun deleteConfiguration(configName: String) {&#10;        savedConfigurations = savedConfigurations.filter { it.name != configName }&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    private fun loadSavedConfigurations() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = prefs.getString(&quot;saved_configurations&quot;, &quot;[]&quot;)&#10;            val type = object : TypeToken&lt;List&lt;SavedConfiguration&gt;&gt;() {}.type&#10;            try {&#10;                savedConfigurations = gson.fromJson(json, type) ?: emptyList()&#10;            } catch (e: Exception) {&#10;                savedConfigurations = emptyList()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveToPersistentStorage() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = gson.toJson(savedConfigurations)&#10;            prefs.edit().putString(&quot;saved_configurations&quot;, json).apply()&#10;        }&#10;    }&#10;&#10;    fun showOptions() {&#10;        showOptions = true&#10;    }&#10;&#10;    fun hideOptions() {&#10;        showOptions = false&#10;    }&#10;&#10;    fun hideStats() {&#10;        showStats = false&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        toneGenerator?.release()&#10;        textToSpeech?.shutdown()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModel_Fixed.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModel_Fixed.kt" />
              <option name="updatedContent" value="package com.example.boardgametimer.viewmodel&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.media.AudioManager&#10;import android.media.ToneGenerator&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.speech.tts.TextToSpeech&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.GameState&#10;import com.example.boardgametimer.model.SavedConfiguration&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.util.Locale&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;&#10;class GameTimerViewModel : ViewModel() {&#10;&#10;    var gameState by mutableStateOf(GameState())&#10;        private set&#10;&#10;    var gameConfiguration by mutableStateOf(GameConfiguration())&#10;        private set&#10;&#10;    var showOptions by mutableStateOf(false)&#10;        private set&#10;&#10;    var showStats by mutableStateOf(false)&#10;        private set&#10;&#10;    var undoHistory by mutableStateOf&lt;GameState?&gt;(null)&#10;        private set&#10;&#10;    var savedConfigurations by mutableStateOf&lt;List&lt;SavedConfiguration&gt;&gt;(emptyList())&#10;        private set&#10;&#10;    private var timerJob: Job? = null&#10;    private var toneGenerator: ToneGenerator? = null&#10;    private var vibrator: Vibrator? = null&#10;    private var textToSpeech: TextToSpeech? = null&#10;    private var ttsReady = false&#10;    private var sharedPreferences: SharedPreferences? = null&#10;    private val gson = Gson()&#10;&#10;    fun initializeAudio(context: Context) {&#10;        toneGenerator = ToneGenerator(AudioManager.STREAM_NOTIFICATION, 100)&#10;&#10;        // Use modern vibrator API&#10;        vibrator = if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.S) {&#10;            val vibratorManager = context.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            vibratorManager.defaultVibrator&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;&#10;        textToSpeech = TextToSpeech(context) { status -&gt;&#10;            if (status == TextToSpeech.SUCCESS) {&#10;                textToSpeech?.language = Locale.getDefault()&#10;                ttsReady = true&#10;            }&#10;        }&#10;&#10;        // Initialize SharedPreferences for saving configurations&#10;        sharedPreferences = context.getSharedPreferences(&quot;BoardGameTimer&quot;, Context.MODE_PRIVATE)&#10;        loadSavedConfigurations()&#10;    }&#10;&#10;    fun startNewGame() {&#10;        val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;        gameState = GameState(&#10;            currentPlayerIndex = 0,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            isGameRunning = true,&#10;            isPaused = false, // Start ready to play, not paused&#10;            roundCount = 0,&#10;            playerTurnTimes = playerTurnTimes,&#10;            gameStartTime = System.currentTimeMillis(),&#10;            turnStartTime = System.currentTimeMillis()&#10;        )&#10;        startTimer() // Auto-start the timer for the first player&#10;    }&#10;&#10;    fun nextPlayer() {&#10;        if (!gameState.isGameRunning) return&#10;&#10;        // Play a beep sound when passing turn&#10;        playTurnPassBeep()&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        // Record the time taken for current player's turn&#10;        val timeTaken = gameConfiguration.turnDurationSeconds - gameState.timeRemainingSeconds&#10;        val currentPlayerTimes = gameState.playerTurnTimes[gameState.currentPlayerIndex].toMutableList()&#10;        currentPlayerTimes.add(timeTaken)&#10;&#10;        val updatedPlayerTurnTimes = gameState.playerTurnTimes.toMutableList()&#10;        updatedPlayerTurnTimes[gameState.currentPlayerIndex] = currentPlayerTimes&#10;&#10;        val nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameConfiguration.numberOfPlayers&#10;        val newRoundCount = if (nextPlayerIndex == 0) gameState.roundCount + 1 else gameState.roundCount&#10;&#10;        gameState = gameState.copy(&#10;            currentPlayerIndex = nextPlayerIndex,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            playerTurnTimes = updatedPlayerTurnTimes,&#10;            roundCount = newRoundCount,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = false // Don't pause after each player switch&#10;        )&#10;&#10;        // Auto-start timer for next player&#10;        startTimer()&#10;    }&#10;&#10;    fun undoLastAction() {&#10;        undoHistory?.let { previousState -&gt;&#10;            gameState = previousState&#10;            undoHistory = null&#10;            if (gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun pauseResumeGame() {&#10;        if (gameState.isGameRunning) {&#10;            gameState = gameState.copy(isPaused = !gameState.isPaused)&#10;            if (gameState.isPaused) {&#10;                timerJob?.cancel()&#10;            } else {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun endGame() {&#10;        timerJob?.cancel()&#10;        gameState = gameState.copy(isGameRunning = false, isPaused = false)&#10;        showStats = true&#10;    }&#10;&#10;    private fun startTimer() {&#10;        timerJob?.cancel()&#10;        timerJob = viewModelScope.launch {&#10;            var lastUpdateTime = System.currentTimeMillis()&#10;            var lastSecond = gameState.timeRemainingSeconds&#10;&#10;            while (gameState.timeRemainingMillis &gt; 0 &amp;&amp; gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                delay(16) // Update every 16ms for smooth animation (~60fps)&#10;&#10;                val currentTime = System.currentTimeMillis()&#10;                val deltaTime = currentTime - lastUpdateTime&#10;                lastUpdateTime = currentTime&#10;&#10;                val newTimeMillis = (gameState.timeRemainingMillis - deltaTime).coerceAtLeast(0L)&#10;                val newTimeSeconds = (newTimeMillis / 1000).toInt()&#10;&#10;                gameState = gameState.copy(&#10;                    timeRemainingMillis = newTimeMillis,&#10;                    timeRemainingSeconds = newTimeSeconds&#10;                )&#10;&#10;                // Handle audio alerts (only on second changes)&#10;                if (newTimeSeconds != lastSecond) {&#10;                    lastSecond = newTimeSeconds&#10;                    when (newTimeSeconds) {&#10;                        60 -&gt; if (gameConfiguration.audioAlert60s) playAlert()&#10;                        30 -&gt; if (gameConfiguration.audioAlert30s) playAlert()&#10;                        10, 9, 8, 7, 6, 5, 4, 3, 2, 1 -&gt; {&#10;                            if (gameConfiguration.audioAlert10sCountdown) {&#10;                                speakCountdown(newTimeSeconds)&#10;                            }&#10;                        }&#10;                        0 -&gt; {&#10;                            if (gameConfiguration.audioAlertTimeOut) playAlert()&#10;                            break&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun playAlert() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_CDMA_ALERT_CALL_GUARD, 200)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun playTurnPassBeep() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_PROP_BEEP, 150)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun speakCountdown(seconds: Int) {&#10;        if (ttsReady) {&#10;            textToSpeech?.speak(seconds.toString(), TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    fun updateConfiguration(newConfig: GameConfiguration) {&#10;        gameConfiguration = newConfig&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(newConfig.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = newConfig.turnDurationSeconds,&#10;                timeRemainingMillis = newConfig.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun saveConfiguration(name: String) {&#10;        if (name.isBlank()) return&#10;&#10;        val newConfig = SavedConfiguration(name, gameConfiguration)&#10;        val updatedConfigs = savedConfigurations.toMutableList()&#10;&#10;        // Remove existing config with same name&#10;        updatedConfigs.removeAll { it.name == name }&#10;        updatedConfigs.add(newConfig)&#10;&#10;        savedConfigurations = updatedConfigs&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    fun loadConfiguration(savedConfig: SavedConfiguration) {&#10;        gameConfiguration = savedConfig.configuration&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;                timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun deleteConfiguration(configName: String) {&#10;        savedConfigurations = savedConfigurations.filter { it.name != configName }&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    private fun loadSavedConfigurations() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = prefs.getString(&quot;saved_configurations&quot;, &quot;[]&quot;)&#10;            val type = object : TypeToken&lt;List&lt;SavedConfiguration&gt;&gt;() {}.type&#10;            try {&#10;                savedConfigurations = gson.fromJson(json, type) ?: emptyList()&#10;            } catch (e: Exception) {&#10;                savedConfigurations = emptyList()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveToPersistentStorage() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = gson.toJson(savedConfigurations)&#10;            prefs.edit().putString(&quot;saved_configurations&quot;, json).apply()&#10;        }&#10;    }&#10;&#10;    fun showOptions() {&#10;        showOptions = true&#10;    }&#10;&#10;    fun hideOptions() {&#10;        showOptions = false&#10;    }&#10;&#10;    fun hideStats() {&#10;        showStats = false&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        toneGenerator?.release()&#10;        textToSpeech?.shutdown()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModel_updated.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/boardgametimer/viewmodel/GameTimerViewModel_updated.kt" />
              <option name="updatedContent" value="package com.example.boardgametimer.viewmodel&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.media.AudioManager&#10;import android.media.ToneGenerator&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.speech.tts.TextToSpeech&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.boardgametimer.model.GameConfiguration&#10;import com.example.boardgametimer.model.GameState&#10;import com.example.boardgametimer.model.SavedConfiguration&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.util.Locale&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;&#10;class GameTimerViewModel : ViewModel() {&#10;&#10;    var gameState by mutableStateOf(GameState())&#10;        private set&#10;&#10;    var gameConfiguration by mutableStateOf(GameConfiguration())&#10;        private set&#10;&#10;    var showOptions by mutableStateOf(false)&#10;        private set&#10;&#10;    var showStats by mutableStateOf(false)&#10;        private set&#10;&#10;    var undoHistory by mutableStateOf&lt;GameState?&gt;(null)&#10;        private set&#10;&#10;    var savedConfigurations by mutableStateOf&lt;List&lt;SavedConfiguration&gt;&gt;(emptyList())&#10;        private set&#10;&#10;    private var timerJob: Job? = null&#10;    private var toneGenerator: ToneGenerator? = null&#10;    private var vibrator: Vibrator? = null&#10;    private var textToSpeech: TextToSpeech? = null&#10;    private var ttsReady = false&#10;    private var sharedPreferences: SharedPreferences? = null&#10;    private val gson = Gson()&#10;&#10;    fun initializeAudio(context: Context) {&#10;        toneGenerator = ToneGenerator(AudioManager.STREAM_NOTIFICATION, 100)&#10;&#10;        // Use modern vibrator API&#10;        vibrator = if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.S) {&#10;            val vibratorManager = context.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            vibratorManager.defaultVibrator&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;&#10;        textToSpeech = TextToSpeech(context) { status -&gt;&#10;            if (status == TextToSpeech.SUCCESS) {&#10;                textToSpeech?.language = Locale.getDefault()&#10;                ttsReady = true&#10;            }&#10;        }&#10;&#10;        // Initialize SharedPreferences for saving configurations&#10;        sharedPreferences = context.getSharedPreferences(&quot;BoardGameTimer&quot;, Context.MODE_PRIVATE)&#10;        loadSavedConfigurations()&#10;    }&#10;&#10;    fun startNewGame() {&#10;        val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;        gameState = GameState(&#10;            currentPlayerIndex = 0,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            isGameRunning = true,&#10;            isPaused = false, // Start ready to play, not paused&#10;            roundCount = 0,&#10;            playerTurnTimes = playerTurnTimes,&#10;            gameStartTime = System.currentTimeMillis(),&#10;            turnStartTime = System.currentTimeMillis()&#10;        )&#10;        startTimer() // Auto-start the timer for the first player&#10;    }&#10;&#10;    fun nextPlayer() {&#10;        if (!gameState.isGameRunning) return&#10;&#10;        // Play a beep sound when passing turn&#10;        playTurnPassBeep()&#10;&#10;        // Save current state for undo&#10;        undoHistory = gameState.copy()&#10;&#10;        // Record the time taken for current player's turn&#10;        val timeTaken = gameConfiguration.turnDurationSeconds - gameState.timeRemainingSeconds&#10;        val currentPlayerTimes = gameState.playerTurnTimes[gameState.currentPlayerIndex].toMutableList()&#10;        currentPlayerTimes.add(timeTaken)&#10;&#10;        val updatedPlayerTurnTimes = gameState.playerTurnTimes.toMutableList()&#10;        updatedPlayerTurnTimes[gameState.currentPlayerIndex] = currentPlayerTimes&#10;&#10;        val nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameConfiguration.numberOfPlayers&#10;        val newRoundCount = if (nextPlayerIndex == 0) gameState.roundCount + 1 else gameState.roundCount&#10;&#10;        gameState = gameState.copy(&#10;            currentPlayerIndex = nextPlayerIndex,&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            playerTurnTimes = updatedPlayerTurnTimes,&#10;            roundCount = newRoundCount,&#10;            turnStartTime = System.currentTimeMillis(),&#10;            isPaused = false // Don't pause after each player switch&#10;        )&#10;&#10;        // Auto-start timer for next player&#10;        startTimer()&#10;    }&#10;&#10;    fun undoLastAction() {&#10;        undoHistory?.let { previousState -&gt;&#10;            gameState = previousState&#10;            undoHistory = null&#10;            if (gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun pauseResumeGame() {&#10;        if (gameState.isGameRunning) {&#10;            gameState = gameState.copy(isPaused = !gameState.isPaused)&#10;            if (gameState.isPaused) {&#10;                timerJob?.cancel()&#10;            } else {&#10;                startTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun endGame() {&#10;        timerJob?.cancel()&#10;        gameState = gameState.copy(isGameRunning = false, isPaused = false)&#10;        showStats = true&#10;    }&#10;&#10;    private fun startTimer() {&#10;        timerJob?.cancel()&#10;        timerJob = viewModelScope.launch {&#10;            var lastUpdateTime = System.currentTimeMillis()&#10;            var lastSecond = gameState.timeRemainingSeconds&#10;&#10;            while (gameState.timeRemainingMillis &gt; 0 &amp;&amp; gameState.isGameRunning &amp;&amp; !gameState.isPaused) {&#10;                delay(16) // Update every 16ms for smooth animation (~60fps)&#10;&#10;                val currentTime = System.currentTimeMillis()&#10;                val deltaTime = currentTime - lastUpdateTime&#10;                lastUpdateTime = currentTime&#10;&#10;                val newTimeMillis = (gameState.timeRemainingMillis - deltaTime).coerceAtLeast(0L)&#10;                val newTimeSeconds = (newTimeMillis / 1000).toInt()&#10;&#10;                gameState = gameState.copy(&#10;                    timeRemainingMillis = newTimeMillis,&#10;                    timeRemainingSeconds = newTimeSeconds&#10;                )&#10;&#10;                // Handle audio alerts (only on second changes)&#10;                if (newTimeSeconds != lastSecond) {&#10;                    lastSecond = newTimeSeconds&#10;                    when (newTimeSeconds) {&#10;                        60 -&gt; if (gameConfiguration.audioAlert60s) playAlert()&#10;                        30 -&gt; if (gameConfiguration.audioAlert30s) playAlert()&#10;                        10, 9, 8, 7, 6, 5, 4, 3, 2, 1 -&gt; {&#10;                            if (gameConfiguration.audioAlert10sCountdown) {&#10;                                speakCountdown(newTimeSeconds)&#10;                            }&#10;                        }&#10;                        0 -&gt; {&#10;                            // Handle timeout with enhanced functionality&#10;                            handlePlayerTimeout()&#10;                            break&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handlePlayerTimeout() {&#10;        // Play timeout alert if enabled&#10;        if (gameConfiguration.audioAlertTimeOut) {&#10;            playAlert()&#10;        }&#10;        &#10;        // Announce timeout with text-to-speech if enabled&#10;        if (gameConfiguration.audioAlertTimeOut &amp;&amp; ttsReady) {&#10;            val playerName = gameConfiguration.getPlayerName(gameState.currentPlayerIndex)&#10;            textToSpeech?.speak(&quot;$playerName ran out of time!&quot;, TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;        &#10;        // Pause the game and show timeout dialog&#10;        gameState = gameState.copy(&#10;            isPaused = true,&#10;            showTimeExpiredDialog = true&#10;        )&#10;    }&#10;&#10;    fun dismissTimeExpiredDialog() {&#10;        gameState = gameState.copy(showTimeExpiredDialog = false)&#10;    }&#10;&#10;    fun continueAfterTimeout() {&#10;        // Reset timer to full duration and resume game&#10;        gameState = gameState.copy(&#10;            timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;            timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;            isPaused = false,&#10;            showTimeExpiredDialog = false&#10;        )&#10;        startTimer()&#10;    }&#10;&#10;    private fun playAlert() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_CDMA_ALERT_CALL_GUARD, 200)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun playTurnPassBeep() {&#10;        toneGenerator?.startTone(ToneGenerator.TONE_PROP_BEEP, 150)&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    private fun speakCountdown(seconds: Int) {&#10;        if (ttsReady) {&#10;            textToSpeech?.speak(seconds.toString(), TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;        if (gameConfiguration.vibrateOnAlerts) {&#10;            vibrator?.vibrate(VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        }&#10;    }&#10;&#10;    fun updateConfiguration(newConfig: GameConfiguration) {&#10;        gameConfiguration = newConfig&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(newConfig.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = newConfig.turnDurationSeconds,&#10;                timeRemainingMillis = newConfig.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun saveConfiguration(name: String) {&#10;        if (name.isBlank()) return&#10;&#10;        val newConfig = SavedConfiguration(name, gameConfiguration)&#10;        val updatedConfigs = savedConfigurations.toMutableList()&#10;&#10;        // Remove existing config with same name&#10;        updatedConfigs.removeAll { it.name == name }&#10;        updatedConfigs.add(newConfig)&#10;&#10;        savedConfigurations = updatedConfigs&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    fun loadConfiguration(savedConfig: SavedConfiguration) {&#10;        gameConfiguration = savedConfig.configuration&#10;        // Reset game state with new configuration only if game is not running&#10;        if (!gameState.isGameRunning) {&#10;            val playerTurnTimes = List(gameConfiguration.numberOfPlayers) { mutableListOf&lt;Int&gt;() }&#10;            gameState = GameState(&#10;                timeRemainingSeconds = gameConfiguration.turnDurationSeconds,&#10;                timeRemainingMillis = gameConfiguration.turnDurationSeconds * 1000L,&#10;                playerTurnTimes = playerTurnTimes,&#10;                isPaused = false, // Ready to start, not paused&#10;                isGameRunning = false // Not running until user starts&#10;            )&#10;        }&#10;    }&#10;&#10;    fun deleteConfiguration(configName: String) {&#10;        savedConfigurations = savedConfigurations.filter { it.name != configName }&#10;        saveToPersistentStorage()&#10;    }&#10;&#10;    private fun loadSavedConfigurations() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = prefs.getString(&quot;saved_configurations&quot;, &quot;[]&quot;)&#10;            val type = object : TypeToken&lt;List&lt;SavedConfiguration&gt;&gt;() {}.type&#10;            try {&#10;                savedConfigurations = gson.fromJson(json, type) ?: emptyList()&#10;            } catch (e: Exception) {&#10;                savedConfigurations = emptyList()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun saveToPersistentStorage() {&#10;        sharedPreferences?.let { prefs -&gt;&#10;            val json = gson.toJson(savedConfigurations)&#10;            prefs.edit().putString(&quot;saved_configurations&quot;, json).apply()&#10;        }&#10;    }&#10;&#10;    fun showOptions() {&#10;        showOptions = true&#10;    }&#10;&#10;    fun hideOptions() {&#10;        showOptions = false&#10;    }&#10;&#10;    fun hideStats() {&#10;        showStats = false&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        toneGenerator?.release()&#10;        textToSpeech?.shutdown()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>